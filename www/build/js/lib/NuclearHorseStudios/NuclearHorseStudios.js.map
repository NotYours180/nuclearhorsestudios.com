{"version":3,"file":"NuclearHorseStudios.js","sources":["../dep/jquery.js","../dep/jqueryPrivate.js","../dep/angular.js","../dep/angular-resource.js","../dep/angular-route.js","RecentBlogPosts.js","BlogAddPostController.js","BlogDeletePostController.js","BlogAdminController.js","AdminController.js","CreationsController.js","ContactController.js","Controllers.js","../dep/underscore.min.js","../DbTypeFactory.js","Filters/MarkdownFilter.js","Filters/BlogPostDateFilter.js","RouteProvider.js","../dep/showdown.js","NuclearHorseStudios.js"],"names":[],"mappings":"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","sourcesContent":["\n/*!\n * jQuery JavaScript Library v1.10.2\n * http://jquery.com/\n *\n * Includes Sizzle.js\n * http://sizzlejs.com/\n *\n * Copyright 2005, 2013 jQuery Foundation, Inc. and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2013-07-03T13:48Z\n */\n(function( window, undefined ) {\n\n// Can't do this because several apps including ASP.NET trace\n// the stack via arguments.caller.callee and Firefox dies if\n// you try to trace through \"use strict\" call chains. (#13335)\n// Support: Firefox 18+\n//\"use strict\";\nvar\n    // The deferred used on DOM ready\n    readyList,\n\n    // A central reference to the root jQuery(document)\n    rootjQuery,\n\n    // Support: IE<10\n    // For `typeof xmlNode.method` instead of `xmlNode.method !== undefined`\n    core_strundefined = typeof undefined,\n\n    // Use the correct document accordingly with window argument (sandbox)\n    location = window.location,\n    document = window.document,\n    docElem = document.documentElement,\n\n    // Map over jQuery in case of overwrite\n    _jQuery = window.jQuery,\n\n    // Map over the $ in case of overwrite\n    _$ = window.$,\n\n    // [[Class]] -> type pairs\n    class2type = {},\n\n    // List of deleted data cache ids, so we can reuse them\n    core_deletedIds = [],\n\n    core_version = \"1.10.2\",\n\n    // Save a reference to some core methods\n    core_concat = core_deletedIds.concat,\n    core_push = core_deletedIds.push,\n    core_slice = core_deletedIds.slice,\n    core_indexOf = core_deletedIds.indexOf,\n    core_toString = class2type.toString,\n    core_hasOwn = class2type.hasOwnProperty,\n    core_trim = core_version.trim,\n\n    // Define a local copy of jQuery\n    jQuery = function( selector, context ) {\n        // The jQuery object is actually just the init constructor 'enhanced'\n        return new jQuery.fn.init( selector, context, rootjQuery );\n    },\n\n    // Used for matching numbers\n    core_pnum = /[+-]?(?:\\d*\\.|)\\d+(?:[eE][+-]?\\d+|)/.source,\n\n    // Used for splitting on whitespace\n    core_rnotwhite = /\\S+/g,\n\n    // Make sure we trim BOM and NBSP (here's looking at you, Safari 5.0 and IE)\n    rtrim = /^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g,\n\n    // A simple way to check for HTML strings\n    // Prioritize #id over <tag> to avoid XSS via location.hash (#9521)\n    // Strict HTML recognition (#11290: must start with <)\n    rquickExpr = /^(?:\\s*(<[\\w\\W]+>)[^>]*|#([\\w-]*))$/,\n\n    // Match a standalone tag\n    rsingleTag = /^<(\\w+)\\s*\\/?>(?:<\\/\\1>|)$/,\n\n    // JSON RegExp\n    rvalidchars = /^[\\],:{}\\s]*$/,\n    rvalidbraces = /(?:^|:|,)(?:\\s*\\[)+/g,\n    rvalidescape = /\\\\(?:[\"\\\\\\/bfnrt]|u[\\da-fA-F]{4})/g,\n    rvalidtokens = /\"[^\"\\\\\\r\\n]*\"|true|false|null|-?(?:\\d+\\.|)\\d+(?:[eE][+-]?\\d+|)/g,\n\n    // Matches dashed string for camelizing\n    rmsPrefix = /^-ms-/,\n    rdashAlpha = /-([\\da-z])/gi,\n\n    // Used by jQuery.camelCase as callback to replace()\n    fcamelCase = function( all, letter ) {\n        return letter.toUpperCase();\n    },\n\n    // The ready event handler\n    completed = function( event ) {\n\n        // readyState === \"complete\" is good enough for us to call the dom ready in oldIE\n        if ( document.addEventListener || event.type === \"load\" || document.readyState === \"complete\" ) {\n            detach();\n            jQuery.ready();\n        }\n    },\n    // Clean-up method for dom ready events\n    detach = function() {\n        if ( document.addEventListener ) {\n            document.removeEventListener( \"DOMContentLoaded\", completed, false );\n            window.removeEventListener( \"load\", completed, false );\n\n        } else {\n            document.detachEvent( \"onreadystatechange\", completed );\n            window.detachEvent( \"onload\", completed );\n        }\n    };\n\njQuery.fn = jQuery.prototype = {\n    // The current version of jQuery being used\n    jquery: core_version,\n\n    constructor: jQuery,\n    init: function( selector, context, rootjQuery ) {\n        var match, elem;\n\n        // HANDLE: $(\"\"), $(null), $(undefined), $(false)\n        if ( !selector ) {\n            return this;\n        }\n\n        // Handle HTML strings\n        if ( typeof selector === \"string\" ) {\n            if ( selector.charAt(0) === \"<\" && selector.charAt( selector.length - 1 ) === \">\" && selector.length >= 3 ) {\n                // Assume that strings that start and end with <> are HTML and skip the regex check\n                match = [ null, selector, null ];\n\n            } else {\n                match = rquickExpr.exec( selector );\n            }\n\n            // Match html or make sure no context is specified for #id\n            if ( match && (match[1] || !context) ) {\n\n                // HANDLE: $(html) -> $(array)\n                if ( match[1] ) {\n                    context = context instanceof jQuery ? context[0] : context;\n\n                    // scripts is true for back-compat\n                    jQuery.merge( this, jQuery.parseHTML(\n                        match[1],\n                        context && context.nodeType ? context.ownerDocument || context : document,\n                        true\n                    ) );\n\n                    // HANDLE: $(html, props)\n                    if ( rsingleTag.test( match[1] ) && jQuery.isPlainObject( context ) ) {\n                        for ( match in context ) {\n                            // Properties of context are called as methods if possible\n                            if ( jQuery.isFunction( this[ match ] ) ) {\n                                this[ match ]( context[ match ] );\n\n                            // ...and otherwise set as attributes\n                            } else {\n                                this.attr( match, context[ match ] );\n                            }\n                        }\n                    }\n\n                    return this;\n\n                // HANDLE: $(#id)\n                } else {\n                    elem = document.getElementById( match[2] );\n\n                    // Check parentNode to catch when Blackberry 4.6 returns\n                    // nodes that are no longer in the document #6963\n                    if ( elem && elem.parentNode ) {\n                        // Handle the case where IE and Opera return items\n                        // by name instead of ID\n                        if ( elem.id !== match[2] ) {\n                            return rootjQuery.find( selector );\n                        }\n\n                        // Otherwise, we inject the element directly into the jQuery object\n                        this.length = 1;\n                        this[0] = elem;\n                    }\n\n                    this.context = document;\n                    this.selector = selector;\n                    return this;\n                }\n\n            // HANDLE: $(expr, $(...))\n            } else if ( !context || context.jquery ) {\n                return ( context || rootjQuery ).find( selector );\n\n            // HANDLE: $(expr, context)\n            // (which is just equivalent to: $(context).find(expr)\n            } else {\n                return this.constructor( context ).find( selector );\n            }\n\n        // HANDLE: $(DOMElement)\n        } else if ( selector.nodeType ) {\n            this.context = this[0] = selector;\n            this.length = 1;\n            return this;\n\n        // HANDLE: $(function)\n        // Shortcut for document ready\n        } else if ( jQuery.isFunction( selector ) ) {\n            return rootjQuery.ready( selector );\n        }\n\n        if ( selector.selector !== undefined ) {\n            this.selector = selector.selector;\n            this.context = selector.context;\n        }\n\n        return jQuery.makeArray( selector, this );\n    },\n\n    // Start with an empty selector\n    selector: \"\",\n\n    // The default length of a jQuery object is 0\n    length: 0,\n\n    toArray: function() {\n        return core_slice.call( this );\n    },\n\n    // Get the Nth element in the matched element set OR\n    // Get the whole matched element set as a clean array\n    get: function( num ) {\n        return num == null ?\n\n            // Return a 'clean' array\n            this.toArray() :\n\n            // Return just the object\n            ( num < 0 ? this[ this.length + num ] : this[ num ] );\n    },\n\n    // Take an array of elements and push it onto the stack\n    // (returning the new matched element set)\n    pushStack: function( elems ) {\n\n        // Build a new jQuery matched element set\n        var ret = jQuery.merge( this.constructor(), elems );\n\n        // Add the old object onto the stack (as a reference)\n        ret.prevObject = this;\n        ret.context = this.context;\n\n        // Return the newly-formed element set\n        return ret;\n    },\n\n    // Execute a callback for every element in the matched set.\n    // (You can seed the arguments with an array of args, but this is\n    // only used internally.)\n    each: function( callback, args ) {\n        return jQuery.each( this, callback, args );\n    },\n\n    ready: function( fn ) {\n        // Add the callback\n        jQuery.ready.promise().done( fn );\n\n        return this;\n    },\n\n    slice: function() {\n        return this.pushStack( core_slice.apply( this, arguments ) );\n    },\n\n    first: function() {\n        return this.eq( 0 );\n    },\n\n    last: function() {\n        return this.eq( -1 );\n    },\n\n    eq: function( i ) {\n        var len = this.length,\n            j = +i + ( i < 0 ? len : 0 );\n        return this.pushStack( j >= 0 && j < len ? [ this[j] ] : [] );\n    },\n\n    map: function( callback ) {\n        return this.pushStack( jQuery.map(this, function( elem, i ) {\n            return callback.call( elem, i, elem );\n        }));\n    },\n\n    end: function() {\n        return this.prevObject || this.constructor(null);\n    },\n\n    // For internal use only.\n    // Behaves like an Array's method, not like a jQuery method.\n    push: core_push,\n    sort: [].sort,\n    splice: [].splice\n};\n\n// Give the init function the jQuery prototype for later instantiation\njQuery.fn.init.prototype = jQuery.fn;\n\njQuery.extend = jQuery.fn.extend = function() {\n    var src, copyIsArray, copy, name, options, clone,\n        target = arguments[0] || {},\n        i = 1,\n        length = arguments.length,\n        deep = false;\n\n    // Handle a deep copy situation\n    if ( typeof target === \"boolean\" ) {\n        deep = target;\n        target = arguments[1] || {};\n        // skip the boolean and the target\n        i = 2;\n    }\n\n    // Handle case when target is a string or something (possible in deep copy)\n    if ( typeof target !== \"object\" && !jQuery.isFunction(target) ) {\n        target = {};\n    }\n\n    // extend jQuery itself if only one argument is passed\n    if ( length === i ) {\n        target = this;\n        --i;\n    }\n\n    for ( ; i < length; i++ ) {\n        // Only deal with non-null/undefined values\n        if ( (options = arguments[ i ]) != null ) {\n            // Extend the base object\n            for ( name in options ) {\n                src = target[ name ];\n                copy = options[ name ];\n\n                // Prevent never-ending loop\n                if ( target === copy ) {\n                    continue;\n                }\n\n                // Recurse if we're merging plain objects or arrays\n                if ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {\n                    if ( copyIsArray ) {\n                        copyIsArray = false;\n                        clone = src && jQuery.isArray(src) ? src : [];\n\n                    } else {\n                        clone = src && jQuery.isPlainObject(src) ? src : {};\n                    }\n\n                    // Never move original objects, clone them\n                    target[ name ] = jQuery.extend( deep, clone, copy );\n\n                // Don't bring in undefined values\n                } else if ( copy !== undefined ) {\n                    target[ name ] = copy;\n                }\n            }\n        }\n    }\n\n    // Return the modified object\n    return target;\n};\n\njQuery.extend({\n    // Unique for each copy of jQuery on the page\n    // Non-digits removed to match rinlinejQuery\n    expando: \"jQuery\" + ( core_version + Math.random() ).replace( /\\D/g, \"\" ),\n\n    noConflict: function( deep ) {\n        if ( window.$ === jQuery ) {\n            window.$ = _$;\n        }\n\n        if ( deep && window.jQuery === jQuery ) {\n            window.jQuery = _jQuery;\n        }\n\n        return jQuery;\n    },\n\n    // Is the DOM ready to be used? Set to true once it occurs.\n    isReady: false,\n\n    // A counter to track how many items to wait for before\n    // the ready event fires. See #6781\n    readyWait: 1,\n\n    // Hold (or release) the ready event\n    holdReady: function( hold ) {\n        if ( hold ) {\n            jQuery.readyWait++;\n        } else {\n            jQuery.ready( true );\n        }\n    },\n\n    // Handle when the DOM is ready\n    ready: function( wait ) {\n\n        // Abort if there are pending holds or we're already ready\n        if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {\n            return;\n        }\n\n        // Make sure body exists, at least, in case IE gets a little overzealous (ticket #5443).\n        if ( !document.body ) {\n            return setTimeout( jQuery.ready );\n        }\n\n        // Remember that the DOM is ready\n        jQuery.isReady = true;\n\n        // If a normal DOM Ready event fired, decrement, and wait if need be\n        if ( wait !== true && --jQuery.readyWait > 0 ) {\n            return;\n        }\n\n        // If there are functions bound, to execute\n        readyList.resolveWith( document, [ jQuery ] );\n\n        // Trigger any bound ready events\n        if ( jQuery.fn.trigger ) {\n            jQuery( document ).trigger(\"ready\").off(\"ready\");\n        }\n    },\n\n    // See test/unit/core.js for details concerning isFunction.\n    // Since version 1.3, DOM methods and functions like alert\n    // aren't supported. They return false on IE (#2968).\n    isFunction: function( obj ) {\n        return jQuery.type(obj) === \"function\";\n    },\n\n    isArray: Array.isArray || function( obj ) {\n        return jQuery.type(obj) === \"array\";\n    },\n\n    isWindow: function( obj ) {\n        /* jshint eqeqeq: false */\n        return obj != null && obj == obj.window;\n    },\n\n    isNumeric: function( obj ) {\n        return !isNaN( parseFloat(obj) ) && isFinite( obj );\n    },\n\n    type: function( obj ) {\n        if ( obj == null ) {\n            return String( obj );\n        }\n        return typeof obj === \"object\" || typeof obj === \"function\" ?\n            class2type[ core_toString.call(obj) ] || \"object\" :\n            typeof obj;\n    },\n\n    isPlainObject: function( obj ) {\n        var key;\n\n        // Must be an Object.\n        // Because of IE, we also have to check the presence of the constructor property.\n        // Make sure that DOM nodes and window objects don't pass through, as well\n        if ( !obj || jQuery.type(obj) !== \"object\" || obj.nodeType || jQuery.isWindow( obj ) ) {\n            return false;\n        }\n\n        try {\n            // Not own constructor property must be Object\n            if ( obj.constructor &&\n                !core_hasOwn.call(obj, \"constructor\") &&\n                !core_hasOwn.call(obj.constructor.prototype, \"isPrototypeOf\") ) {\n                return false;\n            }\n        } catch ( e ) {\n            // IE8,9 Will throw exceptions on certain host objects #9897\n            return false;\n        }\n\n        // Support: IE<9\n        // Handle iteration over inherited properties before own properties.\n        if ( jQuery.support.ownLast ) {\n            for ( key in obj ) {\n                return core_hasOwn.call( obj, key );\n            }\n        }\n\n        // Own properties are enumerated firstly, so to speed up,\n        // if last one is own, then all properties are own.\n        for ( key in obj ) {}\n\n        return key === undefined || core_hasOwn.call( obj, key );\n    },\n\n    isEmptyObject: function( obj ) {\n        var name;\n        for ( name in obj ) {\n            return false;\n        }\n        return true;\n    },\n\n    error: function( msg ) {\n        throw new Error( msg );\n    },\n\n    // data: string of html\n    // context (optional): If specified, the fragment will be created in this context, defaults to document\n    // keepScripts (optional): If true, will include scripts passed in the html string\n    parseHTML: function( data, context, keepScripts ) {\n        if ( !data || typeof data !== \"string\" ) {\n            return null;\n        }\n        if ( typeof context === \"boolean\" ) {\n            keepScripts = context;\n            context = false;\n        }\n        context = context || document;\n\n        var parsed = rsingleTag.exec( data ),\n            scripts = !keepScripts && [];\n\n        // Single tag\n        if ( parsed ) {\n            return [ context.createElement( parsed[1] ) ];\n        }\n\n        parsed = jQuery.buildFragment( [ data ], context, scripts );\n        if ( scripts ) {\n            jQuery( scripts ).remove();\n        }\n        return jQuery.merge( [], parsed.childNodes );\n    },\n\n    parseJSON: function( data ) {\n        // Attempt to parse using the native JSON parser first\n        if ( window.JSON && window.JSON.parse ) {\n            return window.JSON.parse( data );\n        }\n\n        if ( data === null ) {\n            return data;\n        }\n\n        if ( typeof data === \"string\" ) {\n\n            // Make sure leading/trailing whitespace is removed (IE can't handle it)\n            data = jQuery.trim( data );\n\n            if ( data ) {\n                // Make sure the incoming data is actual JSON\n                // Logic borrowed from http://json.org/json2.js\n                if ( rvalidchars.test( data.replace( rvalidescape, \"@\" )\n                    .replace( rvalidtokens, \"]\" )\n                    .replace( rvalidbraces, \"\")) ) {\n\n                    return ( new Function( \"return \" + data ) )();\n                }\n            }\n        }\n\n        jQuery.error( \"Invalid JSON: \" + data );\n    },\n\n    // Cross-browser xml parsing\n    parseXML: function( data ) {\n        var xml, tmp;\n        if ( !data || typeof data !== \"string\" ) {\n            return null;\n        }\n        try {\n            if ( window.DOMParser ) { // Standard\n                tmp = new DOMParser();\n                xml = tmp.parseFromString( data , \"text/xml\" );\n            } else { // IE\n                xml = new ActiveXObject( \"Microsoft.XMLDOM\" );\n                xml.async = \"false\";\n                xml.loadXML( data );\n            }\n        } catch( e ) {\n            xml = undefined;\n        }\n        if ( !xml || !xml.documentElement || xml.getElementsByTagName( \"parsererror\" ).length ) {\n            jQuery.error( \"Invalid XML: \" + data );\n        }\n        return xml;\n    },\n\n    noop: function() {},\n\n    // Evaluates a script in a global context\n    // Workarounds based on findings by Jim Driscoll\n    // http://weblogs.java.net/blog/driscoll/archive/2009/09/08/eval-javascript-global-context\n    globalEval: function( data ) {\n        if ( data && jQuery.trim( data ) ) {\n            // We use execScript on Internet Explorer\n            // We use an anonymous function so that context is window\n            // rather than jQuery in Firefox\n            ( window.execScript || function( data ) {\n                window[ \"eval\" ].call( window, data );\n            } )( data );\n        }\n    },\n\n    // Convert dashed to camelCase; used by the css and data modules\n    // Microsoft forgot to hump their vendor prefix (#9572)\n    camelCase: function( string ) {\n        return string.replace( rmsPrefix, \"ms-\" ).replace( rdashAlpha, fcamelCase );\n    },\n\n    nodeName: function( elem, name ) {\n        return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();\n    },\n\n    // args is for internal usage only\n    each: function( obj, callback, args ) {\n        var value,\n            i = 0,\n            length = obj.length,\n            isArray = isArraylike( obj );\n\n        if ( args ) {\n            if ( isArray ) {\n                for ( ; i < length; i++ ) {\n                    value = callback.apply( obj[ i ], args );\n\n                    if ( value === false ) {\n                        break;\n                    }\n                }\n            } else {\n                for ( i in obj ) {\n                    value = callback.apply( obj[ i ], args );\n\n                    if ( value === false ) {\n                        break;\n                    }\n                }\n            }\n\n        // A special, fast, case for the most common use of each\n        } else {\n            if ( isArray ) {\n                for ( ; i < length; i++ ) {\n                    value = callback.call( obj[ i ], i, obj[ i ] );\n\n                    if ( value === false ) {\n                        break;\n                    }\n                }\n            } else {\n                for ( i in obj ) {\n                    value = callback.call( obj[ i ], i, obj[ i ] );\n\n                    if ( value === false ) {\n                        break;\n                    }\n                }\n            }\n        }\n\n        return obj;\n    },\n\n    // Use native String.trim function wherever possible\n    trim: core_trim && !core_trim.call(\"\\uFEFF\\xA0\") ?\n        function( text ) {\n            return text == null ?\n                \"\" :\n                core_trim.call( text );\n        } :\n\n        // Otherwise use our own trimming functionality\n        function( text ) {\n            return text == null ?\n                \"\" :\n                ( text + \"\" ).replace( rtrim, \"\" );\n        },\n\n    // results is for internal usage only\n    makeArray: function( arr, results ) {\n        var ret = results || [];\n\n        if ( arr != null ) {\n            if ( isArraylike( Object(arr) ) ) {\n                jQuery.merge( ret,\n                    typeof arr === \"string\" ?\n                    [ arr ] : arr\n                );\n            } else {\n                core_push.call( ret, arr );\n            }\n        }\n\n        return ret;\n    },\n\n    inArray: function( elem, arr, i ) {\n        var len;\n\n        if ( arr ) {\n            if ( core_indexOf ) {\n                return core_indexOf.call( arr, elem, i );\n            }\n\n            len = arr.length;\n            i = i ? i < 0 ? Math.max( 0, len + i ) : i : 0;\n\n            for ( ; i < len; i++ ) {\n                // Skip accessing in sparse arrays\n                if ( i in arr && arr[ i ] === elem ) {\n                    return i;\n                }\n            }\n        }\n\n        return -1;\n    },\n\n    merge: function( first, second ) {\n        var l = second.length,\n            i = first.length,\n            j = 0;\n\n        if ( typeof l === \"number\" ) {\n            for ( ; j < l; j++ ) {\n                first[ i++ ] = second[ j ];\n            }\n        } else {\n            while ( second[j] !== undefined ) {\n                first[ i++ ] = second[ j++ ];\n            }\n        }\n\n        first.length = i;\n\n        return first;\n    },\n\n    grep: function( elems, callback, inv ) {\n        var retVal,\n            ret = [],\n            i = 0,\n            length = elems.length;\n        inv = !!inv;\n\n        // Go through the array, only saving the items\n        // that pass the validator function\n        for ( ; i < length; i++ ) {\n            retVal = !!callback( elems[ i ], i );\n            if ( inv !== retVal ) {\n                ret.push( elems[ i ] );\n            }\n        }\n\n        return ret;\n    },\n\n    // arg is for internal usage only\n    map: function( elems, callback, arg ) {\n        var value,\n            i = 0,\n            length = elems.length,\n            isArray = isArraylike( elems ),\n            ret = [];\n\n        // Go through the array, translating each of the items to their\n        if ( isArray ) {\n            for ( ; i < length; i++ ) {\n                value = callback( elems[ i ], i, arg );\n\n                if ( value != null ) {\n                    ret[ ret.length ] = value;\n                }\n            }\n\n        // Go through every key on the object,\n        } else {\n            for ( i in elems ) {\n                value = callback( elems[ i ], i, arg );\n\n                if ( value != null ) {\n                    ret[ ret.length ] = value;\n                }\n            }\n        }\n\n        // Flatten any nested arrays\n        return core_concat.apply( [], ret );\n    },\n\n    // A global GUID counter for objects\n    guid: 1,\n\n    // Bind a function to a context, optionally partially applying any\n    // arguments.\n    proxy: function( fn, context ) {\n        var args, proxy, tmp;\n\n        if ( typeof context === \"string\" ) {\n            tmp = fn[ context ];\n            context = fn;\n            fn = tmp;\n        }\n\n        // Quick check to determine if target is callable, in the spec\n        // this throws a TypeError, but we will just return undefined.\n        if ( !jQuery.isFunction( fn ) ) {\n            return undefined;\n        }\n\n        // Simulated bind\n        args = core_slice.call( arguments, 2 );\n        proxy = function() {\n            return fn.apply( context || this, args.concat( core_slice.call( arguments ) ) );\n        };\n\n        // Set the guid of unique handler to the same of original handler, so it can be removed\n        proxy.guid = fn.guid = fn.guid || jQuery.guid++;\n\n        return proxy;\n    },\n\n    // Multifunctional method to get and set values of a collection\n    // The value/s can optionally be executed if it's a function\n    access: function( elems, fn, key, value, chainable, emptyGet, raw ) {\n        var i = 0,\n            length = elems.length,\n            bulk = key == null;\n\n        // Sets many values\n        if ( jQuery.type( key ) === \"object\" ) {\n            chainable = true;\n            for ( i in key ) {\n                jQuery.access( elems, fn, i, key[i], true, emptyGet, raw );\n            }\n\n        // Sets one value\n        } else if ( value !== undefined ) {\n            chainable = true;\n\n            if ( !jQuery.isFunction( value ) ) {\n                raw = true;\n            }\n\n            if ( bulk ) {\n                // Bulk operations run against the entire set\n                if ( raw ) {\n                    fn.call( elems, value );\n                    fn = null;\n\n                // ...except when executing function values\n                } else {\n                    bulk = fn;\n                    fn = function( elem, key, value ) {\n                        return bulk.call( jQuery( elem ), value );\n                    };\n                }\n            }\n\n            if ( fn ) {\n                for ( ; i < length; i++ ) {\n                    fn( elems[i], key, raw ? value : value.call( elems[i], i, fn( elems[i], key ) ) );\n                }\n            }\n        }\n\n        return chainable ?\n            elems :\n\n            // Gets\n            bulk ?\n                fn.call( elems ) :\n                length ? fn( elems[0], key ) : emptyGet;\n    },\n\n    now: function() {\n        return ( new Date() ).getTime();\n    },\n\n    // A method for quickly swapping in/out CSS properties to get correct calculations.\n    // Note: this method belongs to the css module but it's needed here for the support module.\n    // If support gets modularized, this method should be moved back to the css module.\n    swap: function( elem, options, callback, args ) {\n        var ret, name,\n            old = {};\n\n        // Remember the old values, and insert the new ones\n        for ( name in options ) {\n            old[ name ] = elem.style[ name ];\n            elem.style[ name ] = options[ name ];\n        }\n\n        ret = callback.apply( elem, args || [] );\n\n        // Revert the old values\n        for ( name in options ) {\n            elem.style[ name ] = old[ name ];\n        }\n\n        return ret;\n    }\n});\n\njQuery.ready.promise = function( obj ) {\n    if ( !readyList ) {\n\n        readyList = jQuery.Deferred();\n\n        // Catch cases where $(document).ready() is called after the browser event has already occurred.\n        // we once tried to use readyState \"interactive\" here, but it caused issues like the one\n        // discovered by ChrisS here: http://bugs.jquery.com/ticket/12282#comment:15\n        if ( document.readyState === \"complete\" ) {\n            // Handle it asynchronously to allow scripts the opportunity to delay ready\n            setTimeout( jQuery.ready );\n\n        // Standards-based browsers support DOMContentLoaded\n        } else if ( document.addEventListener ) {\n            // Use the handy event callback\n            document.addEventListener( \"DOMContentLoaded\", completed, false );\n\n            // A fallback to window.onload, that will always work\n            window.addEventListener( \"load\", completed, false );\n\n        // If IE event model is used\n        } else {\n            // Ensure firing before onload, maybe late but safe also for iframes\n            document.attachEvent( \"onreadystatechange\", completed );\n\n            // A fallback to window.onload, that will always work\n            window.attachEvent( \"onload\", completed );\n\n            // If IE and not a frame\n            // continually check to see if the document is ready\n            var top = false;\n\n            try {\n                top = window.frameElement == null && document.documentElement;\n            } catch(e) {}\n\n            if ( top && top.doScroll ) {\n                (function doScrollCheck() {\n                    if ( !jQuery.isReady ) {\n\n                        try {\n                            // Use the trick by Diego Perini\n                            // http://javascript.nwbox.com/IEContentLoaded/\n                            top.doScroll(\"left\");\n                        } catch(e) {\n                            return setTimeout( doScrollCheck, 50 );\n                        }\n\n                        // detach all dom ready events\n                        detach();\n\n                        // and execute any waiting functions\n                        jQuery.ready();\n                    }\n                })();\n            }\n        }\n    }\n    return readyList.promise( obj );\n};\n\n// Populate the class2type map\njQuery.each(\"Boolean Number String Function Array Date RegExp Object Error\".split(\" \"), function(i, name) {\n    class2type[ \"[object \" + name + \"]\" ] = name.toLowerCase();\n});\n\nfunction isArraylike( obj ) {\n    var length = obj.length,\n        type = jQuery.type( obj );\n\n    if ( jQuery.isWindow( obj ) ) {\n        return false;\n    }\n\n    if ( obj.nodeType === 1 && length ) {\n        return true;\n    }\n\n    return type === \"array\" || type !== \"function\" &&\n        ( length === 0 ||\n        typeof length === \"number\" && length > 0 && ( length - 1 ) in obj );\n}\n\n// All jQuery objects should point back to these\nrootjQuery = jQuery(document);\n/*!\n * Sizzle CSS Selector Engine v1.10.2\n * http://sizzlejs.com/\n *\n * Copyright 2013 jQuery Foundation, Inc. and other contributors\n * Released under the MIT license\n * http://jquery.org/license\n *\n * Date: 2013-07-03\n */\n(function( window, undefined ) {\n\nvar i,\n    support,\n    cachedruns,\n    Expr,\n    getText,\n    isXML,\n    compile,\n    outermostContext,\n    sortInput,\n\n    // Local document vars\n    setDocument,\n    document,\n    docElem,\n    documentIsHTML,\n    rbuggyQSA,\n    rbuggyMatches,\n    matches,\n    contains,\n\n    // Instance-specific data\n    expando = \"sizzle\" + -(new Date()),\n    preferredDoc = window.document,\n    dirruns = 0,\n    done = 0,\n    classCache = createCache(),\n    tokenCache = createCache(),\n    compilerCache = createCache(),\n    hasDuplicate = false,\n    sortOrder = function( a, b ) {\n        if ( a === b ) {\n            hasDuplicate = true;\n            return 0;\n        }\n        return 0;\n    },\n\n    // General-purpose constants\n    strundefined = typeof undefined,\n    MAX_NEGATIVE = 1 << 31,\n\n    // Instance methods\n    hasOwn = ({}).hasOwnProperty,\n    arr = [],\n    pop = arr.pop,\n    push_native = arr.push,\n    push = arr.push,\n    slice = arr.slice,\n    // Use a stripped-down indexOf if we can't use a native one\n    indexOf = arr.indexOf || function( elem ) {\n        var i = 0,\n            len = this.length;\n        for ( ; i < len; i++ ) {\n            if ( this[i] === elem ) {\n                return i;\n            }\n        }\n        return -1;\n    },\n\n    booleans = \"checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped\",\n\n    // Regular expressions\n\n    // Whitespace characters http://www.w3.org/TR/css3-selectors/#whitespace\n    whitespace = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\",\n    // http://www.w3.org/TR/css3-syntax/#characters\n    characterEncoding = \"(?:\\\\\\\\.|[\\\\w-]|[^\\\\x00-\\\\xa0])+\",\n\n    // Loosely modeled on CSS identifier characters\n    // An unquoted value should be a CSS identifier http://www.w3.org/TR/css3-selectors/#attribute-selectors\n    // Proper syntax: http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier\n    identifier = characterEncoding.replace( \"w\", \"w#\" ),\n\n    // Acceptable operators http://www.w3.org/TR/selectors/#attribute-selectors\n    attributes = \"\\\\[\" + whitespace + \"*(\" + characterEncoding + \")\" + whitespace +\n        \"*(?:([*^$|!~]?=)\" + whitespace + \"*(?:(['\\\"])((?:\\\\\\\\.|[^\\\\\\\\])*?)\\\\3|(\" + identifier + \")|)|)\" + whitespace + \"*\\\\]\",\n\n    // Prefer arguments quoted,\n    //   then not containing pseudos/brackets,\n    //   then attribute selectors/non-parenthetical expressions,\n    //   then anything else\n    // These preferences are here to reduce the number of selectors\n    //   needing tokenize in the PSEUDO preFilter\n    pseudos = \":(\" + characterEncoding + \")(?:\\\\(((['\\\"])((?:\\\\\\\\.|[^\\\\\\\\])*?)\\\\3|((?:\\\\\\\\.|[^\\\\\\\\()[\\\\]]|\" + attributes.replace( 3, 8 ) + \")*)|.*)\\\\)|)\",\n\n    // Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter\n    rtrim = new RegExp( \"^\" + whitespace + \"+|((?:^|[^\\\\\\\\])(?:\\\\\\\\.)*)\" + whitespace + \"+$\", \"g\" ),\n\n    rcomma = new RegExp( \"^\" + whitespace + \"*,\" + whitespace + \"*\" ),\n    rcombinators = new RegExp( \"^\" + whitespace + \"*([>+~]|\" + whitespace + \")\" + whitespace + \"*\" ),\n\n    rsibling = new RegExp( whitespace + \"*[+~]\" ),\n    rattributeQuotes = new RegExp( \"=\" + whitespace + \"*([^\\\\]'\\\"]*)\" + whitespace + \"*\\\\]\", \"g\" ),\n\n    rpseudo = new RegExp( pseudos ),\n    ridentifier = new RegExp( \"^\" + identifier + \"$\" ),\n\n    matchExpr = {\n        \"ID\": new RegExp( \"^#(\" + characterEncoding + \")\" ),\n        \"CLASS\": new RegExp( \"^\\\\.(\" + characterEncoding + \")\" ),\n        \"TAG\": new RegExp( \"^(\" + characterEncoding.replace( \"w\", \"w*\" ) + \")\" ),\n        \"ATTR\": new RegExp( \"^\" + attributes ),\n        \"PSEUDO\": new RegExp( \"^\" + pseudos ),\n        \"CHILD\": new RegExp( \"^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\\\(\" + whitespace +\n            \"*(even|odd|(([+-]|)(\\\\d*)n|)\" + whitespace + \"*(?:([+-]|)\" + whitespace +\n            \"*(\\\\d+)|))\" + whitespace + \"*\\\\)|)\", \"i\" ),\n        \"bool\": new RegExp( \"^(?:\" + booleans + \")$\", \"i\" ),\n        // For use in libraries implementing .is()\n        // We use this for POS matching in `select`\n        \"needsContext\": new RegExp( \"^\" + whitespace + \"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\\\(\" +\n            whitespace + \"*((?:-\\\\d)?\\\\d*)\" + whitespace + \"*\\\\)|)(?=[^-]|$)\", \"i\" )\n    },\n\n    rnative = /^[^{]+\\{\\s*\\[native \\w/,\n\n    // Easily-parseable/retrievable ID or TAG or CLASS selectors\n    rquickExpr = /^(?:#([\\w-]+)|(\\w+)|\\.([\\w-]+))$/,\n\n    rinputs = /^(?:input|select|textarea|button)$/i,\n    rheader = /^h\\d$/i,\n\n    rescape = /'|\\\\/g,\n\n    // CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters\n    runescape = new RegExp( \"\\\\\\\\([\\\\da-f]{1,6}\" + whitespace + \"?|(\" + whitespace + \")|.)\", \"ig\" ),\n    funescape = function( _, escaped, escapedWhitespace ) {\n        var high = \"0x\" + escaped - 0x10000;\n        // NaN means non-codepoint\n        // Support: Firefox\n        // Workaround erroneous numeric interpretation of +\"0x\"\n        return high !== high || escapedWhitespace ?\n            escaped :\n            // BMP codepoint\n            high < 0 ?\n                String.fromCharCode( high + 0x10000 ) :\n                // Supplemental Plane codepoint (surrogate pair)\n                String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );\n    };\n\n// Optimize for push.apply( _, NodeList )\ntry {\n    push.apply(\n        (arr = slice.call( preferredDoc.childNodes )),\n        preferredDoc.childNodes\n    );\n    // Support: Android<4.0\n    // Detect silently failing push.apply\n    arr[ preferredDoc.childNodes.length ].nodeType;\n} catch ( e ) {\n    push = { apply: arr.length ?\n\n        // Leverage slice if possible\n        function( target, els ) {\n            push_native.apply( target, slice.call(els) );\n        } :\n\n        // Support: IE<9\n        // Otherwise append directly\n        function( target, els ) {\n            var j = target.length,\n                i = 0;\n            // Can't trust NodeList.length\n            while ( (target[j++] = els[i++]) ) {}\n            target.length = j - 1;\n        }\n    };\n}\n\nfunction Sizzle( selector, context, results, seed ) {\n    var match, elem, m, nodeType,\n        // QSA vars\n        i, groups, old, nid, newContext, newSelector;\n\n    if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {\n        setDocument( context );\n    }\n\n    context = context || document;\n    results = results || [];\n\n    if ( !selector || typeof selector !== \"string\" ) {\n        return results;\n    }\n\n    if ( (nodeType = context.nodeType) !== 1 && nodeType !== 9 ) {\n        return [];\n    }\n\n    if ( documentIsHTML && !seed ) {\n\n        // Shortcuts\n        if ( (match = rquickExpr.exec( selector )) ) {\n            // Speed-up: Sizzle(\"#ID\")\n            if ( (m = match[1]) ) {\n                if ( nodeType === 9 ) {\n                    elem = context.getElementById( m );\n                    // Check parentNode to catch when Blackberry 4.6 returns\n                    // nodes that are no longer in the document #6963\n                    if ( elem && elem.parentNode ) {\n                        // Handle the case where IE, Opera, and Webkit return items\n                        // by name instead of ID\n                        if ( elem.id === m ) {\n                            results.push( elem );\n                            return results;\n                        }\n                    } else {\n                        return results;\n                    }\n                } else {\n                    // Context is not a document\n                    if ( context.ownerDocument && (elem = context.ownerDocument.getElementById( m )) &&\n                        contains( context, elem ) && elem.id === m ) {\n                        results.push( elem );\n                        return results;\n                    }\n                }\n\n            // Speed-up: Sizzle(\"TAG\")\n            } else if ( match[2] ) {\n                push.apply( results, context.getElementsByTagName( selector ) );\n                return results;\n\n            // Speed-up: Sizzle(\".CLASS\")\n            } else if ( (m = match[3]) && support.getElementsByClassName && context.getElementsByClassName ) {\n                push.apply( results, context.getElementsByClassName( m ) );\n                return results;\n            }\n        }\n\n        // QSA path\n        if ( support.qsa && (!rbuggyQSA || !rbuggyQSA.test( selector )) ) {\n            nid = old = expando;\n            newContext = context;\n            newSelector = nodeType === 9 && selector;\n\n            // qSA works strangely on Element-rooted queries\n            // We can work around this by specifying an extra ID on the root\n            // and working up from there (Thanks to Andrew Dupont for the technique)\n            // IE 8 doesn't work on object elements\n            if ( nodeType === 1 && context.nodeName.toLowerCase() !== \"object\" ) {\n                groups = tokenize( selector );\n\n                if ( (old = context.getAttribute(\"id\")) ) {\n                    nid = old.replace( rescape, \"\\\\$&\" );\n                } else {\n                    context.setAttribute( \"id\", nid );\n                }\n                nid = \"[id='\" + nid + \"'] \";\n\n                i = groups.length;\n                while ( i-- ) {\n                    groups[i] = nid + toSelector( groups[i] );\n                }\n                newContext = rsibling.test( selector ) && context.parentNode || context;\n                newSelector = groups.join(\",\");\n            }\n\n            if ( newSelector ) {\n                try {\n                    push.apply( results,\n                        newContext.querySelectorAll( newSelector )\n                    );\n                    return results;\n                } catch(qsaError) {\n                } finally {\n                    if ( !old ) {\n                        context.removeAttribute(\"id\");\n                    }\n                }\n            }\n        }\n    }\n\n    // All others\n    return select( selector.replace( rtrim, \"$1\" ), context, results, seed );\n}\n\n/**\n * Create key-value caches of limited size\n * @returns {Function(string, Object)} Returns the Object data after storing it on itself with\n *  property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)\n *  deleting the oldest entry\n */\nfunction createCache() {\n    var keys = [];\n\n    function cache( key, value ) {\n        // Use (key + \" \") to avoid collision with native prototype properties (see Issue #157)\n        if ( keys.push( key += \" \" ) > Expr.cacheLength ) {\n            // Only keep the most recent entries\n            delete cache[ keys.shift() ];\n        }\n        return (cache[ key ] = value);\n    }\n    return cache;\n}\n\n/**\n * Mark a function for special use by Sizzle\n * @param {Function} fn The function to mark\n */\nfunction markFunction( fn ) {\n    fn[ expando ] = true;\n    return fn;\n}\n\n/**\n * Support testing using an element\n * @param {Function} fn Passed the created div and expects a boolean result\n */\nfunction assert( fn ) {\n    var div = document.createElement(\"div\");\n\n    try {\n        return !!fn( div );\n    } catch (e) {\n        return false;\n    } finally {\n        // Remove from its parent by default\n        if ( div.parentNode ) {\n            div.parentNode.removeChild( div );\n        }\n        // release memory in IE\n        div = null;\n    }\n}\n\n/**\n * Adds the same handler for all of the specified attrs\n * @param {String} attrs Pipe-separated list of attributes\n * @param {Function} handler The method that will be applied\n */\nfunction addHandle( attrs, handler ) {\n    var arr = attrs.split(\"|\"),\n        i = attrs.length;\n\n    while ( i-- ) {\n        Expr.attrHandle[ arr[i] ] = handler;\n    }\n}\n\n/**\n * Checks document order of two siblings\n * @param {Element} a\n * @param {Element} b\n * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b\n */\nfunction siblingCheck( a, b ) {\n    var cur = b && a,\n        diff = cur && a.nodeType === 1 && b.nodeType === 1 &&\n            ( ~b.sourceIndex || MAX_NEGATIVE ) -\n            ( ~a.sourceIndex || MAX_NEGATIVE );\n\n    // Use IE sourceIndex if available on both nodes\n    if ( diff ) {\n        return diff;\n    }\n\n    // Check if b follows a\n    if ( cur ) {\n        while ( (cur = cur.nextSibling) ) {\n            if ( cur === b ) {\n                return -1;\n            }\n        }\n    }\n\n    return a ? 1 : -1;\n}\n\n/**\n * Returns a function to use in pseudos for input types\n * @param {String} type\n */\nfunction createInputPseudo( type ) {\n    return function( elem ) {\n        var name = elem.nodeName.toLowerCase();\n        return name === \"input\" && elem.type === type;\n    };\n}\n\n/**\n * Returns a function to use in pseudos for buttons\n * @param {String} type\n */\nfunction createButtonPseudo( type ) {\n    return function( elem ) {\n        var name = elem.nodeName.toLowerCase();\n        return (name === \"input\" || name === \"button\") && elem.type === type;\n    };\n}\n\n/**\n * Returns a function to use in pseudos for positionals\n * @param {Function} fn\n */\nfunction createPositionalPseudo( fn ) {\n    return markFunction(function( argument ) {\n        argument = +argument;\n        return markFunction(function( seed, matches ) {\n            var j,\n                matchIndexes = fn( [], seed.length, argument ),\n                i = matchIndexes.length;\n\n            // Match elements found at the specified indexes\n            while ( i-- ) {\n                if ( seed[ (j = matchIndexes[i]) ] ) {\n                    seed[j] = !(matches[j] = seed[j]);\n                }\n            }\n        });\n    });\n}\n\n/**\n * Detect xml\n * @param {Element|Object} elem An element or a document\n */\nisXML = Sizzle.isXML = function( elem ) {\n    // documentElement is verified for cases where it doesn't yet exist\n    // (such as loading iframes in IE - #4833)\n    var documentElement = elem && (elem.ownerDocument || elem).documentElement;\n    return documentElement ? documentElement.nodeName !== \"HTML\" : false;\n};\n\n// Expose support vars for convenience\nsupport = Sizzle.support = {};\n\n/**\n * Sets document-related variables once based on the current document\n * @param {Element|Object} [doc] An element or document object to use to set the document\n * @returns {Object} Returns the current document\n */\nsetDocument = Sizzle.setDocument = function( node ) {\n    var doc = node ? node.ownerDocument || node : preferredDoc,\n        parent = doc.defaultView;\n\n    // If no document and documentElement is available, return\n    if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {\n        return document;\n    }\n\n    // Set our document\n    document = doc;\n    docElem = doc.documentElement;\n\n    // Support tests\n    documentIsHTML = !isXML( doc );\n\n    // Support: IE>8\n    // If iframe document is assigned to \"document\" variable and if iframe has been reloaded,\n    // IE will throw \"permission denied\" error when accessing \"document\" variable, see jQuery #13936\n    // IE6-8 do not support the defaultView property so parent will be undefined\n    if ( parent && parent.attachEvent && parent !== parent.top ) {\n        parent.attachEvent( \"onbeforeunload\", function() {\n            setDocument();\n        });\n    }\n\n    /* Attributes\n    ---------------------------------------------------------------------- */\n\n    // Support: IE<8\n    // Verify that getAttribute really returns attributes and not properties (excepting IE8 booleans)\n    support.attributes = assert(function( div ) {\n        div.className = \"i\";\n        return !div.getAttribute(\"className\");\n    });\n\n    /* getElement(s)By*\n    ---------------------------------------------------------------------- */\n\n    // Check if getElementsByTagName(\"*\") returns only elements\n    support.getElementsByTagName = assert(function( div ) {\n        div.appendChild( doc.createComment(\"\") );\n        return !div.getElementsByTagName(\"*\").length;\n    });\n\n    // Check if getElementsByClassName can be trusted\n    support.getElementsByClassName = assert(function( div ) {\n        div.innerHTML = \"<div class='a'></div><div class='a i'></div>\";\n\n        // Support: Safari<4\n        // Catch class over-caching\n        div.firstChild.className = \"i\";\n        // Support: Opera<10\n        // Catch gEBCN failure to find non-leading classes\n        return div.getElementsByClassName(\"i\").length === 2;\n    });\n\n    // Support: IE<10\n    // Check if getElementById returns elements by name\n    // The broken getElementById methods don't pick up programatically-set names,\n    // so use a roundabout getElementsByName test\n    support.getById = assert(function( div ) {\n        docElem.appendChild( div ).id = expando;\n        return !doc.getElementsByName || !doc.getElementsByName( expando ).length;\n    });\n\n    // ID find and filter\n    if ( support.getById ) {\n        Expr.find[\"ID\"] = function( id, context ) {\n            if ( typeof context.getElementById !== strundefined && documentIsHTML ) {\n                var m = context.getElementById( id );\n                // Check parentNode to catch when Blackberry 4.6 returns\n                // nodes that are no longer in the document #6963\n                return m && m.parentNode ? [m] : [];\n            }\n        };\n        Expr.filter[\"ID\"] = function( id ) {\n            var attrId = id.replace( runescape, funescape );\n            return function( elem ) {\n                return elem.getAttribute(\"id\") === attrId;\n            };\n        };\n    } else {\n        // Support: IE6/7\n        // getElementById is not reliable as a find shortcut\n        delete Expr.find[\"ID\"];\n\n        Expr.filter[\"ID\"] =  function( id ) {\n            var attrId = id.replace( runescape, funescape );\n            return function( elem ) {\n                var node = typeof elem.getAttributeNode !== strundefined && elem.getAttributeNode(\"id\");\n                return node && node.value === attrId;\n            };\n        };\n    }\n\n    // Tag\n    Expr.find[\"TAG\"] = support.getElementsByTagName ?\n        function( tag, context ) {\n            if ( typeof context.getElementsByTagName !== strundefined ) {\n                return context.getElementsByTagName( tag );\n            }\n        } :\n        function( tag, context ) {\n            var elem,\n                tmp = [],\n                i = 0,\n                results = context.getElementsByTagName( tag );\n\n            // Filter out possible comments\n            if ( tag === \"*\" ) {\n                while ( (elem = results[i++]) ) {\n                    if ( elem.nodeType === 1 ) {\n                        tmp.push( elem );\n                    }\n                }\n\n                return tmp;\n            }\n            return results;\n        };\n\n    // Class\n    Expr.find[\"CLASS\"] = support.getElementsByClassName && function( className, context ) {\n        if ( typeof context.getElementsByClassName !== strundefined && documentIsHTML ) {\n            return context.getElementsByClassName( className );\n        }\n    };\n\n    /* QSA/matchesSelector\n    ---------------------------------------------------------------------- */\n\n    // QSA and matchesSelector support\n\n    // matchesSelector(:active) reports false when true (IE9/Opera 11.5)\n    rbuggyMatches = [];\n\n    // qSa(:focus) reports false when true (Chrome 21)\n    // We allow this because of a bug in IE8/9 that throws an error\n    // whenever `document.activeElement` is accessed on an iframe\n    // So, we allow :focus to pass through QSA all the time to avoid the IE error\n    // See http://bugs.jquery.com/ticket/13378\n    rbuggyQSA = [];\n\n    if ( (support.qsa = rnative.test( doc.querySelectorAll )) ) {\n        // Build QSA regex\n        // Regex strategy adopted from Diego Perini\n        assert(function( div ) {\n            // Select is set to empty string on purpose\n            // This is to test IE's treatment of not explicitly\n            // setting a boolean content attribute,\n            // since its presence should be enough\n            // http://bugs.jquery.com/ticket/12359\n            div.innerHTML = \"<select><option selected=''></option></select>\";\n\n            // Support: IE8\n            // Boolean attributes and \"value\" are not treated correctly\n            if ( !div.querySelectorAll(\"[selected]\").length ) {\n                rbuggyQSA.push( \"\\\\[\" + whitespace + \"*(?:value|\" + booleans + \")\" );\n            }\n\n            // Webkit/Opera - :checked should return selected option elements\n            // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n            // IE8 throws error here and will not see later tests\n            if ( !div.querySelectorAll(\":checked\").length ) {\n                rbuggyQSA.push(\":checked\");\n            }\n        });\n\n        assert(function( div ) {\n\n            // Support: Opera 10-12/IE8\n            // ^= $= *= and empty values\n            // Should not select anything\n            // Support: Windows 8 Native Apps\n            // The type attribute is restricted during .innerHTML assignment\n            var input = doc.createElement(\"input\");\n            input.setAttribute( \"type\", \"hidden\" );\n            div.appendChild( input ).setAttribute( \"t\", \"\" );\n\n            if ( div.querySelectorAll(\"[t^='']\").length ) {\n                rbuggyQSA.push( \"[*^$]=\" + whitespace + \"*(?:''|\\\"\\\")\" );\n            }\n\n            // FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)\n            // IE8 throws error here and will not see later tests\n            if ( !div.querySelectorAll(\":enabled\").length ) {\n                rbuggyQSA.push( \":enabled\", \":disabled\" );\n            }\n\n            // Opera 10-11 does not throw on post-comma invalid pseudos\n            div.querySelectorAll(\"*,:x\");\n            rbuggyQSA.push(\",.*:\");\n        });\n    }\n\n    if ( (support.matchesSelector = rnative.test( (matches = docElem.webkitMatchesSelector ||\n        docElem.mozMatchesSelector ||\n        docElem.oMatchesSelector ||\n        docElem.msMatchesSelector) )) ) {\n\n        assert(function( div ) {\n            // Check to see if it's possible to do matchesSelector\n            // on a disconnected node (IE 9)\n            support.disconnectedMatch = matches.call( div, \"div\" );\n\n            // This should fail with an exception\n            // Gecko does not error, returns false instead\n            matches.call( div, \"[s!='']:x\" );\n            rbuggyMatches.push( \"!=\", pseudos );\n        });\n    }\n\n    rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join(\"|\") );\n    rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join(\"|\") );\n\n    /* Contains\n    ---------------------------------------------------------------------- */\n\n    // Element contains another\n    // Purposefully does not implement inclusive descendent\n    // As in, an element does not contain itself\n    contains = rnative.test( docElem.contains ) || docElem.compareDocumentPosition ?\n        function( a, b ) {\n            var adown = a.nodeType === 9 ? a.documentElement : a,\n                bup = b && b.parentNode;\n            return a === bup || !!( bup && bup.nodeType === 1 && (\n                adown.contains ?\n                    adown.contains( bup ) :\n                    a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16\n            ));\n        } :\n        function( a, b ) {\n            if ( b ) {\n                while ( (b = b.parentNode) ) {\n                    if ( b === a ) {\n                        return true;\n                    }\n                }\n            }\n            return false;\n        };\n\n    /* Sorting\n    ---------------------------------------------------------------------- */\n\n    // Document order sorting\n    sortOrder = docElem.compareDocumentPosition ?\n    function( a, b ) {\n\n        // Flag for duplicate removal\n        if ( a === b ) {\n            hasDuplicate = true;\n            return 0;\n        }\n\n        var compare = b.compareDocumentPosition && a.compareDocumentPosition && a.compareDocumentPosition( b );\n\n        if ( compare ) {\n            // Disconnected nodes\n            if ( compare & 1 ||\n                (!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {\n\n                // Choose the first element that is related to our preferred document\n                if ( a === doc || contains(preferredDoc, a) ) {\n                    return -1;\n                }\n                if ( b === doc || contains(preferredDoc, b) ) {\n                    return 1;\n                }\n\n                // Maintain original order\n                return sortInput ?\n                    ( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :\n                    0;\n            }\n\n            return compare & 4 ? -1 : 1;\n        }\n\n        // Not directly comparable, sort on existence of method\n        return a.compareDocumentPosition ? -1 : 1;\n    } :\n    function( a, b ) {\n        var cur,\n            i = 0,\n            aup = a.parentNode,\n            bup = b.parentNode,\n            ap = [ a ],\n            bp = [ b ];\n\n        // Exit early if the nodes are identical\n        if ( a === b ) {\n            hasDuplicate = true;\n            return 0;\n\n        // Parentless nodes are either documents or disconnected\n        } else if ( !aup || !bup ) {\n            return a === doc ? -1 :\n                b === doc ? 1 :\n                aup ? -1 :\n                bup ? 1 :\n                sortInput ?\n                ( indexOf.call( sortInput, a ) - indexOf.call( sortInput, b ) ) :\n                0;\n\n        // If the nodes are siblings, we can do a quick check\n        } else if ( aup === bup ) {\n            return siblingCheck( a, b );\n        }\n\n        // Otherwise we need full lists of their ancestors for comparison\n        cur = a;\n        while ( (cur = cur.parentNode) ) {\n            ap.unshift( cur );\n        }\n        cur = b;\n        while ( (cur = cur.parentNode) ) {\n            bp.unshift( cur );\n        }\n\n        // Walk down the tree looking for a discrepancy\n        while ( ap[i] === bp[i] ) {\n            i++;\n        }\n\n        return i ?\n            // Do a sibling check if the nodes have a common ancestor\n            siblingCheck( ap[i], bp[i] ) :\n\n            // Otherwise nodes in our document sort first\n            ap[i] === preferredDoc ? -1 :\n            bp[i] === preferredDoc ? 1 :\n            0;\n    };\n\n    return doc;\n};\n\nSizzle.matches = function( expr, elements ) {\n    return Sizzle( expr, null, null, elements );\n};\n\nSizzle.matchesSelector = function( elem, expr ) {\n    // Set document vars if needed\n    if ( ( elem.ownerDocument || elem ) !== document ) {\n        setDocument( elem );\n    }\n\n    // Make sure that attribute selectors are quoted\n    expr = expr.replace( rattributeQuotes, \"='$1']\" );\n\n    if ( support.matchesSelector && documentIsHTML &&\n        ( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&\n        ( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {\n\n        try {\n            var ret = matches.call( elem, expr );\n\n            // IE 9's matchesSelector returns false on disconnected nodes\n            if ( ret || support.disconnectedMatch ||\n                    // As well, disconnected nodes are said to be in a document\n                    // fragment in IE 9\n                    elem.document && elem.document.nodeType !== 11 ) {\n                return ret;\n            }\n        } catch(e) {}\n    }\n\n    return Sizzle( expr, document, null, [elem] ).length > 0;\n};\n\nSizzle.contains = function( context, elem ) {\n    // Set document vars if needed\n    if ( ( context.ownerDocument || context ) !== document ) {\n        setDocument( context );\n    }\n    return contains( context, elem );\n};\n\nSizzle.attr = function( elem, name ) {\n    // Set document vars if needed\n    if ( ( elem.ownerDocument || elem ) !== document ) {\n        setDocument( elem );\n    }\n\n    var fn = Expr.attrHandle[ name.toLowerCase() ],\n        // Don't get fooled by Object.prototype properties (jQuery #13807)\n        val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?\n            fn( elem, name, !documentIsHTML ) :\n            undefined;\n\n    return val === undefined ?\n        support.attributes || !documentIsHTML ?\n            elem.getAttribute( name ) :\n            (val = elem.getAttributeNode(name)) && val.specified ?\n                val.value :\n                null :\n        val;\n};\n\nSizzle.error = function( msg ) {\n    throw new Error( \"Syntax error, unrecognized expression: \" + msg );\n};\n\n/**\n * Document sorting and removing duplicates\n * @param {ArrayLike} results\n */\nSizzle.uniqueSort = function( results ) {\n    var elem,\n        duplicates = [],\n        j = 0,\n        i = 0;\n\n    // Unless we *know* we can detect duplicates, assume their presence\n    hasDuplicate = !support.detectDuplicates;\n    sortInput = !support.sortStable && results.slice( 0 );\n    results.sort( sortOrder );\n\n    if ( hasDuplicate ) {\n        while ( (elem = results[i++]) ) {\n            if ( elem === results[ i ] ) {\n                j = duplicates.push( i );\n            }\n        }\n        while ( j-- ) {\n            results.splice( duplicates[ j ], 1 );\n        }\n    }\n\n    return results;\n};\n\n/**\n * Utility function for retrieving the text value of an array of DOM nodes\n * @param {Array|Element} elem\n */\ngetText = Sizzle.getText = function( elem ) {\n    var node,\n        ret = \"\",\n        i = 0,\n        nodeType = elem.nodeType;\n\n    if ( !nodeType ) {\n        // If no nodeType, this is expected to be an array\n        for ( ; (node = elem[i]); i++ ) {\n            // Do not traverse comment nodes\n            ret += getText( node );\n        }\n    } else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {\n        // Use textContent for elements\n        // innerText usage removed for consistency of new lines (see #11153)\n        if ( typeof elem.textContent === \"string\" ) {\n            return elem.textContent;\n        } else {\n            // Traverse its children\n            for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n                ret += getText( elem );\n            }\n        }\n    } else if ( nodeType === 3 || nodeType === 4 ) {\n        return elem.nodeValue;\n    }\n    // Do not include comment or processing instruction nodes\n\n    return ret;\n};\n\nExpr = Sizzle.selectors = {\n\n    // Can be adjusted by the user\n    cacheLength: 50,\n\n    createPseudo: markFunction,\n\n    match: matchExpr,\n\n    attrHandle: {},\n\n    find: {},\n\n    relative: {\n        \">\": { dir: \"parentNode\", first: true },\n        \" \": { dir: \"parentNode\" },\n        \"+\": { dir: \"previousSibling\", first: true },\n        \"~\": { dir: \"previousSibling\" }\n    },\n\n    preFilter: {\n        \"ATTR\": function( match ) {\n            match[1] = match[1].replace( runescape, funescape );\n\n            // Move the given value to match[3] whether quoted or unquoted\n            match[3] = ( match[4] || match[5] || \"\" ).replace( runescape, funescape );\n\n            if ( match[2] === \"~=\" ) {\n                match[3] = \" \" + match[3] + \" \";\n            }\n\n            return match.slice( 0, 4 );\n        },\n\n        \"CHILD\": function( match ) {\n            /* matches from matchExpr[\"CHILD\"]\n                1 type (only|nth|...)\n                2 what (child|of-type)\n                3 argument (even|odd|\\d*|\\d*n([+-]\\d+)?|...)\n                4 xn-component of xn+y argument ([+-]?\\d*n|)\n                5 sign of xn-component\n                6 x of xn-component\n                7 sign of y-component\n                8 y of y-component\n            */\n            match[1] = match[1].toLowerCase();\n\n            if ( match[1].slice( 0, 3 ) === \"nth\" ) {\n                // nth-* requires argument\n                if ( !match[3] ) {\n                    Sizzle.error( match[0] );\n                }\n\n                // numeric x and y parameters for Expr.filter.CHILD\n                // remember that false/true cast respectively to 0/1\n                match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === \"even\" || match[3] === \"odd\" ) );\n                match[5] = +( ( match[7] + match[8] ) || match[3] === \"odd\" );\n\n            // other types prohibit arguments\n            } else if ( match[3] ) {\n                Sizzle.error( match[0] );\n            }\n\n            return match;\n        },\n\n        \"PSEUDO\": function( match ) {\n            var excess,\n                unquoted = !match[5] && match[2];\n\n            if ( matchExpr[\"CHILD\"].test( match[0] ) ) {\n                return null;\n            }\n\n            // Accept quoted arguments as-is\n            if ( match[3] && match[4] !== undefined ) {\n                match[2] = match[4];\n\n            // Strip excess characters from unquoted arguments\n            } else if ( unquoted && rpseudo.test( unquoted ) &&\n                // Get excess from tokenize (recursively)\n                (excess = tokenize( unquoted, true )) &&\n                // advance to the next closing parenthesis\n                (excess = unquoted.indexOf( \")\", unquoted.length - excess ) - unquoted.length) ) {\n\n                // excess is a negative index\n                match[0] = match[0].slice( 0, excess );\n                match[2] = unquoted.slice( 0, excess );\n            }\n\n            // Return only captures needed by the pseudo filter method (type and argument)\n            return match.slice( 0, 3 );\n        }\n    },\n\n    filter: {\n\n        \"TAG\": function( nodeNameSelector ) {\n            var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();\n            return nodeNameSelector === \"*\" ?\n                function() { return true; } :\n                function( elem ) {\n                    return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;\n                };\n        },\n\n        \"CLASS\": function( className ) {\n            var pattern = classCache[ className + \" \" ];\n\n            return pattern ||\n                (pattern = new RegExp( \"(^|\" + whitespace + \")\" + className + \"(\" + whitespace + \"|$)\" )) &&\n                classCache( className, function( elem ) {\n                    return pattern.test( typeof elem.className === \"string\" && elem.className || typeof elem.getAttribute !== strundefined && elem.getAttribute(\"class\") || \"\" );\n                });\n        },\n\n        \"ATTR\": function( name, operator, check ) {\n            return function( elem ) {\n                var result = Sizzle.attr( elem, name );\n\n                if ( result == null ) {\n                    return operator === \"!=\";\n                }\n                if ( !operator ) {\n                    return true;\n                }\n\n                result += \"\";\n\n                return operator === \"=\" ? result === check :\n                    operator === \"!=\" ? result !== check :\n                    operator === \"^=\" ? check && result.indexOf( check ) === 0 :\n                    operator === \"*=\" ? check && result.indexOf( check ) > -1 :\n                    operator === \"$=\" ? check && result.slice( -check.length ) === check :\n                    operator === \"~=\" ? ( \" \" + result + \" \" ).indexOf( check ) > -1 :\n                    operator === \"|=\" ? result === check || result.slice( 0, check.length + 1 ) === check + \"-\" :\n                    false;\n            };\n        },\n\n        \"CHILD\": function( type, what, argument, first, last ) {\n            var simple = type.slice( 0, 3 ) !== \"nth\",\n                forward = type.slice( -4 ) !== \"last\",\n                ofType = what === \"of-type\";\n\n            return first === 1 && last === 0 ?\n\n                // Shortcut for :nth-*(n)\n                function( elem ) {\n                    return !!elem.parentNode;\n                } :\n\n                function( elem, context, xml ) {\n                    var cache, outerCache, node, diff, nodeIndex, start,\n                        dir = simple !== forward ? \"nextSibling\" : \"previousSibling\",\n                        parent = elem.parentNode,\n                        name = ofType && elem.nodeName.toLowerCase(),\n                        useCache = !xml && !ofType;\n\n                    if ( parent ) {\n\n                        // :(first|last|only)-(child|of-type)\n                        if ( simple ) {\n                            while ( dir ) {\n                                node = elem;\n                                while ( (node = node[ dir ]) ) {\n                                    if ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) {\n                                        return false;\n                                    }\n                                }\n                                // Reverse direction for :only-* (if we haven't yet done so)\n                                start = dir = type === \"only\" && !start && \"nextSibling\";\n                            }\n                            return true;\n                        }\n\n                        start = [ forward ? parent.firstChild : parent.lastChild ];\n\n                        // non-xml :nth-child(...) stores cache data on `parent`\n                        if ( forward && useCache ) {\n                            // Seek `elem` from a previously-cached index\n                            outerCache = parent[ expando ] || (parent[ expando ] = {});\n                            cache = outerCache[ type ] || [];\n                            nodeIndex = cache[0] === dirruns && cache[1];\n                            diff = cache[0] === dirruns && cache[2];\n                            node = nodeIndex && parent.childNodes[ nodeIndex ];\n\n                            while ( (node = ++nodeIndex && node && node[ dir ] ||\n\n                                // Fallback to seeking `elem` from the start\n                                (diff = nodeIndex = 0) || start.pop()) ) {\n\n                                // When found, cache indexes on `parent` and break\n                                if ( node.nodeType === 1 && ++diff && node === elem ) {\n                                    outerCache[ type ] = [ dirruns, nodeIndex, diff ];\n                                    break;\n                                }\n                            }\n\n                        // Use previously-cached element index if available\n                        } else if ( useCache && (cache = (elem[ expando ] || (elem[ expando ] = {}))[ type ]) && cache[0] === dirruns ) {\n                            diff = cache[1];\n\n                        // xml :nth-child(...) or :nth-last-child(...) or :nth(-last)?-of-type(...)\n                        } else {\n                            // Use the same loop as above to seek `elem` from the start\n                            while ( (node = ++nodeIndex && node && node[ dir ] ||\n                                (diff = nodeIndex = 0) || start.pop()) ) {\n\n                                if ( ( ofType ? node.nodeName.toLowerCase() === name : node.nodeType === 1 ) && ++diff ) {\n                                    // Cache the index of each encountered element\n                                    if ( useCache ) {\n                                        (node[ expando ] || (node[ expando ] = {}))[ type ] = [ dirruns, diff ];\n                                    }\n\n                                    if ( node === elem ) {\n                                        break;\n                                    }\n                                }\n                            }\n                        }\n\n                        // Incorporate the offset, then check against cycle size\n                        diff -= last;\n                        return diff === first || ( diff % first === 0 && diff / first >= 0 );\n                    }\n                };\n        },\n\n        \"PSEUDO\": function( pseudo, argument ) {\n            // pseudo-class names are case-insensitive\n            // http://www.w3.org/TR/selectors/#pseudo-classes\n            // Prioritize by case sensitivity in case custom pseudos are added with uppercase letters\n            // Remember that setFilters inherits from pseudos\n            var args,\n                fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||\n                    Sizzle.error( \"unsupported pseudo: \" + pseudo );\n\n            // The user may use createPseudo to indicate that\n            // arguments are needed to create the filter function\n            // just as Sizzle does\n            if ( fn[ expando ] ) {\n                return fn( argument );\n            }\n\n            // But maintain support for old signatures\n            if ( fn.length > 1 ) {\n                args = [ pseudo, pseudo, \"\", argument ];\n                return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?\n                    markFunction(function( seed, matches ) {\n                        var idx,\n                            matched = fn( seed, argument ),\n                            i = matched.length;\n                        while ( i-- ) {\n                            idx = indexOf.call( seed, matched[i] );\n                            seed[ idx ] = !( matches[ idx ] = matched[i] );\n                        }\n                    }) :\n                    function( elem ) {\n                        return fn( elem, 0, args );\n                    };\n            }\n\n            return fn;\n        }\n    },\n\n    pseudos: {\n        // Potentially complex pseudos\n        \"not\": markFunction(function( selector ) {\n            // Trim the selector passed to compile\n            // to avoid treating leading and trailing\n            // spaces as combinators\n            var input = [],\n                results = [],\n                matcher = compile( selector.replace( rtrim, \"$1\" ) );\n\n            return matcher[ expando ] ?\n                markFunction(function( seed, matches, context, xml ) {\n                    var elem,\n                        unmatched = matcher( seed, null, xml, [] ),\n                        i = seed.length;\n\n                    // Match elements unmatched by `matcher`\n                    while ( i-- ) {\n                        if ( (elem = unmatched[i]) ) {\n                            seed[i] = !(matches[i] = elem);\n                        }\n                    }\n                }) :\n                function( elem, context, xml ) {\n                    input[0] = elem;\n                    matcher( input, null, xml, results );\n                    return !results.pop();\n                };\n        }),\n\n        \"has\": markFunction(function( selector ) {\n            return function( elem ) {\n                return Sizzle( selector, elem ).length > 0;\n            };\n        }),\n\n        \"contains\": markFunction(function( text ) {\n            return function( elem ) {\n                return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;\n            };\n        }),\n\n        // \"Whether an element is represented by a :lang() selector\n        // is based solely on the element's language value\n        // being equal to the identifier C,\n        // or beginning with the identifier C immediately followed by \"-\".\n        // The matching of C against the element's language value is performed case-insensitively.\n        // The identifier C does not have to be a valid language name.\"\n        // http://www.w3.org/TR/selectors/#lang-pseudo\n        \"lang\": markFunction( function( lang ) {\n            // lang value must be a valid identifier\n            if ( !ridentifier.test(lang || \"\") ) {\n                Sizzle.error( \"unsupported lang: \" + lang );\n            }\n            lang = lang.replace( runescape, funescape ).toLowerCase();\n            return function( elem ) {\n                var elemLang;\n                do {\n                    if ( (elemLang = documentIsHTML ?\n                        elem.lang :\n                        elem.getAttribute(\"xml:lang\") || elem.getAttribute(\"lang\")) ) {\n\n                        elemLang = elemLang.toLowerCase();\n                        return elemLang === lang || elemLang.indexOf( lang + \"-\" ) === 0;\n                    }\n                } while ( (elem = elem.parentNode) && elem.nodeType === 1 );\n                return false;\n            };\n        }),\n\n        // Miscellaneous\n        \"target\": function( elem ) {\n            var hash = window.location && window.location.hash;\n            return hash && hash.slice( 1 ) === elem.id;\n        },\n\n        \"root\": function( elem ) {\n            return elem === docElem;\n        },\n\n        \"focus\": function( elem ) {\n            return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);\n        },\n\n        // Boolean properties\n        \"enabled\": function( elem ) {\n            return elem.disabled === false;\n        },\n\n        \"disabled\": function( elem ) {\n            return elem.disabled === true;\n        },\n\n        \"checked\": function( elem ) {\n            // In CSS3, :checked should return both checked and selected elements\n            // http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked\n            var nodeName = elem.nodeName.toLowerCase();\n            return (nodeName === \"input\" && !!elem.checked) || (nodeName === \"option\" && !!elem.selected);\n        },\n\n        \"selected\": function( elem ) {\n            // Accessing this property makes selected-by-default\n            // options in Safari work properly\n            if ( elem.parentNode ) {\n                elem.parentNode.selectedIndex;\n            }\n\n            return elem.selected === true;\n        },\n\n        // Contents\n        \"empty\": function( elem ) {\n            // http://www.w3.org/TR/selectors/#empty-pseudo\n            // :empty is only affected by element nodes and content nodes(including text(3), cdata(4)),\n            //   not comment, processing instructions, or others\n            // Thanks to Diego Perini for the nodeName shortcut\n            //   Greater than \"@\" means alpha characters (specifically not starting with \"#\" or \"?\")\n            for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {\n                if ( elem.nodeName > \"@\" || elem.nodeType === 3 || elem.nodeType === 4 ) {\n                    return false;\n                }\n            }\n            return true;\n        },\n\n        \"parent\": function( elem ) {\n            return !Expr.pseudos[\"empty\"]( elem );\n        },\n\n        // Element/input types\n        \"header\": function( elem ) {\n            return rheader.test( elem.nodeName );\n        },\n\n        \"input\": function( elem ) {\n            return rinputs.test( elem.nodeName );\n        },\n\n        \"button\": function( elem ) {\n            var name = elem.nodeName.toLowerCase();\n            return name === \"input\" && elem.type === \"button\" || name === \"button\";\n        },\n\n        \"text\": function( elem ) {\n            var attr;\n            // IE6 and 7 will map elem.type to 'text' for new HTML5 types (search, etc)\n            // use getAttribute instead to test this case\n            return elem.nodeName.toLowerCase() === \"input\" &&\n                elem.type === \"text\" &&\n                ( (attr = elem.getAttribute(\"type\")) == null || attr.toLowerCase() === elem.type );\n        },\n\n        // Position-in-collection\n        \"first\": createPositionalPseudo(function() {\n            return [ 0 ];\n        }),\n\n        \"last\": createPositionalPseudo(function( matchIndexes, length ) {\n            return [ length - 1 ];\n        }),\n\n        \"eq\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n            return [ argument < 0 ? argument + length : argument ];\n        }),\n\n        \"even\": createPositionalPseudo(function( matchIndexes, length ) {\n            var i = 0;\n            for ( ; i < length; i += 2 ) {\n                matchIndexes.push( i );\n            }\n            return matchIndexes;\n        }),\n\n        \"odd\": createPositionalPseudo(function( matchIndexes, length ) {\n            var i = 1;\n            for ( ; i < length; i += 2 ) {\n                matchIndexes.push( i );\n            }\n            return matchIndexes;\n        }),\n\n        \"lt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n            var i = argument < 0 ? argument + length : argument;\n            for ( ; --i >= 0; ) {\n                matchIndexes.push( i );\n            }\n            return matchIndexes;\n        }),\n\n        \"gt\": createPositionalPseudo(function( matchIndexes, length, argument ) {\n            var i = argument < 0 ? argument + length : argument;\n            for ( ; ++i < length; ) {\n                matchIndexes.push( i );\n            }\n            return matchIndexes;\n        })\n    }\n};\n\nExpr.pseudos[\"nth\"] = Expr.pseudos[\"eq\"];\n\n// Add button/input type pseudos\nfor ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {\n    Expr.pseudos[ i ] = createInputPseudo( i );\n}\nfor ( i in { submit: true, reset: true } ) {\n    Expr.pseudos[ i ] = createButtonPseudo( i );\n}\n\n// Easy API for creating new setFilters\nfunction setFilters() {}\nsetFilters.prototype = Expr.filters = Expr.pseudos;\nExpr.setFilters = new setFilters();\n\nfunction tokenize( selector, parseOnly ) {\n    var matched, match, tokens, type,\n        soFar, groups, preFilters,\n        cached = tokenCache[ selector + \" \" ];\n\n    if ( cached ) {\n        return parseOnly ? 0 : cached.slice( 0 );\n    }\n\n    soFar = selector;\n    groups = [];\n    preFilters = Expr.preFilter;\n\n    while ( soFar ) {\n\n        // Comma and first run\n        if ( !matched || (match = rcomma.exec( soFar )) ) {\n            if ( match ) {\n                // Don't consume trailing commas as valid\n                soFar = soFar.slice( match[0].length ) || soFar;\n            }\n            groups.push( tokens = [] );\n        }\n\n        matched = false;\n\n        // Combinators\n        if ( (match = rcombinators.exec( soFar )) ) {\n            matched = match.shift();\n            tokens.push({\n                value: matched,\n                // Cast descendant combinators to space\n                type: match[0].replace( rtrim, \" \" )\n            });\n            soFar = soFar.slice( matched.length );\n        }\n\n        // Filters\n        for ( type in Expr.filter ) {\n            if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||\n                (match = preFilters[ type ]( match ))) ) {\n                matched = match.shift();\n                tokens.push({\n                    value: matched,\n                    type: type,\n                    matches: match\n                });\n                soFar = soFar.slice( matched.length );\n            }\n        }\n\n        if ( !matched ) {\n            break;\n        }\n    }\n\n    // Return the length of the invalid excess\n    // if we're just parsing\n    // Otherwise, throw an error or return tokens\n    return parseOnly ?\n        soFar.length :\n        soFar ?\n            Sizzle.error( selector ) :\n            // Cache the tokens\n            tokenCache( selector, groups ).slice( 0 );\n}\n\nfunction toSelector( tokens ) {\n    var i = 0,\n        len = tokens.length,\n        selector = \"\";\n    for ( ; i < len; i++ ) {\n        selector += tokens[i].value;\n    }\n    return selector;\n}\n\nfunction addCombinator( matcher, combinator, base ) {\n    var dir = combinator.dir,\n        checkNonElements = base && dir === \"parentNode\",\n        doneName = done++;\n\n    return combinator.first ?\n        // Check against closest ancestor/preceding element\n        function( elem, context, xml ) {\n            while ( (elem = elem[ dir ]) ) {\n                if ( elem.nodeType === 1 || checkNonElements ) {\n                    return matcher( elem, context, xml );\n                }\n            }\n        } :\n\n        // Check against all ancestor/preceding elements\n        function( elem, context, xml ) {\n            var data, cache, outerCache,\n                dirkey = dirruns + \" \" + doneName;\n\n            // We can't set arbitrary data on XML nodes, so they don't benefit from dir caching\n            if ( xml ) {\n                while ( (elem = elem[ dir ]) ) {\n                    if ( elem.nodeType === 1 || checkNonElements ) {\n                        if ( matcher( elem, context, xml ) ) {\n                            return true;\n                        }\n                    }\n                }\n            } else {\n                while ( (elem = elem[ dir ]) ) {\n                    if ( elem.nodeType === 1 || checkNonElements ) {\n                        outerCache = elem[ expando ] || (elem[ expando ] = {});\n                        if ( (cache = outerCache[ dir ]) && cache[0] === dirkey ) {\n                            if ( (data = cache[1]) === true || data === cachedruns ) {\n                                return data === true;\n                            }\n                        } else {\n                            cache = outerCache[ dir ] = [ dirkey ];\n                            cache[1] = matcher( elem, context, xml ) || cachedruns;\n                            if ( cache[1] === true ) {\n                                return true;\n                            }\n                        }\n                    }\n                }\n            }\n        };\n}\n\nfunction elementMatcher( matchers ) {\n    return matchers.length > 1 ?\n        function( elem, context, xml ) {\n            var i = matchers.length;\n            while ( i-- ) {\n                if ( !matchers[i]( elem, context, xml ) ) {\n                    return false;\n                }\n            }\n            return true;\n        } :\n        matchers[0];\n}\n\nfunction condense( unmatched, map, filter, context, xml ) {\n    var elem,\n        newUnmatched = [],\n        i = 0,\n        len = unmatched.length,\n        mapped = map != null;\n\n    for ( ; i < len; i++ ) {\n        if ( (elem = unmatched[i]) ) {\n            if ( !filter || filter( elem, context, xml ) ) {\n                newUnmatched.push( elem );\n                if ( mapped ) {\n                    map.push( i );\n                }\n            }\n        }\n    }\n\n    return newUnmatched;\n}\n\nfunction setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {\n    if ( postFilter && !postFilter[ expando ] ) {\n        postFilter = setMatcher( postFilter );\n    }\n    if ( postFinder && !postFinder[ expando ] ) {\n        postFinder = setMatcher( postFinder, postSelector );\n    }\n    return markFunction(function( seed, results, context, xml ) {\n        var temp, i, elem,\n            preMap = [],\n            postMap = [],\n            preexisting = results.length,\n\n            // Get initial elements from seed or context\n            elems = seed || multipleContexts( selector || \"*\", context.nodeType ? [ context ] : context, [] ),\n\n            // Prefilter to get matcher input, preserving a map for seed-results synchronization\n            matcherIn = preFilter && ( seed || !selector ) ?\n                condense( elems, preMap, preFilter, context, xml ) :\n                elems,\n\n            matcherOut = matcher ?\n                // If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,\n                postFinder || ( seed ? preFilter : preexisting || postFilter ) ?\n\n                    // ...intermediate processing is necessary\n                    [] :\n\n                    // ...otherwise use results directly\n                    results :\n                matcherIn;\n\n        // Find primary matches\n        if ( matcher ) {\n            matcher( matcherIn, matcherOut, context, xml );\n        }\n\n        // Apply postFilter\n        if ( postFilter ) {\n            temp = condense( matcherOut, postMap );\n            postFilter( temp, [], context, xml );\n\n            // Un-match failing elements by moving them back to matcherIn\n            i = temp.length;\n            while ( i-- ) {\n                if ( (elem = temp[i]) ) {\n                    matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);\n                }\n            }\n        }\n\n        if ( seed ) {\n            if ( postFinder || preFilter ) {\n                if ( postFinder ) {\n                    // Get the final matcherOut by condensing this intermediate into postFinder contexts\n                    temp = [];\n                    i = matcherOut.length;\n                    while ( i-- ) {\n                        if ( (elem = matcherOut[i]) ) {\n                            // Restore matcherIn since elem is not yet a final match\n                            temp.push( (matcherIn[i] = elem) );\n                        }\n                    }\n                    postFinder( null, (matcherOut = []), temp, xml );\n                }\n\n                // Move matched elements from seed to results to keep them synchronized\n                i = matcherOut.length;\n                while ( i-- ) {\n                    if ( (elem = matcherOut[i]) &&\n                        (temp = postFinder ? indexOf.call( seed, elem ) : preMap[i]) > -1 ) {\n\n                        seed[temp] = !(results[temp] = elem);\n                    }\n                }\n            }\n\n        // Add elements to results, through postFinder if defined\n        } else {\n            matcherOut = condense(\n                matcherOut === results ?\n                    matcherOut.splice( preexisting, matcherOut.length ) :\n                    matcherOut\n            );\n            if ( postFinder ) {\n                postFinder( null, results, matcherOut, xml );\n            } else {\n                push.apply( results, matcherOut );\n            }\n        }\n    });\n}\n\nfunction matcherFromTokens( tokens ) {\n    var checkContext, matcher, j,\n        len = tokens.length,\n        leadingRelative = Expr.relative[ tokens[0].type ],\n        implicitRelative = leadingRelative || Expr.relative[\" \"],\n        i = leadingRelative ? 1 : 0,\n\n        // The foundational matcher ensures that elements are reachable from top-level context(s)\n        matchContext = addCombinator( function( elem ) {\n            return elem === checkContext;\n        }, implicitRelative, true ),\n        matchAnyContext = addCombinator( function( elem ) {\n            return indexOf.call( checkContext, elem ) > -1;\n        }, implicitRelative, true ),\n        matchers = [ function( elem, context, xml ) {\n            return ( !leadingRelative && ( xml || context !== outermostContext ) ) || (\n                (checkContext = context).nodeType ?\n                    matchContext( elem, context, xml ) :\n                    matchAnyContext( elem, context, xml ) );\n        } ];\n\n    for ( ; i < len; i++ ) {\n        if ( (matcher = Expr.relative[ tokens[i].type ]) ) {\n            matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];\n        } else {\n            matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );\n\n            // Return special upon seeing a positional matcher\n            if ( matcher[ expando ] ) {\n                // Find the next relative operator (if any) for proper handling\n                j = ++i;\n                for ( ; j < len; j++ ) {\n                    if ( Expr.relative[ tokens[j].type ] ) {\n                        break;\n                    }\n                }\n                return setMatcher(\n                    i > 1 && elementMatcher( matchers ),\n                    i > 1 && toSelector(\n                        // If the preceding token was a descendant combinator, insert an implicit any-element `*`\n                        tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === \" \" ? \"*\" : \"\" })\n                    ).replace( rtrim, \"$1\" ),\n                    matcher,\n                    i < j && matcherFromTokens( tokens.slice( i, j ) ),\n                    j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),\n                    j < len && toSelector( tokens )\n                );\n            }\n            matchers.push( matcher );\n        }\n    }\n\n    return elementMatcher( matchers );\n}\n\nfunction matcherFromGroupMatchers( elementMatchers, setMatchers ) {\n    // A counter to specify which element is currently being matched\n    var matcherCachedRuns = 0,\n        bySet = setMatchers.length > 0,\n        byElement = elementMatchers.length > 0,\n        superMatcher = function( seed, context, xml, results, expandContext ) {\n            var elem, j, matcher,\n                setMatched = [],\n                matchedCount = 0,\n                i = \"0\",\n                unmatched = seed && [],\n                outermost = expandContext != null,\n                contextBackup = outermostContext,\n                // We must always have either seed elements or context\n                elems = seed || byElement && Expr.find[\"TAG\"]( \"*\", expandContext && context.parentNode || context ),\n                // Use integer dirruns iff this is the outermost matcher\n                dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1);\n\n            if ( outermost ) {\n                outermostContext = context !== document && context;\n                cachedruns = matcherCachedRuns;\n            }\n\n            // Add elements passing elementMatchers directly to results\n            // Keep `i` a string if there are no elements so `matchedCount` will be \"00\" below\n            for ( ; (elem = elems[i]) != null; i++ ) {\n                if ( byElement && elem ) {\n                    j = 0;\n                    while ( (matcher = elementMatchers[j++]) ) {\n                        if ( matcher( elem, context, xml ) ) {\n                            results.push( elem );\n                            break;\n                        }\n                    }\n                    if ( outermost ) {\n                        dirruns = dirrunsUnique;\n                        cachedruns = ++matcherCachedRuns;\n                    }\n                }\n\n                // Track unmatched elements for set filters\n                if ( bySet ) {\n                    // They will have gone through all possible matchers\n                    if ( (elem = !matcher && elem) ) {\n                        matchedCount--;\n                    }\n\n                    // Lengthen the array for every element, matched or not\n                    if ( seed ) {\n                        unmatched.push( elem );\n                    }\n                }\n            }\n\n            // Apply set filters to unmatched elements\n            matchedCount += i;\n            if ( bySet && i !== matchedCount ) {\n                j = 0;\n                while ( (matcher = setMatchers[j++]) ) {\n                    matcher( unmatched, setMatched, context, xml );\n                }\n\n                if ( seed ) {\n                    // Reintegrate element matches to eliminate the need for sorting\n                    if ( matchedCount > 0 ) {\n                        while ( i-- ) {\n                            if ( !(unmatched[i] || setMatched[i]) ) {\n                                setMatched[i] = pop.call( results );\n                            }\n                        }\n                    }\n\n                    // Discard index placeholder values to get only actual matches\n                    setMatched = condense( setMatched );\n                }\n\n                // Add matches to results\n                push.apply( results, setMatched );\n\n                // Seedless set matches succeeding multiple successful matchers stipulate sorting\n                if ( outermost && !seed && setMatched.length > 0 &&\n                    ( matchedCount + setMatchers.length ) > 1 ) {\n\n                    Sizzle.uniqueSort( results );\n                }\n            }\n\n            // Override manipulation of globals by nested matchers\n            if ( outermost ) {\n                dirruns = dirrunsUnique;\n                outermostContext = contextBackup;\n            }\n\n            return unmatched;\n        };\n\n    return bySet ?\n        markFunction( superMatcher ) :\n        superMatcher;\n}\n\ncompile = Sizzle.compile = function( selector, group /* Internal Use Only */ ) {\n    var i,\n        setMatchers = [],\n        elementMatchers = [],\n        cached = compilerCache[ selector + \" \" ];\n\n    if ( !cached ) {\n        // Generate a function of recursive functions that can be used to check each element\n        if ( !group ) {\n            group = tokenize( selector );\n        }\n        i = group.length;\n        while ( i-- ) {\n            cached = matcherFromTokens( group[i] );\n            if ( cached[ expando ] ) {\n                setMatchers.push( cached );\n            } else {\n                elementMatchers.push( cached );\n            }\n        }\n\n        // Cache the compiled function\n        cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );\n    }\n    return cached;\n};\n\nfunction multipleContexts( selector, contexts, results ) {\n    var i = 0,\n        len = contexts.length;\n    for ( ; i < len; i++ ) {\n        Sizzle( selector, contexts[i], results );\n    }\n    return results;\n}\n\nfunction select( selector, context, results, seed ) {\n    var i, tokens, token, type, find,\n        match = tokenize( selector );\n\n    if ( !seed ) {\n        // Try to minimize operations if there is only one group\n        if ( match.length === 1 ) {\n\n            // Take a shortcut and set the context if the root selector is an ID\n            tokens = match[0] = match[0].slice( 0 );\n            if ( tokens.length > 2 && (token = tokens[0]).type === \"ID\" &&\n                    support.getById && context.nodeType === 9 && documentIsHTML &&\n                    Expr.relative[ tokens[1].type ] ) {\n\n                context = ( Expr.find[\"ID\"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];\n                if ( !context ) {\n                    return results;\n                }\n                selector = selector.slice( tokens.shift().value.length );\n            }\n\n            // Fetch a seed set for right-to-left matching\n            i = matchExpr[\"needsContext\"].test( selector ) ? 0 : tokens.length;\n            while ( i-- ) {\n                token = tokens[i];\n\n                // Abort if we hit a combinator\n                if ( Expr.relative[ (type = token.type) ] ) {\n                    break;\n                }\n                if ( (find = Expr.find[ type ]) ) {\n                    // Search, expanding context for leading sibling combinators\n                    if ( (seed = find(\n                        token.matches[0].replace( runescape, funescape ),\n                        rsibling.test( tokens[0].type ) && context.parentNode || context\n                    )) ) {\n\n                        // If seed is empty or no tokens remain, we can return early\n                        tokens.splice( i, 1 );\n                        selector = seed.length && toSelector( tokens );\n                        if ( !selector ) {\n                            push.apply( results, seed );\n                            return results;\n                        }\n\n                        break;\n                    }\n                }\n            }\n        }\n    }\n\n    // Compile and execute a filtering function\n    // Provide `match` to avoid retokenization if we modified the selector above\n    compile( selector, match )(\n        seed,\n        context,\n        !documentIsHTML,\n        results,\n        rsibling.test( selector )\n    );\n    return results;\n}\n\n// One-time assignments\n\n// Sort stability\nsupport.sortStable = expando.split(\"\").sort( sortOrder ).join(\"\") === expando;\n\n// Support: Chrome<14\n// Always assume duplicates if they aren't passed to the comparison function\nsupport.detectDuplicates = hasDuplicate;\n\n// Initialize against the default document\nsetDocument();\n\n// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)\n// Detached nodes confoundingly follow *each other*\nsupport.sortDetached = assert(function( div1 ) {\n    // Should return 1, but returns 4 (following)\n    return div1.compareDocumentPosition( document.createElement(\"div\") ) & 1;\n});\n\n// Support: IE<8\n// Prevent attribute/property \"interpolation\"\n// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\nif ( !assert(function( div ) {\n    div.innerHTML = \"<a href='#'></a>\";\n    return div.firstChild.getAttribute(\"href\") === \"#\" ;\n}) ) {\n    addHandle( \"type|href|height|width\", function( elem, name, isXML ) {\n        if ( !isXML ) {\n            return elem.getAttribute( name, name.toLowerCase() === \"type\" ? 1 : 2 );\n        }\n    });\n}\n\n// Support: IE<9\n// Use defaultValue in place of getAttribute(\"value\")\nif ( !support.attributes || !assert(function( div ) {\n    div.innerHTML = \"<input/>\";\n    div.firstChild.setAttribute( \"value\", \"\" );\n    return div.firstChild.getAttribute( \"value\" ) === \"\";\n}) ) {\n    addHandle( \"value\", function( elem, name, isXML ) {\n        if ( !isXML && elem.nodeName.toLowerCase() === \"input\" ) {\n            return elem.defaultValue;\n        }\n    });\n}\n\n// Support: IE<9\n// Use getAttributeNode to fetch booleans when getAttribute lies\nif ( !assert(function( div ) {\n    return div.getAttribute(\"disabled\") == null;\n}) ) {\n    addHandle( booleans, function( elem, name, isXML ) {\n        var val;\n        if ( !isXML ) {\n            return (val = elem.getAttributeNode( name )) && val.specified ?\n                val.value :\n                elem[ name ] === true ? name.toLowerCase() : null;\n        }\n    });\n}\n\njQuery.find = Sizzle;\njQuery.expr = Sizzle.selectors;\njQuery.expr[\":\"] = jQuery.expr.pseudos;\njQuery.unique = Sizzle.uniqueSort;\njQuery.text = Sizzle.getText;\njQuery.isXMLDoc = Sizzle.isXML;\njQuery.contains = Sizzle.contains;\n\n\n})( window );\n// String to Object options format cache\nvar optionsCache = {};\n\n// Convert String-formatted options into Object-formatted ones and store in cache\nfunction createOptions( options ) {\n    var object = optionsCache[ options ] = {};\n    jQuery.each( options.match( core_rnotwhite ) || [], function( _, flag ) {\n        object[ flag ] = true;\n    });\n    return object;\n}\n\n/*\n * Create a callback list using the following parameters:\n *\n *  options: an optional list of space-separated options that will change how\n *          the callback list behaves or a more traditional option object\n *\n * By default a callback list will act like an event callback list and can be\n * \"fired\" multiple times.\n *\n * Possible options:\n *\n *  once:           will ensure the callback list can only be fired once (like a Deferred)\n *\n *  memory:         will keep track of previous values and will call any callback added\n *                  after the list has been fired right away with the latest \"memorized\"\n *                  values (like a Deferred)\n *\n *  unique:         will ensure a callback can only be added once (no duplicate in the list)\n *\n *  stopOnFalse:    interrupt callings when a callback returns false\n *\n */\njQuery.Callbacks = function( options ) {\n\n    // Convert options from String-formatted to Object-formatted if needed\n    // (we check in cache first)\n    options = typeof options === \"string\" ?\n        ( optionsCache[ options ] || createOptions( options ) ) :\n        jQuery.extend( {}, options );\n\n    var // Flag to know if list is currently firing\n        firing,\n        // Last fire value (for non-forgettable lists)\n        memory,\n        // Flag to know if list was already fired\n        fired,\n        // End of the loop when firing\n        firingLength,\n        // Index of currently firing callback (modified by remove if needed)\n        firingIndex,\n        // First callback to fire (used internally by add and fireWith)\n        firingStart,\n        // Actual callback list\n        list = [],\n        // Stack of fire calls for repeatable lists\n        stack = !options.once && [],\n        // Fire callbacks\n        fire = function( data ) {\n            memory = options.memory && data;\n            fired = true;\n            firingIndex = firingStart || 0;\n            firingStart = 0;\n            firingLength = list.length;\n            firing = true;\n            for ( ; list && firingIndex < firingLength; firingIndex++ ) {\n                if ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {\n                    memory = false; // To prevent further calls using add\n                    break;\n                }\n            }\n            firing = false;\n            if ( list ) {\n                if ( stack ) {\n                    if ( stack.length ) {\n                        fire( stack.shift() );\n                    }\n                } else if ( memory ) {\n                    list = [];\n                } else {\n                    self.disable();\n                }\n            }\n        },\n        // Actual Callbacks object\n        self = {\n            // Add a callback or a collection of callbacks to the list\n            add: function() {\n                if ( list ) {\n                    // First, we save the current length\n                    var start = list.length;\n                    (function add( args ) {\n                        jQuery.each( args, function( _, arg ) {\n                            var type = jQuery.type( arg );\n                            if ( type === \"function\" ) {\n                                if ( !options.unique || !self.has( arg ) ) {\n                                    list.push( arg );\n                                }\n                            } else if ( arg && arg.length && type !== \"string\" ) {\n                                // Inspect recursively\n                                add( arg );\n                            }\n                        });\n                    })( arguments );\n                    // Do we need to add the callbacks to the\n                    // current firing batch?\n                    if ( firing ) {\n                        firingLength = list.length;\n                    // With memory, if we're not firing then\n                    // we should call right away\n                    } else if ( memory ) {\n                        firingStart = start;\n                        fire( memory );\n                    }\n                }\n                return this;\n            },\n            // Remove a callback from the list\n            remove: function() {\n                if ( list ) {\n                    jQuery.each( arguments, function( _, arg ) {\n                        var index;\n                        while( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {\n                            list.splice( index, 1 );\n                            // Handle firing indexes\n                            if ( firing ) {\n                                if ( index <= firingLength ) {\n                                    firingLength--;\n                                }\n                                if ( index <= firingIndex ) {\n                                    firingIndex--;\n                                }\n                            }\n                        }\n                    });\n                }\n                return this;\n            },\n            // Check if a given callback is in the list.\n            // If no argument is given, return whether or not list has callbacks attached.\n            has: function( fn ) {\n                return fn ? jQuery.inArray( fn, list ) > -1 : !!( list && list.length );\n            },\n            // Remove all callbacks from the list\n            empty: function() {\n                list = [];\n                firingLength = 0;\n                return this;\n            },\n            // Have the list do nothing anymore\n            disable: function() {\n                list = stack = memory = undefined;\n                return this;\n            },\n            // Is it disabled?\n            disabled: function() {\n                return !list;\n            },\n            // Lock the list in its current state\n            lock: function() {\n                stack = undefined;\n                if ( !memory ) {\n                    self.disable();\n                }\n                return this;\n            },\n            // Is it locked?\n            locked: function() {\n                return !stack;\n            },\n            // Call all callbacks with the given context and arguments\n            fireWith: function( context, args ) {\n                if ( list && ( !fired || stack ) ) {\n                    args = args || [];\n                    args = [ context, args.slice ? args.slice() : args ];\n                    if ( firing ) {\n                        stack.push( args );\n                    } else {\n                        fire( args );\n                    }\n                }\n                return this;\n            },\n            // Call all the callbacks with the given arguments\n            fire: function() {\n                self.fireWith( this, arguments );\n                return this;\n            },\n            // To know if the callbacks have already been called at least once\n            fired: function() {\n                return !!fired;\n            }\n        };\n\n    return self;\n};\njQuery.extend({\n\n    Deferred: function( func ) {\n        var tuples = [\n                // action, add listener, listener list, final state\n                [ \"resolve\", \"done\", jQuery.Callbacks(\"once memory\"), \"resolved\" ],\n                [ \"reject\", \"fail\", jQuery.Callbacks(\"once memory\"), \"rejected\" ],\n                [ \"notify\", \"progress\", jQuery.Callbacks(\"memory\") ]\n            ],\n            state = \"pending\",\n            promise = {\n                state: function() {\n                    return state;\n                },\n                always: function() {\n                    deferred.done( arguments ).fail( arguments );\n                    return this;\n                },\n                then: function( /* fnDone, fnFail, fnProgress */ ) {\n                    var fns = arguments;\n                    return jQuery.Deferred(function( newDefer ) {\n                        jQuery.each( tuples, function( i, tuple ) {\n                            var action = tuple[ 0 ],\n                                fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];\n                            // deferred[ done | fail | progress ] for forwarding actions to newDefer\n                            deferred[ tuple[1] ](function() {\n                                var returned = fn && fn.apply( this, arguments );\n                                if ( returned && jQuery.isFunction( returned.promise ) ) {\n                                    returned.promise()\n                                        .done( newDefer.resolve )\n                                        .fail( newDefer.reject )\n                                        .progress( newDefer.notify );\n                                } else {\n                                    newDefer[ action + \"With\" ]( this === promise ? newDefer.promise() : this, fn ? [ returned ] : arguments );\n                                }\n                            });\n                        });\n                        fns = null;\n                    }).promise();\n                },\n                // Get a promise for this deferred\n                // If obj is provided, the promise aspect is added to the object\n                promise: function( obj ) {\n                    return obj != null ? jQuery.extend( obj, promise ) : promise;\n                }\n            },\n            deferred = {};\n\n        // Keep pipe for back-compat\n        promise.pipe = promise.then;\n\n        // Add list-specific methods\n        jQuery.each( tuples, function( i, tuple ) {\n            var list = tuple[ 2 ],\n                stateString = tuple[ 3 ];\n\n            // promise[ done | fail | progress ] = list.add\n            promise[ tuple[1] ] = list.add;\n\n            // Handle state\n            if ( stateString ) {\n                list.add(function() {\n                    // state = [ resolved | rejected ]\n                    state = stateString;\n\n                // [ reject_list | resolve_list ].disable; progress_list.lock\n                }, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );\n            }\n\n            // deferred[ resolve | reject | notify ]\n            deferred[ tuple[0] ] = function() {\n                deferred[ tuple[0] + \"With\" ]( this === deferred ? promise : this, arguments );\n                return this;\n            };\n            deferred[ tuple[0] + \"With\" ] = list.fireWith;\n        });\n\n        // Make the deferred a promise\n        promise.promise( deferred );\n\n        // Call given func if any\n        if ( func ) {\n            func.call( deferred, deferred );\n        }\n\n        // All done!\n        return deferred;\n    },\n\n    // Deferred helper\n    when: function( subordinate /* , ..., subordinateN */ ) {\n        var i = 0,\n            resolveValues = core_slice.call( arguments ),\n            length = resolveValues.length,\n\n            // the count of uncompleted subordinates\n            remaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,\n\n            // the master Deferred. If resolveValues consist of only a single Deferred, just use that.\n            deferred = remaining === 1 ? subordinate : jQuery.Deferred(),\n\n            // Update function for both resolve and progress values\n            updateFunc = function( i, contexts, values ) {\n                return function( value ) {\n                    contexts[ i ] = this;\n                    values[ i ] = arguments.length > 1 ? core_slice.call( arguments ) : value;\n                    if( values === progressValues ) {\n                        deferred.notifyWith( contexts, values );\n                    } else if ( !( --remaining ) ) {\n                        deferred.resolveWith( contexts, values );\n                    }\n                };\n            },\n\n            progressValues, progressContexts, resolveContexts;\n\n        // add listeners to Deferred subordinates; treat others as resolved\n        if ( length > 1 ) {\n            progressValues = new Array( length );\n            progressContexts = new Array( length );\n            resolveContexts = new Array( length );\n            for ( ; i < length; i++ ) {\n                if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {\n                    resolveValues[ i ].promise()\n                        .done( updateFunc( i, resolveContexts, resolveValues ) )\n                        .fail( deferred.reject )\n                        .progress( updateFunc( i, progressContexts, progressValues ) );\n                } else {\n                    --remaining;\n                }\n            }\n        }\n\n        // if we're not waiting on anything, resolve the master\n        if ( !remaining ) {\n            deferred.resolveWith( resolveContexts, resolveValues );\n        }\n\n        return deferred.promise();\n    }\n});\njQuery.support = (function( support ) {\n\n    var all, a, input, select, fragment, opt, eventName, isSupported, i,\n        div = document.createElement(\"div\");\n\n    // Setup\n    div.setAttribute( \"className\", \"t\" );\n    div.innerHTML = \"  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>\";\n\n    // Finish early in limited (non-browser) environments\n    all = div.getElementsByTagName(\"*\") || [];\n    a = div.getElementsByTagName(\"a\")[ 0 ];\n    if ( !a || !a.style || !all.length ) {\n        return support;\n    }\n\n    // First batch of tests\n    select = document.createElement(\"select\");\n    opt = select.appendChild( document.createElement(\"option\") );\n    input = div.getElementsByTagName(\"input\")[ 0 ];\n\n    a.style.cssText = \"top:1px;float:left;opacity:.5\";\n\n    // Test setAttribute on camelCase class. If it works, we need attrFixes when doing get/setAttribute (ie6/7)\n    support.getSetAttribute = div.className !== \"t\";\n\n    // IE strips leading whitespace when .innerHTML is used\n    support.leadingWhitespace = div.firstChild.nodeType === 3;\n\n    // Make sure that tbody elements aren't automatically inserted\n    // IE will insert them into empty tables\n    support.tbody = !div.getElementsByTagName(\"tbody\").length;\n\n    // Make sure that link elements get serialized correctly by innerHTML\n    // This requires a wrapper element in IE\n    support.htmlSerialize = !!div.getElementsByTagName(\"link\").length;\n\n    // Get the style information from getAttribute\n    // (IE uses .cssText instead)\n    support.style = /top/.test( a.getAttribute(\"style\") );\n\n    // Make sure that URLs aren't manipulated\n    // (IE normalizes it by default)\n    support.hrefNormalized = a.getAttribute(\"href\") === \"/a\";\n\n    // Make sure that element opacity exists\n    // (IE uses filter instead)\n    // Use a regex to work around a WebKit issue. See #5145\n    support.opacity = /^0.5/.test( a.style.opacity );\n\n    // Verify style float existence\n    // (IE uses styleFloat instead of cssFloat)\n    support.cssFloat = !!a.style.cssFloat;\n\n    // Check the default checkbox/radio value (\"\" on WebKit; \"on\" elsewhere)\n    support.checkOn = !!input.value;\n\n    // Make sure that a selected-by-default option has a working selected property.\n    // (WebKit defaults to false instead of true, IE too, if it's in an optgroup)\n    support.optSelected = opt.selected;\n\n    // Tests for enctype support on a form (#6743)\n    support.enctype = !!document.createElement(\"form\").enctype;\n\n    // Makes sure cloning an html5 element does not cause problems\n    // Where outerHTML is undefined, this still works\n    support.html5Clone = document.createElement(\"nav\").cloneNode( true ).outerHTML !== \"<:nav></:nav>\";\n\n    // Will be defined later\n    support.inlineBlockNeedsLayout = false;\n    support.shrinkWrapBlocks = false;\n    support.pixelPosition = false;\n    support.deleteExpando = true;\n    support.noCloneEvent = true;\n    support.reliableMarginRight = true;\n    support.boxSizingReliable = true;\n\n    // Make sure checked status is properly cloned\n    input.checked = true;\n    support.noCloneChecked = input.cloneNode( true ).checked;\n\n    // Make sure that the options inside disabled selects aren't marked as disabled\n    // (WebKit marks them as disabled)\n    select.disabled = true;\n    support.optDisabled = !opt.disabled;\n\n    // Support: IE<9\n    try {\n        delete div.test;\n    } catch( e ) {\n        support.deleteExpando = false;\n    }\n\n    // Check if we can trust getAttribute(\"value\")\n    input = document.createElement(\"input\");\n    input.setAttribute( \"value\", \"\" );\n    support.input = input.getAttribute( \"value\" ) === \"\";\n\n    // Check if an input maintains its value after becoming a radio\n    input.value = \"t\";\n    input.setAttribute( \"type\", \"radio\" );\n    support.radioValue = input.value === \"t\";\n\n    // #11217 - WebKit loses check when the name is after the checked attribute\n    input.setAttribute( \"checked\", \"t\" );\n    input.setAttribute( \"name\", \"t\" );\n\n    fragment = document.createDocumentFragment();\n    fragment.appendChild( input );\n\n    // Check if a disconnected checkbox will retain its checked\n    // value of true after appended to the DOM (IE6/7)\n    support.appendChecked = input.checked;\n\n    // WebKit doesn't clone checked state correctly in fragments\n    support.checkClone = fragment.cloneNode( true ).cloneNode( true ).lastChild.checked;\n\n    // Support: IE<9\n    // Opera does not clone events (and typeof div.attachEvent === undefined).\n    // IE9-10 clones events bound via attachEvent, but they don't trigger with .click()\n    if ( div.attachEvent ) {\n        div.attachEvent( \"onclick\", function() {\n            support.noCloneEvent = false;\n        });\n\n        div.cloneNode( true ).click();\n    }\n\n    // Support: IE<9 (lack submit/change bubble), Firefox 17+ (lack focusin event)\n    // Beware of CSP restrictions (https://developer.mozilla.org/en/Security/CSP)\n    for ( i in { submit: true, change: true, focusin: true }) {\n        div.setAttribute( eventName = \"on\" + i, \"t\" );\n\n        support[ i + \"Bubbles\" ] = eventName in window || div.attributes[ eventName ].expando === false;\n    }\n\n    div.style.backgroundClip = \"content-box\";\n    div.cloneNode( true ).style.backgroundClip = \"\";\n    support.clearCloneStyle = div.style.backgroundClip === \"content-box\";\n\n    // Support: IE<9\n    // Iteration over object's inherited properties before its own.\n    for ( i in jQuery( support ) ) {\n        break;\n    }\n    support.ownLast = i !== \"0\";\n\n    // Run tests that need a body at doc ready\n    jQuery(function() {\n        var container, marginDiv, tds,\n            divReset = \"padding:0;margin:0;border:0;display:block;box-sizing:content-box;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;\",\n            body = document.getElementsByTagName(\"body\")[0];\n\n        if ( !body ) {\n            // Return for frameset docs that don't have a body\n            return;\n        }\n\n        container = document.createElement(\"div\");\n        container.style.cssText = \"border:0;width:0;height:0;position:absolute;top:0;left:-9999px;margin-top:1px\";\n\n        body.appendChild( container ).appendChild( div );\n\n        // Support: IE8\n        // Check if table cells still have offsetWidth/Height when they are set\n        // to display:none and there are still other visible table cells in a\n        // table row; if so, offsetWidth/Height are not reliable for use when\n        // determining if an element has been hidden directly using\n        // display:none (it is still safe to use offsets if a parent element is\n        // hidden; don safety goggles and see bug #4512 for more information).\n        div.innerHTML = \"<table><tr><td></td><td>t</td></tr></table>\";\n        tds = div.getElementsByTagName(\"td\");\n        tds[ 0 ].style.cssText = \"padding:0;margin:0;border:0;display:none\";\n        isSupported = ( tds[ 0 ].offsetHeight === 0 );\n\n        tds[ 0 ].style.display = \"\";\n        tds[ 1 ].style.display = \"none\";\n\n        // Support: IE8\n        // Check if empty table cells still have offsetWidth/Height\n        support.reliableHiddenOffsets = isSupported && ( tds[ 0 ].offsetHeight === 0 );\n\n        // Check box-sizing and margin behavior.\n        div.innerHTML = \"\";\n        div.style.cssText = \"box-sizing:border-box;-moz-box-sizing:border-box;-webkit-box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%;\";\n\n        // Workaround failing boxSizing test due to offsetWidth returning wrong value\n        // with some non-1 values of body zoom, ticket #13543\n        jQuery.swap( body, body.style.zoom != null ? { zoom: 1 } : {}, function() {\n            support.boxSizing = div.offsetWidth === 4;\n        });\n\n        // Use window.getComputedStyle because jsdom on node.js will break without it.\n        if ( window.getComputedStyle ) {\n            support.pixelPosition = ( window.getComputedStyle( div, null ) || {} ).top !== \"1%\";\n            support.boxSizingReliable = ( window.getComputedStyle( div, null ) || { width: \"4px\" } ).width === \"4px\";\n\n            // Check if div with explicit width and no margin-right incorrectly\n            // gets computed margin-right based on width of container. (#3333)\n            // Fails in WebKit before Feb 2011 nightlies\n            // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right\n            marginDiv = div.appendChild( document.createElement(\"div\") );\n            marginDiv.style.cssText = div.style.cssText = divReset;\n            marginDiv.style.marginRight = marginDiv.style.width = \"0\";\n            div.style.width = \"1px\";\n\n            support.reliableMarginRight =\n                !parseFloat( ( window.getComputedStyle( marginDiv, null ) || {} ).marginRight );\n        }\n\n        if ( typeof div.style.zoom !== core_strundefined ) {\n            // Support: IE<8\n            // Check if natively block-level elements act like inline-block\n            // elements when setting their display to 'inline' and giving\n            // them layout\n            div.innerHTML = \"\";\n            div.style.cssText = divReset + \"width:1px;padding:1px;display:inline;zoom:1\";\n            support.inlineBlockNeedsLayout = ( div.offsetWidth === 3 );\n\n            // Support: IE6\n            // Check if elements with layout shrink-wrap their children\n            div.style.display = \"block\";\n            div.innerHTML = \"<div></div>\";\n            div.firstChild.style.width = \"5px\";\n            support.shrinkWrapBlocks = ( div.offsetWidth !== 3 );\n\n            if ( support.inlineBlockNeedsLayout ) {\n                // Prevent IE 6 from affecting layout for positioned elements #11048\n                // Prevent IE from shrinking the body in IE 7 mode #12869\n                // Support: IE<8\n                body.style.zoom = 1;\n            }\n        }\n\n        body.removeChild( container );\n\n        // Null elements to avoid leaks in IE\n        container = div = tds = marginDiv = null;\n    });\n\n    // Null elements to avoid leaks in IE\n    all = select = fragment = opt = a = input = null;\n\n    return support;\n})({});\n\nvar rbrace = /(?:\\{[\\s\\S]*\\}|\\[[\\s\\S]*\\])$/,\n    rmultiDash = /([A-Z])/g;\n\nfunction internalData( elem, name, data, pvt /* Internal Use Only */ ){\n    if ( !jQuery.acceptData( elem ) ) {\n        return;\n    }\n\n    var ret, thisCache,\n        internalKey = jQuery.expando,\n\n        // We have to handle DOM nodes and JS objects differently because IE6-7\n        // can't GC object references properly across the DOM-JS boundary\n        isNode = elem.nodeType,\n\n        // Only DOM nodes need the global jQuery cache; JS object data is\n        // attached directly to the object so GC can occur automatically\n        cache = isNode ? jQuery.cache : elem,\n\n        // Only defining an ID for JS objects if its cache already exists allows\n        // the code to shortcut on the same path as a DOM node with no cache\n        id = isNode ? elem[ internalKey ] : elem[ internalKey ] && internalKey;\n\n    // Avoid doing any more work than we need to when trying to get data on an\n    // object that has no data at all\n    if ( (!id || !cache[id] || (!pvt && !cache[id].data)) && data === undefined && typeof name === \"string\" ) {\n        return;\n    }\n\n    if ( !id ) {\n        // Only DOM nodes need a new unique ID for each element since their data\n        // ends up in the global cache\n        if ( isNode ) {\n            id = elem[ internalKey ] = core_deletedIds.pop() || jQuery.guid++;\n        } else {\n            id = internalKey;\n        }\n    }\n\n    if ( !cache[ id ] ) {\n        // Avoid exposing jQuery metadata on plain JS objects when the object\n        // is serialized using JSON.stringify\n        cache[ id ] = isNode ? {} : { toJSON: jQuery.noop };\n    }\n\n    // An object can be passed to jQuery.data instead of a key/value pair; this gets\n    // shallow copied over onto the existing cache\n    if ( typeof name === \"object\" || typeof name === \"function\" ) {\n        if ( pvt ) {\n            cache[ id ] = jQuery.extend( cache[ id ], name );\n        } else {\n            cache[ id ].data = jQuery.extend( cache[ id ].data, name );\n        }\n    }\n\n    thisCache = cache[ id ];\n\n    // jQuery data() is stored in a separate object inside the object's internal data\n    // cache in order to avoid key collisions between internal data and user-defined\n    // data.\n    if ( !pvt ) {\n        if ( !thisCache.data ) {\n            thisCache.data = {};\n        }\n\n        thisCache = thisCache.data;\n    }\n\n    if ( data !== undefined ) {\n        thisCache[ jQuery.camelCase( name ) ] = data;\n    }\n\n    // Check for both converted-to-camel and non-converted data property names\n    // If a data property was specified\n    if ( typeof name === \"string\" ) {\n\n        // First Try to find as-is property data\n        ret = thisCache[ name ];\n\n        // Test for null|undefined property data\n        if ( ret == null ) {\n\n            // Try to find the camelCased property\n            ret = thisCache[ jQuery.camelCase( name ) ];\n        }\n    } else {\n        ret = thisCache;\n    }\n\n    return ret;\n}\n\nfunction internalRemoveData( elem, name, pvt ) {\n    if ( !jQuery.acceptData( elem ) ) {\n        return;\n    }\n\n    var thisCache, i,\n        isNode = elem.nodeType,\n\n        // See jQuery.data for more information\n        cache = isNode ? jQuery.cache : elem,\n        id = isNode ? elem[ jQuery.expando ] : jQuery.expando;\n\n    // If there is already no cache entry for this object, there is no\n    // purpose in continuing\n    if ( !cache[ id ] ) {\n        return;\n    }\n\n    if ( name ) {\n\n        thisCache = pvt ? cache[ id ] : cache[ id ].data;\n\n        if ( thisCache ) {\n\n            // Support array or space separated string names for data keys\n            if ( !jQuery.isArray( name ) ) {\n\n                // try the string as a key before any manipulation\n                if ( name in thisCache ) {\n                    name = [ name ];\n                } else {\n\n                    // split the camel cased version by spaces unless a key with the spaces exists\n                    name = jQuery.camelCase( name );\n                    if ( name in thisCache ) {\n                        name = [ name ];\n                    } else {\n                        name = name.split(\" \");\n                    }\n                }\n            } else {\n                // If \"name\" is an array of keys...\n                // When data is initially created, via (\"key\", \"val\") signature,\n                // keys will be converted to camelCase.\n                // Since there is no way to tell _how_ a key was added, remove\n                // both plain key and camelCase key. #12786\n                // This will only penalize the array argument path.\n                name = name.concat( jQuery.map( name, jQuery.camelCase ) );\n            }\n\n            i = name.length;\n            while ( i-- ) {\n                delete thisCache[ name[i] ];\n            }\n\n            // If there is no data left in the cache, we want to continue\n            // and let the cache object itself get destroyed\n            if ( pvt ? !isEmptyDataObject(thisCache) : !jQuery.isEmptyObject(thisCache) ) {\n                return;\n            }\n        }\n    }\n\n    // See jQuery.data for more information\n    if ( !pvt ) {\n        delete cache[ id ].data;\n\n        // Don't destroy the parent cache unless the internal data object\n        // had been the only thing left in it\n        if ( !isEmptyDataObject( cache[ id ] ) ) {\n            return;\n        }\n    }\n\n    // Destroy the cache\n    if ( isNode ) {\n        jQuery.cleanData( [ elem ], true );\n\n    // Use delete when supported for expandos or `cache` is not a window per isWindow (#10080)\n    /* jshint eqeqeq: false */\n    } else if ( jQuery.support.deleteExpando || cache != cache.window ) {\n        /* jshint eqeqeq: true */\n        delete cache[ id ];\n\n    // When all else fails, null\n    } else {\n        cache[ id ] = null;\n    }\n}\n\njQuery.extend({\n    cache: {},\n\n    // The following elements throw uncatchable exceptions if you\n    // attempt to add expando properties to them.\n    noData: {\n        \"applet\": true,\n        \"embed\": true,\n        // Ban all objects except for Flash (which handle expandos)\n        \"object\": \"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000\"\n    },\n\n    hasData: function( elem ) {\n        elem = elem.nodeType ? jQuery.cache[ elem[jQuery.expando] ] : elem[ jQuery.expando ];\n        return !!elem && !isEmptyDataObject( elem );\n    },\n\n    data: function( elem, name, data ) {\n        return internalData( elem, name, data );\n    },\n\n    removeData: function( elem, name ) {\n        return internalRemoveData( elem, name );\n    },\n\n    // For internal use only.\n    _data: function( elem, name, data ) {\n        return internalData( elem, name, data, true );\n    },\n\n    _removeData: function( elem, name ) {\n        return internalRemoveData( elem, name, true );\n    },\n\n    // A method for determining if a DOM node can handle the data expando\n    acceptData: function( elem ) {\n        // Do not set data on non-element because it will not be cleared (#8335).\n        if ( elem.nodeType && elem.nodeType !== 1 && elem.nodeType !== 9 ) {\n            return false;\n        }\n\n        var noData = elem.nodeName && jQuery.noData[ elem.nodeName.toLowerCase() ];\n\n        // nodes accept data unless otherwise specified; rejection can be conditional\n        return !noData || noData !== true && elem.getAttribute(\"classid\") === noData;\n    }\n});\n\njQuery.fn.extend({\n    data: function( key, value ) {\n        var attrs, name,\n            data = null,\n            i = 0,\n            elem = this[0];\n\n        // Special expections of .data basically thwart jQuery.access,\n        // so implement the relevant behavior ourselves\n\n        // Gets all values\n        if ( key === undefined ) {\n            if ( this.length ) {\n                data = jQuery.data( elem );\n\n                if ( elem.nodeType === 1 && !jQuery._data( elem, \"parsedAttrs\" ) ) {\n                    attrs = elem.attributes;\n                    for ( ; i < attrs.length; i++ ) {\n                        name = attrs[i].name;\n\n                        if ( name.indexOf(\"data-\") === 0 ) {\n                            name = jQuery.camelCase( name.slice(5) );\n\n                            dataAttr( elem, name, data[ name ] );\n                        }\n                    }\n                    jQuery._data( elem, \"parsedAttrs\", true );\n                }\n            }\n\n            return data;\n        }\n\n        // Sets multiple values\n        if ( typeof key === \"object\" ) {\n            return this.each(function() {\n                jQuery.data( this, key );\n            });\n        }\n\n        return arguments.length > 1 ?\n\n            // Sets one value\n            this.each(function() {\n                jQuery.data( this, key, value );\n            }) :\n\n            // Gets one value\n            // Try to fetch any internally stored data first\n            elem ? dataAttr( elem, key, jQuery.data( elem, key ) ) : null;\n    },\n\n    removeData: function( key ) {\n        return this.each(function() {\n            jQuery.removeData( this, key );\n        });\n    }\n});\n\nfunction dataAttr( elem, key, data ) {\n    // If nothing was found internally, try to fetch any\n    // data from the HTML5 data-* attribute\n    if ( data === undefined && elem.nodeType === 1 ) {\n\n        var name = \"data-\" + key.replace( rmultiDash, \"-$1\" ).toLowerCase();\n\n        data = elem.getAttribute( name );\n\n        if ( typeof data === \"string\" ) {\n            try {\n                data = data === \"true\" ? true :\n                    data === \"false\" ? false :\n                    data === \"null\" ? null :\n                    // Only convert to a number if it doesn't change the string\n                    +data + \"\" === data ? +data :\n                    rbrace.test( data ) ? jQuery.parseJSON( data ) :\n                        data;\n            } catch( e ) {}\n\n            // Make sure we set the data so it isn't changed later\n            jQuery.data( elem, key, data );\n\n        } else {\n            data = undefined;\n        }\n    }\n\n    return data;\n}\n\n// checks a cache object for emptiness\nfunction isEmptyDataObject( obj ) {\n    var name;\n    for ( name in obj ) {\n\n        // if the public data object is empty, the private is still empty\n        if ( name === \"data\" && jQuery.isEmptyObject( obj[name] ) ) {\n            continue;\n        }\n        if ( name !== \"toJSON\" ) {\n            return false;\n        }\n    }\n\n    return true;\n}\njQuery.extend({\n    queue: function( elem, type, data ) {\n        var queue;\n\n        if ( elem ) {\n            type = ( type || \"fx\" ) + \"queue\";\n            queue = jQuery._data( elem, type );\n\n            // Speed up dequeue by getting out quickly if this is just a lookup\n            if ( data ) {\n                if ( !queue || jQuery.isArray(data) ) {\n                    queue = jQuery._data( elem, type, jQuery.makeArray(data) );\n                } else {\n                    queue.push( data );\n                }\n            }\n            return queue || [];\n        }\n    },\n\n    dequeue: function( elem, type ) {\n        type = type || \"fx\";\n\n        var queue = jQuery.queue( elem, type ),\n            startLength = queue.length,\n            fn = queue.shift(),\n            hooks = jQuery._queueHooks( elem, type ),\n            next = function() {\n                jQuery.dequeue( elem, type );\n            };\n\n        // If the fx queue is dequeued, always remove the progress sentinel\n        if ( fn === \"inprogress\" ) {\n            fn = queue.shift();\n            startLength--;\n        }\n\n        if ( fn ) {\n\n            // Add a progress sentinel to prevent the fx queue from being\n            // automatically dequeued\n            if ( type === \"fx\" ) {\n                queue.unshift( \"inprogress\" );\n            }\n\n            // clear up the last queue stop function\n            delete hooks.stop;\n            fn.call( elem, next, hooks );\n        }\n\n        if ( !startLength && hooks ) {\n            hooks.empty.fire();\n        }\n    },\n\n    // not intended for public consumption - generates a queueHooks object, or returns the current one\n    _queueHooks: function( elem, type ) {\n        var key = type + \"queueHooks\";\n        return jQuery._data( elem, key ) || jQuery._data( elem, key, {\n            empty: jQuery.Callbacks(\"once memory\").add(function() {\n                jQuery._removeData( elem, type + \"queue\" );\n                jQuery._removeData( elem, key );\n            })\n        });\n    }\n});\n\njQuery.fn.extend({\n    queue: function( type, data ) {\n        var setter = 2;\n\n        if ( typeof type !== \"string\" ) {\n            data = type;\n            type = \"fx\";\n            setter--;\n        }\n\n        if ( arguments.length < setter ) {\n            return jQuery.queue( this[0], type );\n        }\n\n        return data === undefined ?\n            this :\n            this.each(function() {\n                var queue = jQuery.queue( this, type, data );\n\n                // ensure a hooks for this queue\n                jQuery._queueHooks( this, type );\n\n                if ( type === \"fx\" && queue[0] !== \"inprogress\" ) {\n                    jQuery.dequeue( this, type );\n                }\n            });\n    },\n    dequeue: function( type ) {\n        return this.each(function() {\n            jQuery.dequeue( this, type );\n        });\n    },\n    // Based off of the plugin by Clint Helfers, with permission.\n    // http://blindsignals.com/index.php/2009/07/jquery-delay/\n    delay: function( time, type ) {\n        time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;\n        type = type || \"fx\";\n\n        return this.queue( type, function( next, hooks ) {\n            var timeout = setTimeout( next, time );\n            hooks.stop = function() {\n                clearTimeout( timeout );\n            };\n        });\n    },\n    clearQueue: function( type ) {\n        return this.queue( type || \"fx\", [] );\n    },\n    // Get a promise resolved when queues of a certain type\n    // are emptied (fx is the type by default)\n    promise: function( type, obj ) {\n        var tmp,\n            count = 1,\n            defer = jQuery.Deferred(),\n            elements = this,\n            i = this.length,\n            resolve = function() {\n                if ( !( --count ) ) {\n                    defer.resolveWith( elements, [ elements ] );\n                }\n            };\n\n        if ( typeof type !== \"string\" ) {\n            obj = type;\n            type = undefined;\n        }\n        type = type || \"fx\";\n\n        while( i-- ) {\n            tmp = jQuery._data( elements[ i ], type + \"queueHooks\" );\n            if ( tmp && tmp.empty ) {\n                count++;\n                tmp.empty.add( resolve );\n            }\n        }\n        resolve();\n        return defer.promise( obj );\n    }\n});\nvar nodeHook, boolHook,\n    rclass = /[\\t\\r\\n\\f]/g,\n    rreturn = /\\r/g,\n    rfocusable = /^(?:input|select|textarea|button|object)$/i,\n    rclickable = /^(?:a|area)$/i,\n    ruseDefault = /^(?:checked|selected)$/i,\n    getSetAttribute = jQuery.support.getSetAttribute,\n    getSetInput = jQuery.support.input;\n\njQuery.fn.extend({\n    attr: function( name, value ) {\n        return jQuery.access( this, jQuery.attr, name, value, arguments.length > 1 );\n    },\n\n    removeAttr: function( name ) {\n        return this.each(function() {\n            jQuery.removeAttr( this, name );\n        });\n    },\n\n    prop: function( name, value ) {\n        return jQuery.access( this, jQuery.prop, name, value, arguments.length > 1 );\n    },\n\n    removeProp: function( name ) {\n        name = jQuery.propFix[ name ] || name;\n        return this.each(function() {\n            // try/catch handles cases where IE balks (such as removing a property on window)\n            try {\n                this[ name ] = undefined;\n                delete this[ name ];\n            } catch( e ) {}\n        });\n    },\n\n    addClass: function( value ) {\n        var classes, elem, cur, clazz, j,\n            i = 0,\n            len = this.length,\n            proceed = typeof value === \"string\" && value;\n\n        if ( jQuery.isFunction( value ) ) {\n            return this.each(function( j ) {\n                jQuery( this ).addClass( value.call( this, j, this.className ) );\n            });\n        }\n\n        if ( proceed ) {\n            // The disjunction here is for better compressibility (see removeClass)\n            classes = ( value || \"\" ).match( core_rnotwhite ) || [];\n\n            for ( ; i < len; i++ ) {\n                elem = this[ i ];\n                cur = elem.nodeType === 1 && ( elem.className ?\n                    ( \" \" + elem.className + \" \" ).replace( rclass, \" \" ) :\n                    \" \"\n                );\n\n                if ( cur ) {\n                    j = 0;\n                    while ( (clazz = classes[j++]) ) {\n                        if ( cur.indexOf( \" \" + clazz + \" \" ) < 0 ) {\n                            cur += clazz + \" \";\n                        }\n                    }\n                    elem.className = jQuery.trim( cur );\n\n                }\n            }\n        }\n\n        return this;\n    },\n\n    removeClass: function( value ) {\n        var classes, elem, cur, clazz, j,\n            i = 0,\n            len = this.length,\n            proceed = arguments.length === 0 || typeof value === \"string\" && value;\n\n        if ( jQuery.isFunction( value ) ) {\n            return this.each(function( j ) {\n                jQuery( this ).removeClass( value.call( this, j, this.className ) );\n            });\n        }\n        if ( proceed ) {\n            classes = ( value || \"\" ).match( core_rnotwhite ) || [];\n\n            for ( ; i < len; i++ ) {\n                elem = this[ i ];\n                // This expression is here for better compressibility (see addClass)\n                cur = elem.nodeType === 1 && ( elem.className ?\n                    ( \" \" + elem.className + \" \" ).replace( rclass, \" \" ) :\n                    \"\"\n                );\n\n                if ( cur ) {\n                    j = 0;\n                    while ( (clazz = classes[j++]) ) {\n                        // Remove *all* instances\n                        while ( cur.indexOf( \" \" + clazz + \" \" ) >= 0 ) {\n                            cur = cur.replace( \" \" + clazz + \" \", \" \" );\n                        }\n                    }\n                    elem.className = value ? jQuery.trim( cur ) : \"\";\n                }\n            }\n        }\n\n        return this;\n    },\n\n    toggleClass: function( value, stateVal ) {\n        var type = typeof value;\n\n        if ( typeof stateVal === \"boolean\" && type === \"string\" ) {\n            return stateVal ? this.addClass( value ) : this.removeClass( value );\n        }\n\n        if ( jQuery.isFunction( value ) ) {\n            return this.each(function( i ) {\n                jQuery( this ).toggleClass( value.call(this, i, this.className, stateVal), stateVal );\n            });\n        }\n\n        return this.each(function() {\n            if ( type === \"string\" ) {\n                // toggle individual class names\n                var className,\n                    i = 0,\n                    self = jQuery( this ),\n                    classNames = value.match( core_rnotwhite ) || [];\n\n                while ( (className = classNames[ i++ ]) ) {\n                    // check each className given, space separated list\n                    if ( self.hasClass( className ) ) {\n                        self.removeClass( className );\n                    } else {\n                        self.addClass( className );\n                    }\n                }\n\n            // Toggle whole class name\n            } else if ( type === core_strundefined || type === \"boolean\" ) {\n                if ( this.className ) {\n                    // store className if set\n                    jQuery._data( this, \"__className__\", this.className );\n                }\n\n                // If the element has a class name or if we're passed \"false\",\n                // then remove the whole classname (if there was one, the above saved it).\n                // Otherwise bring back whatever was previously saved (if anything),\n                // falling back to the empty string if nothing was stored.\n                this.className = this.className || value === false ? \"\" : jQuery._data( this, \"__className__\" ) || \"\";\n            }\n        });\n    },\n\n    hasClass: function( selector ) {\n        var className = \" \" + selector + \" \",\n            i = 0,\n            l = this.length;\n        for ( ; i < l; i++ ) {\n            if ( this[i].nodeType === 1 && (\" \" + this[i].className + \" \").replace(rclass, \" \").indexOf( className ) >= 0 ) {\n                return true;\n            }\n        }\n\n        return false;\n    },\n\n    val: function( value ) {\n        var ret, hooks, isFunction,\n            elem = this[0];\n\n        if ( !arguments.length ) {\n            if ( elem ) {\n                hooks = jQuery.valHooks[ elem.type ] || jQuery.valHooks[ elem.nodeName.toLowerCase() ];\n\n                if ( hooks && \"get\" in hooks && (ret = hooks.get( elem, \"value\" )) !== undefined ) {\n                    return ret;\n                }\n\n                ret = elem.value;\n\n                return typeof ret === \"string\" ?\n                    // handle most common string cases\n                    ret.replace(rreturn, \"\") :\n                    // handle cases where value is null/undef or number\n                    ret == null ? \"\" : ret;\n            }\n\n            return;\n        }\n\n        isFunction = jQuery.isFunction( value );\n\n        return this.each(function( i ) {\n            var val;\n\n            if ( this.nodeType !== 1 ) {\n                return;\n            }\n\n            if ( isFunction ) {\n                val = value.call( this, i, jQuery( this ).val() );\n            } else {\n                val = value;\n            }\n\n            // Treat null/undefined as \"\"; convert numbers to string\n            if ( val == null ) {\n                val = \"\";\n            } else if ( typeof val === \"number\" ) {\n                val += \"\";\n            } else if ( jQuery.isArray( val ) ) {\n                val = jQuery.map(val, function ( value ) {\n                    return value == null ? \"\" : value + \"\";\n                });\n            }\n\n            hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];\n\n            // If set returns undefined, fall back to normal setting\n            if ( !hooks || !(\"set\" in hooks) || hooks.set( this, val, \"value\" ) === undefined ) {\n                this.value = val;\n            }\n        });\n    }\n});\n\njQuery.extend({\n    valHooks: {\n        option: {\n            get: function( elem ) {\n                // Use proper attribute retrieval(#6932, #12072)\n                var val = jQuery.find.attr( elem, \"value\" );\n                return val != null ?\n                    val :\n                    elem.text;\n            }\n        },\n        select: {\n            get: function( elem ) {\n                var value, option,\n                    options = elem.options,\n                    index = elem.selectedIndex,\n                    one = elem.type === \"select-one\" || index < 0,\n                    values = one ? null : [],\n                    max = one ? index + 1 : options.length,\n                    i = index < 0 ?\n                        max :\n                        one ? index : 0;\n\n                // Loop through all the selected options\n                for ( ; i < max; i++ ) {\n                    option = options[ i ];\n\n                    // oldIE doesn't update selected after form reset (#2551)\n                    if ( ( option.selected || i === index ) &&\n                            // Don't return options that are disabled or in a disabled optgroup\n                            ( jQuery.support.optDisabled ? !option.disabled : option.getAttribute(\"disabled\") === null ) &&\n                            ( !option.parentNode.disabled || !jQuery.nodeName( option.parentNode, \"optgroup\" ) ) ) {\n\n                        // Get the specific value for the option\n                        value = jQuery( option ).val();\n\n                        // We don't need an array for one selects\n                        if ( one ) {\n                            return value;\n                        }\n\n                        // Multi-Selects return an array\n                        values.push( value );\n                    }\n                }\n\n                return values;\n            },\n\n            set: function( elem, value ) {\n                var optionSet, option,\n                    options = elem.options,\n                    values = jQuery.makeArray( value ),\n                    i = options.length;\n\n                while ( i-- ) {\n                    option = options[ i ];\n                    if ( (option.selected = jQuery.inArray( jQuery(option).val(), values ) >= 0) ) {\n                        optionSet = true;\n                    }\n                }\n\n                // force browsers to behave consistently when non-matching value is set\n                if ( !optionSet ) {\n                    elem.selectedIndex = -1;\n                }\n                return values;\n            }\n        }\n    },\n\n    attr: function( elem, name, value ) {\n        var hooks, ret,\n            nType = elem.nodeType;\n\n        // don't get/set attributes on text, comment and attribute nodes\n        if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {\n            return;\n        }\n\n        // Fallback to prop when attributes are not supported\n        if ( typeof elem.getAttribute === core_strundefined ) {\n            return jQuery.prop( elem, name, value );\n        }\n\n        // All attributes are lowercase\n        // Grab necessary hook if one is defined\n        if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {\n            name = name.toLowerCase();\n            hooks = jQuery.attrHooks[ name ] ||\n                ( jQuery.expr.match.bool.test( name ) ? boolHook : nodeHook );\n        }\n\n        if ( value !== undefined ) {\n\n            if ( value === null ) {\n                jQuery.removeAttr( elem, name );\n\n            } else if ( hooks && \"set\" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ) {\n                return ret;\n\n            } else {\n                elem.setAttribute( name, value + \"\" );\n                return value;\n            }\n\n        } else if ( hooks && \"get\" in hooks && (ret = hooks.get( elem, name )) !== null ) {\n            return ret;\n\n        } else {\n            ret = jQuery.find.attr( elem, name );\n\n            // Non-existent attributes return null, we normalize to undefined\n            return ret == null ?\n                undefined :\n                ret;\n        }\n    },\n\n    removeAttr: function( elem, value ) {\n        var name, propName,\n            i = 0,\n            attrNames = value && value.match( core_rnotwhite );\n\n        if ( attrNames && elem.nodeType === 1 ) {\n            while ( (name = attrNames[i++]) ) {\n                propName = jQuery.propFix[ name ] || name;\n\n                // Boolean attributes get special treatment (#10870)\n                if ( jQuery.expr.match.bool.test( name ) ) {\n                    // Set corresponding property to false\n                    if ( getSetInput && getSetAttribute || !ruseDefault.test( name ) ) {\n                        elem[ propName ] = false;\n                    // Support: IE<9\n                    // Also clear defaultChecked/defaultSelected (if appropriate)\n                    } else {\n                        elem[ jQuery.camelCase( \"default-\" + name ) ] =\n                            elem[ propName ] = false;\n                    }\n\n                // See #9699 for explanation of this approach (setting first, then removal)\n                } else {\n                    jQuery.attr( elem, name, \"\" );\n                }\n\n                elem.removeAttribute( getSetAttribute ? name : propName );\n            }\n        }\n    },\n\n    attrHooks: {\n        type: {\n            set: function( elem, value ) {\n                if ( !jQuery.support.radioValue && value === \"radio\" && jQuery.nodeName(elem, \"input\") ) {\n                    // Setting the type on a radio button after the value resets the value in IE6-9\n                    // Reset value to default in case type is set after value during creation\n                    var val = elem.value;\n                    elem.setAttribute( \"type\", value );\n                    if ( val ) {\n                        elem.value = val;\n                    }\n                    return value;\n                }\n            }\n        }\n    },\n\n    propFix: {\n        \"for\": \"htmlFor\",\n        \"class\": \"className\"\n    },\n\n    prop: function( elem, name, value ) {\n        var ret, hooks, notxml,\n            nType = elem.nodeType;\n\n        // don't get/set properties on text, comment and attribute nodes\n        if ( !elem || nType === 3 || nType === 8 || nType === 2 ) {\n            return;\n        }\n\n        notxml = nType !== 1 || !jQuery.isXMLDoc( elem );\n\n        if ( notxml ) {\n            // Fix name and attach hooks\n            name = jQuery.propFix[ name ] || name;\n            hooks = jQuery.propHooks[ name ];\n        }\n\n        if ( value !== undefined ) {\n            return hooks && \"set\" in hooks && (ret = hooks.set( elem, value, name )) !== undefined ?\n                ret :\n                ( elem[ name ] = value );\n\n        } else {\n            return hooks && \"get\" in hooks && (ret = hooks.get( elem, name )) !== null ?\n                ret :\n                elem[ name ];\n        }\n    },\n\n    propHooks: {\n        tabIndex: {\n            get: function( elem ) {\n                // elem.tabIndex doesn't always return the correct value when it hasn't been explicitly set\n                // http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/\n                // Use proper attribute retrieval(#12072)\n                var tabindex = jQuery.find.attr( elem, \"tabindex\" );\n\n                return tabindex ?\n                    parseInt( tabindex, 10 ) :\n                    rfocusable.test( elem.nodeName ) || rclickable.test( elem.nodeName ) && elem.href ?\n                        0 :\n                        -1;\n            }\n        }\n    }\n});\n\n// Hooks for boolean attributes\nboolHook = {\n    set: function( elem, value, name ) {\n        if ( value === false ) {\n            // Remove boolean attributes when set to false\n            jQuery.removeAttr( elem, name );\n        } else if ( getSetInput && getSetAttribute || !ruseDefault.test( name ) ) {\n            // IE<8 needs the *property* name\n            elem.setAttribute( !getSetAttribute && jQuery.propFix[ name ] || name, name );\n\n        // Use defaultChecked and defaultSelected for oldIE\n        } else {\n            elem[ jQuery.camelCase( \"default-\" + name ) ] = elem[ name ] = true;\n        }\n\n        return name;\n    }\n};\njQuery.each( jQuery.expr.match.bool.source.match( /\\w+/g ), function( i, name ) {\n    var getter = jQuery.expr.attrHandle[ name ] || jQuery.find.attr;\n\n    jQuery.expr.attrHandle[ name ] = getSetInput && getSetAttribute || !ruseDefault.test( name ) ?\n        function( elem, name, isXML ) {\n            var fn = jQuery.expr.attrHandle[ name ],\n                ret = isXML ?\n                    undefined :\n                    /* jshint eqeqeq: false */\n                    (jQuery.expr.attrHandle[ name ] = undefined) !=\n                        getter( elem, name, isXML ) ?\n\n                        name.toLowerCase() :\n                        null;\n            jQuery.expr.attrHandle[ name ] = fn;\n            return ret;\n        } :\n        function( elem, name, isXML ) {\n            return isXML ?\n                undefined :\n                elem[ jQuery.camelCase( \"default-\" + name ) ] ?\n                    name.toLowerCase() :\n                    null;\n        };\n});\n\n// fix oldIE attroperties\nif ( !getSetInput || !getSetAttribute ) {\n    jQuery.attrHooks.value = {\n        set: function( elem, value, name ) {\n            if ( jQuery.nodeName( elem, \"input\" ) ) {\n                // Does not return so that setAttribute is also used\n                elem.defaultValue = value;\n            } else {\n                // Use nodeHook if defined (#1954); otherwise setAttribute is fine\n                return nodeHook && nodeHook.set( elem, value, name );\n            }\n        }\n    };\n}\n\n// IE6/7 do not support getting/setting some attributes with get/setAttribute\nif ( !getSetAttribute ) {\n\n    // Use this for any attribute in IE6/7\n    // This fixes almost every IE6/7 issue\n    nodeHook = {\n        set: function( elem, value, name ) {\n            // Set the existing or create a new attribute node\n            var ret = elem.getAttributeNode( name );\n            if ( !ret ) {\n                elem.setAttributeNode(\n                    (ret = elem.ownerDocument.createAttribute( name ))\n                );\n            }\n\n            ret.value = value += \"\";\n\n            // Break association with cloned elements by also using setAttribute (#9646)\n            return name === \"value\" || value === elem.getAttribute( name ) ?\n                value :\n                undefined;\n        }\n    };\n    jQuery.expr.attrHandle.id = jQuery.expr.attrHandle.name = jQuery.expr.attrHandle.coords =\n        // Some attributes are constructed with empty-string values when not defined\n        function( elem, name, isXML ) {\n            var ret;\n            return isXML ?\n                undefined :\n                (ret = elem.getAttributeNode( name )) && ret.value !== \"\" ?\n                    ret.value :\n                    null;\n        };\n    jQuery.valHooks.button = {\n        get: function( elem, name ) {\n            var ret = elem.getAttributeNode( name );\n            return ret && ret.specified ?\n                ret.value :\n                undefined;\n        },\n        set: nodeHook.set\n    };\n\n    // Set contenteditable to false on removals(#10429)\n    // Setting to empty string throws an error as an invalid value\n    jQuery.attrHooks.contenteditable = {\n        set: function( elem, value, name ) {\n            nodeHook.set( elem, value === \"\" ? false : value, name );\n        }\n    };\n\n    // Set width and height to auto instead of 0 on empty string( Bug #8150 )\n    // This is for removals\n    jQuery.each([ \"width\", \"height\" ], function( i, name ) {\n        jQuery.attrHooks[ name ] = {\n            set: function( elem, value ) {\n                if ( value === \"\" ) {\n                    elem.setAttribute( name, \"auto\" );\n                    return value;\n                }\n            }\n        };\n    });\n}\n\n\n// Some attributes require a special call on IE\n// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx\nif ( !jQuery.support.hrefNormalized ) {\n    // href/src property should get the full normalized URL (#10299/#12915)\n    jQuery.each([ \"href\", \"src\" ], function( i, name ) {\n        jQuery.propHooks[ name ] = {\n            get: function( elem ) {\n                return elem.getAttribute( name, 4 );\n            }\n        };\n    });\n}\n\nif ( !jQuery.support.style ) {\n    jQuery.attrHooks.style = {\n        get: function( elem ) {\n            // Return undefined in the case of empty string\n            // Note: IE uppercases css property names, but if we were to .toLowerCase()\n            // .cssText, that would destroy case senstitivity in URL's, like in \"background\"\n            return elem.style.cssText || undefined;\n        },\n        set: function( elem, value ) {\n            return ( elem.style.cssText = value + \"\" );\n        }\n    };\n}\n\n// Safari mis-reports the default selected property of an option\n// Accessing the parent's selectedIndex property fixes it\nif ( !jQuery.support.optSelected ) {\n    jQuery.propHooks.selected = {\n        get: function( elem ) {\n            var parent = elem.parentNode;\n\n            if ( parent ) {\n                parent.selectedIndex;\n\n                // Make sure that it also works with optgroups, see #5701\n                if ( parent.parentNode ) {\n                    parent.parentNode.selectedIndex;\n                }\n            }\n            return null;\n        }\n    };\n}\n\njQuery.each([\n    \"tabIndex\",\n    \"readOnly\",\n    \"maxLength\",\n    \"cellSpacing\",\n    \"cellPadding\",\n    \"rowSpan\",\n    \"colSpan\",\n    \"useMap\",\n    \"frameBorder\",\n    \"contentEditable\"\n], function() {\n    jQuery.propFix[ this.toLowerCase() ] = this;\n});\n\n// IE6/7 call enctype encoding\nif ( !jQuery.support.enctype ) {\n    jQuery.propFix.enctype = \"encoding\";\n}\n\n// Radios and checkboxes getter/setter\njQuery.each([ \"radio\", \"checkbox\" ], function() {\n    jQuery.valHooks[ this ] = {\n        set: function( elem, value ) {\n            if ( jQuery.isArray( value ) ) {\n                return ( elem.checked = jQuery.inArray( jQuery(elem).val(), value ) >= 0 );\n            }\n        }\n    };\n    if ( !jQuery.support.checkOn ) {\n        jQuery.valHooks[ this ].get = function( elem ) {\n            // Support: Webkit\n            // \"\" is returned instead of \"on\" if a value isn't specified\n            return elem.getAttribute(\"value\") === null ? \"on\" : elem.value;\n        };\n    }\n});\nvar rformElems = /^(?:input|select|textarea)$/i,\n    rkeyEvent = /^key/,\n    rmouseEvent = /^(?:mouse|contextmenu)|click/,\n    rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,\n    rtypenamespace = /^([^.]*)(?:\\.(.+)|)$/;\n\nfunction returnTrue() {\n    return true;\n}\n\nfunction returnFalse() {\n    return false;\n}\n\nfunction safeActiveElement() {\n    try {\n        return document.activeElement;\n    } catch ( err ) { }\n}\n\n/*\n * Helper functions for managing events -- not part of the public interface.\n * Props to Dean Edwards' addEvent library for many of the ideas.\n */\njQuery.event = {\n\n    global: {},\n\n    add: function( elem, types, handler, data, selector ) {\n        var tmp, events, t, handleObjIn,\n            special, eventHandle, handleObj,\n            handlers, type, namespaces, origType,\n            elemData = jQuery._data( elem );\n\n        // Don't attach events to noData or text/comment nodes (but allow plain objects)\n        if ( !elemData ) {\n            return;\n        }\n\n        // Caller can pass in an object of custom data in lieu of the handler\n        if ( handler.handler ) {\n            handleObjIn = handler;\n            handler = handleObjIn.handler;\n            selector = handleObjIn.selector;\n        }\n\n        // Make sure that the handler has a unique ID, used to find/remove it later\n        if ( !handler.guid ) {\n            handler.guid = jQuery.guid++;\n        }\n\n        // Init the element's event structure and main handler, if this is the first\n        if ( !(events = elemData.events) ) {\n            events = elemData.events = {};\n        }\n        if ( !(eventHandle = elemData.handle) ) {\n            eventHandle = elemData.handle = function( e ) {\n                // Discard the second event of a jQuery.event.trigger() and\n                // when an event is called after a page has unloaded\n                return typeof jQuery !== core_strundefined && (!e || jQuery.event.triggered !== e.type) ?\n                    jQuery.event.dispatch.apply( eventHandle.elem, arguments ) :\n                    undefined;\n            };\n            // Add elem as a property of the handle fn to prevent a memory leak with IE non-native events\n            eventHandle.elem = elem;\n        }\n\n        // Handle multiple events separated by a space\n        types = ( types || \"\" ).match( core_rnotwhite ) || [\"\"];\n        t = types.length;\n        while ( t-- ) {\n            tmp = rtypenamespace.exec( types[t] ) || [];\n            type = origType = tmp[1];\n            namespaces = ( tmp[2] || \"\" ).split( \".\" ).sort();\n\n            // There *must* be a type, no attaching namespace-only handlers\n            if ( !type ) {\n                continue;\n            }\n\n            // If event changes its type, use the special event handlers for the changed type\n            special = jQuery.event.special[ type ] || {};\n\n            // If selector defined, determine special event api type, otherwise given type\n            type = ( selector ? special.delegateType : special.bindType ) || type;\n\n            // Update special based on newly reset type\n            special = jQuery.event.special[ type ] || {};\n\n            // handleObj is passed to all event handlers\n            handleObj = jQuery.extend({\n                type: type,\n                origType: origType,\n                data: data,\n                handler: handler,\n                guid: handler.guid,\n                selector: selector,\n                needsContext: selector && jQuery.expr.match.needsContext.test( selector ),\n                namespace: namespaces.join(\".\")\n            }, handleObjIn );\n\n            // Init the event handler queue if we're the first\n            if ( !(handlers = events[ type ]) ) {\n                handlers = events[ type ] = [];\n                handlers.delegateCount = 0;\n\n                // Only use addEventListener/attachEvent if the special events handler returns false\n                if ( !special.setup || special.setup.call( elem, data, namespaces, eventHandle ) === false ) {\n                    // Bind the global event handler to the element\n                    if ( elem.addEventListener ) {\n                        elem.addEventListener( type, eventHandle, false );\n\n                    } else if ( elem.attachEvent ) {\n                        elem.attachEvent( \"on\" + type, eventHandle );\n                    }\n                }\n            }\n\n            if ( special.add ) {\n                special.add.call( elem, handleObj );\n\n                if ( !handleObj.handler.guid ) {\n                    handleObj.handler.guid = handler.guid;\n                }\n            }\n\n            // Add to the element's handler list, delegates in front\n            if ( selector ) {\n                handlers.splice( handlers.delegateCount++, 0, handleObj );\n            } else {\n                handlers.push( handleObj );\n            }\n\n            // Keep track of which events have ever been used, for event optimization\n            jQuery.event.global[ type ] = true;\n        }\n\n        // Nullify elem to prevent memory leaks in IE\n        elem = null;\n    },\n\n    // Detach an event or set of events from an element\n    remove: function( elem, types, handler, selector, mappedTypes ) {\n        var j, handleObj, tmp,\n            origCount, t, events,\n            special, handlers, type,\n            namespaces, origType,\n            elemData = jQuery.hasData( elem ) && jQuery._data( elem );\n\n        if ( !elemData || !(events = elemData.events) ) {\n            return;\n        }\n\n        // Once for each type.namespace in types; type may be omitted\n        types = ( types || \"\" ).match( core_rnotwhite ) || [\"\"];\n        t = types.length;\n        while ( t-- ) {\n            tmp = rtypenamespace.exec( types[t] ) || [];\n            type = origType = tmp[1];\n            namespaces = ( tmp[2] || \"\" ).split( \".\" ).sort();\n\n            // Unbind all events (on this namespace, if provided) for the element\n            if ( !type ) {\n                for ( type in events ) {\n                    jQuery.event.remove( elem, type + types[ t ], handler, selector, true );\n                }\n                continue;\n            }\n\n            special = jQuery.event.special[ type ] || {};\n            type = ( selector ? special.delegateType : special.bindType ) || type;\n            handlers = events[ type ] || [];\n            tmp = tmp[2] && new RegExp( \"(^|\\\\.)\" + namespaces.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\" );\n\n            // Remove matching events\n            origCount = j = handlers.length;\n            while ( j-- ) {\n                handleObj = handlers[ j ];\n\n                if ( ( mappedTypes || origType === handleObj.origType ) &&\n                    ( !handler || handler.guid === handleObj.guid ) &&\n                    ( !tmp || tmp.test( handleObj.namespace ) ) &&\n                    ( !selector || selector === handleObj.selector || selector === \"**\" && handleObj.selector ) ) {\n                    handlers.splice( j, 1 );\n\n                    if ( handleObj.selector ) {\n                        handlers.delegateCount--;\n                    }\n                    if ( special.remove ) {\n                        special.remove.call( elem, handleObj );\n                    }\n                }\n            }\n\n            // Remove generic event handler if we removed something and no more handlers exist\n            // (avoids potential for endless recursion during removal of special event handlers)\n            if ( origCount && !handlers.length ) {\n                if ( !special.teardown || special.teardown.call( elem, namespaces, elemData.handle ) === false ) {\n                    jQuery.removeEvent( elem, type, elemData.handle );\n                }\n\n                delete events[ type ];\n            }\n        }\n\n        // Remove the expando if it's no longer used\n        if ( jQuery.isEmptyObject( events ) ) {\n            delete elemData.handle;\n\n            // removeData also checks for emptiness and clears the expando if empty\n            // so use it instead of delete\n            jQuery._removeData( elem, \"events\" );\n        }\n    },\n\n    trigger: function( event, data, elem, onlyHandlers ) {\n        var handle, ontype, cur,\n            bubbleType, special, tmp, i,\n            eventPath = [ elem || document ],\n            type = core_hasOwn.call( event, \"type\" ) ? event.type : event,\n            namespaces = core_hasOwn.call( event, \"namespace\" ) ? event.namespace.split(\".\") : [];\n\n        cur = tmp = elem = elem || document;\n\n        // Don't do events on text and comment nodes\n        if ( elem.nodeType === 3 || elem.nodeType === 8 ) {\n            return;\n        }\n\n        // focus/blur morphs to focusin/out; ensure we're not firing them right now\n        if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {\n            return;\n        }\n\n        if ( type.indexOf(\".\") >= 0 ) {\n            // Namespaced trigger; create a regexp to match event type in handle()\n            namespaces = type.split(\".\");\n            type = namespaces.shift();\n            namespaces.sort();\n        }\n        ontype = type.indexOf(\":\") < 0 && \"on\" + type;\n\n        // Caller can pass in a jQuery.Event object, Object, or just an event type string\n        event = event[ jQuery.expando ] ?\n            event :\n            new jQuery.Event( type, typeof event === \"object\" && event );\n\n        // Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)\n        event.isTrigger = onlyHandlers ? 2 : 3;\n        event.namespace = namespaces.join(\".\");\n        event.namespace_re = event.namespace ?\n            new RegExp( \"(^|\\\\.)\" + namespaces.join(\"\\\\.(?:.*\\\\.|)\") + \"(\\\\.|$)\" ) :\n            null;\n\n        // Clean up the event in case it is being reused\n        event.result = undefined;\n        if ( !event.target ) {\n            event.target = elem;\n        }\n\n        // Clone any incoming data and prepend the event, creating the handler arg list\n        data = data == null ?\n            [ event ] :\n            jQuery.makeArray( data, [ event ] );\n\n        // Allow special events to draw outside the lines\n        special = jQuery.event.special[ type ] || {};\n        if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {\n            return;\n        }\n\n        // Determine event propagation path in advance, per W3C events spec (#9951)\n        // Bubble up to document, then to window; watch for a global ownerDocument var (#9724)\n        if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {\n\n            bubbleType = special.delegateType || type;\n            if ( !rfocusMorph.test( bubbleType + type ) ) {\n                cur = cur.parentNode;\n            }\n            for ( ; cur; cur = cur.parentNode ) {\n                eventPath.push( cur );\n                tmp = cur;\n            }\n\n            // Only add window if we got to document (e.g., not plain obj or detached DOM)\n            if ( tmp === (elem.ownerDocument || document) ) {\n                eventPath.push( tmp.defaultView || tmp.parentWindow || window );\n            }\n        }\n\n        // Fire handlers on the event path\n        i = 0;\n        while ( (cur = eventPath[i++]) && !event.isPropagationStopped() ) {\n\n            event.type = i > 1 ?\n                bubbleType :\n                special.bindType || type;\n\n            // jQuery handler\n            handle = ( jQuery._data( cur, \"events\" ) || {} )[ event.type ] && jQuery._data( cur, \"handle\" );\n            if ( handle ) {\n                handle.apply( cur, data );\n            }\n\n            // Native handler\n            handle = ontype && cur[ ontype ];\n            if ( handle && jQuery.acceptData( cur ) && handle.apply && handle.apply( cur, data ) === false ) {\n                event.preventDefault();\n            }\n        }\n        event.type = type;\n\n        // If nobody prevented the default action, do it now\n        if ( !onlyHandlers && !event.isDefaultPrevented() ) {\n\n            if ( (!special._default || special._default.apply( eventPath.pop(), data ) === false) &&\n                jQuery.acceptData( elem ) ) {\n\n                // Call a native DOM method on the target with the same name name as the event.\n                // Can't use an .isFunction() check here because IE6/7 fails that test.\n                // Don't do default actions on window, that's where global variables be (#6170)\n                if ( ontype && elem[ type ] && !jQuery.isWindow( elem ) ) {\n\n                    // Don't re-trigger an onFOO event when we call its FOO() method\n                    tmp = elem[ ontype ];\n\n                    if ( tmp ) {\n                        elem[ ontype ] = null;\n                    }\n\n                    // Prevent re-triggering of the same event, since we already bubbled it above\n                    jQuery.event.triggered = type;\n                    try {\n                        elem[ type ]();\n                    } catch ( e ) {\n                        // IE<9 dies on focus/blur to hidden element (#1486,#12518)\n                        // only reproducible on winXP IE8 native, not IE9 in IE8 mode\n                    }\n                    jQuery.event.triggered = undefined;\n\n                    if ( tmp ) {\n                        elem[ ontype ] = tmp;\n                    }\n                }\n            }\n        }\n\n        return event.result;\n    },\n\n    dispatch: function( event ) {\n\n        // Make a writable jQuery.Event from the native event object\n        event = jQuery.event.fix( event );\n\n        var i, ret, handleObj, matched, j,\n            handlerQueue = [],\n            args = core_slice.call( arguments ),\n            handlers = ( jQuery._data( this, \"events\" ) || {} )[ event.type ] || [],\n            special = jQuery.event.special[ event.type ] || {};\n\n        // Use the fix-ed jQuery.Event rather than the (read-only) native event\n        args[0] = event;\n        event.delegateTarget = this;\n\n        // Call the preDispatch hook for the mapped type, and let it bail if desired\n        if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {\n            return;\n        }\n\n        // Determine handlers\n        handlerQueue = jQuery.event.handlers.call( this, event, handlers );\n\n        // Run delegates first; they may want to stop propagation beneath us\n        i = 0;\n        while ( (matched = handlerQueue[ i++ ]) && !event.isPropagationStopped() ) {\n            event.currentTarget = matched.elem;\n\n            j = 0;\n            while ( (handleObj = matched.handlers[ j++ ]) && !event.isImmediatePropagationStopped() ) {\n\n                // Triggered event must either 1) have no namespace, or\n                // 2) have namespace(s) a subset or equal to those in the bound event (both can have no namespace).\n                if ( !event.namespace_re || event.namespace_re.test( handleObj.namespace ) ) {\n\n                    event.handleObj = handleObj;\n                    event.data = handleObj.data;\n\n                    ret = ( (jQuery.event.special[ handleObj.origType ] || {}).handle || handleObj.handler )\n                            .apply( matched.elem, args );\n\n                    if ( ret !== undefined ) {\n                        if ( (event.result = ret) === false ) {\n                            event.preventDefault();\n                            event.stopPropagation();\n                        }\n                    }\n                }\n            }\n        }\n\n        // Call the postDispatch hook for the mapped type\n        if ( special.postDispatch ) {\n            special.postDispatch.call( this, event );\n        }\n\n        return event.result;\n    },\n\n    handlers: function( event, handlers ) {\n        var sel, handleObj, matches, i,\n            handlerQueue = [],\n            delegateCount = handlers.delegateCount,\n            cur = event.target;\n\n        // Find delegate handlers\n        // Black-hole SVG <use> instance trees (#13180)\n        // Avoid non-left-click bubbling in Firefox (#3861)\n        if ( delegateCount && cur.nodeType && (!event.button || event.type !== \"click\") ) {\n\n            /* jshint eqeqeq: false */\n            for ( ; cur != this; cur = cur.parentNode || this ) {\n                /* jshint eqeqeq: true */\n\n                // Don't check non-elements (#13208)\n                // Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)\n                if ( cur.nodeType === 1 && (cur.disabled !== true || event.type !== \"click\") ) {\n                    matches = [];\n                    for ( i = 0; i < delegateCount; i++ ) {\n                        handleObj = handlers[ i ];\n\n                        // Don't conflict with Object.prototype properties (#13203)\n                        sel = handleObj.selector + \" \";\n\n                        if ( matches[ sel ] === undefined ) {\n                            matches[ sel ] = handleObj.needsContext ?\n                                jQuery( sel, this ).index( cur ) >= 0 :\n                                jQuery.find( sel, this, null, [ cur ] ).length;\n                        }\n                        if ( matches[ sel ] ) {\n                            matches.push( handleObj );\n                        }\n                    }\n                    if ( matches.length ) {\n                        handlerQueue.push({ elem: cur, handlers: matches });\n                    }\n                }\n            }\n        }\n\n        // Add the remaining (directly-bound) handlers\n        if ( delegateCount < handlers.length ) {\n            handlerQueue.push({ elem: this, handlers: handlers.slice( delegateCount ) });\n        }\n\n        return handlerQueue;\n    },\n\n    fix: function( event ) {\n        if ( event[ jQuery.expando ] ) {\n            return event;\n        }\n\n        // Create a writable copy of the event object and normalize some properties\n        var i, prop, copy,\n            type = event.type,\n            originalEvent = event,\n            fixHook = this.fixHooks[ type ];\n\n        if ( !fixHook ) {\n            this.fixHooks[ type ] = fixHook =\n                rmouseEvent.test( type ) ? this.mouseHooks :\n                rkeyEvent.test( type ) ? this.keyHooks :\n                {};\n        }\n        copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;\n\n        event = new jQuery.Event( originalEvent );\n\n        i = copy.length;\n        while ( i-- ) {\n            prop = copy[ i ];\n            event[ prop ] = originalEvent[ prop ];\n        }\n\n        // Support: IE<9\n        // Fix target property (#1925)\n        if ( !event.target ) {\n            event.target = originalEvent.srcElement || document;\n        }\n\n        // Support: Chrome 23+, Safari?\n        // Target should not be a text node (#504, #13143)\n        if ( event.target.nodeType === 3 ) {\n            event.target = event.target.parentNode;\n        }\n\n        // Support: IE<9\n        // For mouse/key events, metaKey==false if it's undefined (#3368, #11328)\n        event.metaKey = !!event.metaKey;\n\n        return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;\n    },\n\n    // Includes some event props shared by KeyEvent and MouseEvent\n    props: \"altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which\".split(\" \"),\n\n    fixHooks: {},\n\n    keyHooks: {\n        props: \"char charCode key keyCode\".split(\" \"),\n        filter: function( event, original ) {\n\n            // Add which for key events\n            if ( event.which == null ) {\n                event.which = original.charCode != null ? original.charCode : original.keyCode;\n            }\n\n            return event;\n        }\n    },\n\n    mouseHooks: {\n        props: \"button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement\".split(\" \"),\n        filter: function( event, original ) {\n            var body, eventDoc, doc,\n                button = original.button,\n                fromElement = original.fromElement;\n\n            // Calculate pageX/Y if missing and clientX/Y available\n            if ( event.pageX == null && original.clientX != null ) {\n                eventDoc = event.target.ownerDocument || document;\n                doc = eventDoc.documentElement;\n                body = eventDoc.body;\n\n                event.pageX = original.clientX + ( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) - ( doc && doc.clientLeft || body && body.clientLeft || 0 );\n                event.pageY = original.clientY + ( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) - ( doc && doc.clientTop  || body && body.clientTop  || 0 );\n            }\n\n            // Add relatedTarget, if necessary\n            if ( !event.relatedTarget && fromElement ) {\n                event.relatedTarget = fromElement === event.target ? original.toElement : fromElement;\n            }\n\n            // Add which for click: 1 === left; 2 === middle; 3 === right\n            // Note: button is not normalized, so don't use it\n            if ( !event.which && button !== undefined ) {\n                event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );\n            }\n\n            return event;\n        }\n    },\n\n    special: {\n        load: {\n            // Prevent triggered image.load events from bubbling to window.load\n            noBubble: true\n        },\n        focus: {\n            // Fire native event if possible so blur/focus sequence is correct\n            trigger: function() {\n                if ( this !== safeActiveElement() && this.focus ) {\n                    try {\n                        this.focus();\n                        return false;\n                    } catch ( e ) {\n                        // Support: IE<9\n                        // If we error on focus to hidden element (#1486, #12518),\n                        // let .trigger() run the handlers\n                    }\n                }\n            },\n            delegateType: \"focusin\"\n        },\n        blur: {\n            trigger: function() {\n                if ( this === safeActiveElement() && this.blur ) {\n                    this.blur();\n                    return false;\n                }\n            },\n            delegateType: \"focusout\"\n        },\n        click: {\n            // For checkbox, fire native event so checked state will be right\n            trigger: function() {\n                if ( jQuery.nodeName( this, \"input\" ) && this.type === \"checkbox\" && this.click ) {\n                    this.click();\n                    return false;\n                }\n            },\n\n            // For cross-browser consistency, don't fire native .click() on links\n            _default: function( event ) {\n                return jQuery.nodeName( event.target, \"a\" );\n            }\n        },\n\n        beforeunload: {\n            postDispatch: function( event ) {\n\n                // Even when returnValue equals to undefined Firefox will still show alert\n                if ( event.result !== undefined ) {\n                    event.originalEvent.returnValue = event.result;\n                }\n            }\n        }\n    },\n\n    simulate: function( type, elem, event, bubble ) {\n        // Piggyback on a donor event to simulate a different one.\n        // Fake originalEvent to avoid donor's stopPropagation, but if the\n        // simulated event prevents default then we do the same on the donor.\n        var e = jQuery.extend(\n            new jQuery.Event(),\n            event,\n            {\n                type: type,\n                isSimulated: true,\n                originalEvent: {}\n            }\n        );\n        if ( bubble ) {\n            jQuery.event.trigger( e, null, elem );\n        } else {\n            jQuery.event.dispatch.call( elem, e );\n        }\n        if ( e.isDefaultPrevented() ) {\n            event.preventDefault();\n        }\n    }\n};\n\njQuery.removeEvent = document.removeEventListener ?\n    function( elem, type, handle ) {\n        if ( elem.removeEventListener ) {\n            elem.removeEventListener( type, handle, false );\n        }\n    } :\n    function( elem, type, handle ) {\n        var name = \"on\" + type;\n\n        if ( elem.detachEvent ) {\n\n            // #8545, #7054, preventing memory leaks for custom events in IE6-8\n            // detachEvent needed property on element, by name of that event, to properly expose it to GC\n            if ( typeof elem[ name ] === core_strundefined ) {\n                elem[ name ] = null;\n            }\n\n            elem.detachEvent( name, handle );\n        }\n    };\n\njQuery.Event = function( src, props ) {\n    // Allow instantiation without the 'new' keyword\n    if ( !(this instanceof jQuery.Event) ) {\n        return new jQuery.Event( src, props );\n    }\n\n    // Event object\n    if ( src && src.type ) {\n        this.originalEvent = src;\n        this.type = src.type;\n\n        // Events bubbling up the document may have been marked as prevented\n        // by a handler lower down the tree; reflect the correct value.\n        this.isDefaultPrevented = ( src.defaultPrevented || src.returnValue === false ||\n            src.getPreventDefault && src.getPreventDefault() ) ? returnTrue : returnFalse;\n\n    // Event type\n    } else {\n        this.type = src;\n    }\n\n    // Put explicitly provided properties onto the event object\n    if ( props ) {\n        jQuery.extend( this, props );\n    }\n\n    // Create a timestamp if incoming event doesn't have one\n    this.timeStamp = src && src.timeStamp || jQuery.now();\n\n    // Mark it as fixed\n    this[ jQuery.expando ] = true;\n};\n\n// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding\n// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html\njQuery.Event.prototype = {\n    isDefaultPrevented: returnFalse,\n    isPropagationStopped: returnFalse,\n    isImmediatePropagationStopped: returnFalse,\n\n    preventDefault: function() {\n        var e = this.originalEvent;\n\n        this.isDefaultPrevented = returnTrue;\n        if ( !e ) {\n            return;\n        }\n\n        // If preventDefault exists, run it on the original event\n        if ( e.preventDefault ) {\n            e.preventDefault();\n\n        // Support: IE\n        // Otherwise set the returnValue property of the original event to false\n        } else {\n            e.returnValue = false;\n        }\n    },\n    stopPropagation: function() {\n        var e = this.originalEvent;\n\n        this.isPropagationStopped = returnTrue;\n        if ( !e ) {\n            return;\n        }\n        // If stopPropagation exists, run it on the original event\n        if ( e.stopPropagation ) {\n            e.stopPropagation();\n        }\n\n        // Support: IE\n        // Set the cancelBubble property of the original event to true\n        e.cancelBubble = true;\n    },\n    stopImmediatePropagation: function() {\n        this.isImmediatePropagationStopped = returnTrue;\n        this.stopPropagation();\n    }\n};\n\n// Create mouseenter/leave events using mouseover/out and event-time checks\njQuery.each({\n    mouseenter: \"mouseover\",\n    mouseleave: \"mouseout\"\n}, function( orig, fix ) {\n    jQuery.event.special[ orig ] = {\n        delegateType: fix,\n        bindType: fix,\n\n        handle: function( event ) {\n            var ret,\n                target = this,\n                related = event.relatedTarget,\n                handleObj = event.handleObj;\n\n            // For mousenter/leave call the handler if related is outside the target.\n            // NB: No relatedTarget if the mouse left/entered the browser window\n            if ( !related || (related !== target && !jQuery.contains( target, related )) ) {\n                event.type = handleObj.origType;\n                ret = handleObj.handler.apply( this, arguments );\n                event.type = fix;\n            }\n            return ret;\n        }\n    };\n});\n\n// IE submit delegation\nif ( !jQuery.support.submitBubbles ) {\n\n    jQuery.event.special.submit = {\n        setup: function() {\n            // Only need this for delegated form submit events\n            if ( jQuery.nodeName( this, \"form\" ) ) {\n                return false;\n            }\n\n            // Lazy-add a submit handler when a descendant form may potentially be submitted\n            jQuery.event.add( this, \"click._submit keypress._submit\", function( e ) {\n                // Node name check avoids a VML-related crash in IE (#9807)\n                var elem = e.target,\n                    form = jQuery.nodeName( elem, \"input\" ) || jQuery.nodeName( elem, \"button\" ) ? elem.form : undefined;\n                if ( form && !jQuery._data( form, \"submitBubbles\" ) ) {\n                    jQuery.event.add( form, \"submit._submit\", function( event ) {\n                        event._submit_bubble = true;\n                    });\n                    jQuery._data( form, \"submitBubbles\", true );\n                }\n            });\n            // return undefined since we don't need an event listener\n        },\n\n        postDispatch: function( event ) {\n            // If form was submitted by the user, bubble the event up the tree\n            if ( event._submit_bubble ) {\n                delete event._submit_bubble;\n                if ( this.parentNode && !event.isTrigger ) {\n                    jQuery.event.simulate( \"submit\", this.parentNode, event, true );\n                }\n            }\n        },\n\n        teardown: function() {\n            // Only need this for delegated form submit events\n            if ( jQuery.nodeName( this, \"form\" ) ) {\n                return false;\n            }\n\n            // Remove delegated handlers; cleanData eventually reaps submit handlers attached above\n            jQuery.event.remove( this, \"._submit\" );\n        }\n    };\n}\n\n// IE change delegation and checkbox/radio fix\nif ( !jQuery.support.changeBubbles ) {\n\n    jQuery.event.special.change = {\n\n        setup: function() {\n\n            if ( rformElems.test( this.nodeName ) ) {\n                // IE doesn't fire change on a check/radio until blur; trigger it on click\n                // after a propertychange. Eat the blur-change in special.change.handle.\n                // This still fires onchange a second time for check/radio after blur.\n                if ( this.type === \"checkbox\" || this.type === \"radio\" ) {\n                    jQuery.event.add( this, \"propertychange._change\", function( event ) {\n                        if ( event.originalEvent.propertyName === \"checked\" ) {\n                            this._just_changed = true;\n                        }\n                    });\n                    jQuery.event.add( this, \"click._change\", function( event ) {\n                        if ( this._just_changed && !event.isTrigger ) {\n                            this._just_changed = false;\n                        }\n                        // Allow triggered, simulated change events (#11500)\n                        jQuery.event.simulate( \"change\", this, event, true );\n                    });\n                }\n                return false;\n            }\n            // Delegated event; lazy-add a change handler on descendant inputs\n            jQuery.event.add( this, \"beforeactivate._change\", function( e ) {\n                var elem = e.target;\n\n                if ( rformElems.test( elem.nodeName ) && !jQuery._data( elem, \"changeBubbles\" ) ) {\n                    jQuery.event.add( elem, \"change._change\", function( event ) {\n                        if ( this.parentNode && !event.isSimulated && !event.isTrigger ) {\n                            jQuery.event.simulate( \"change\", this.parentNode, event, true );\n                        }\n                    });\n                    jQuery._data( elem, \"changeBubbles\", true );\n                }\n            });\n        },\n\n        handle: function( event ) {\n            var elem = event.target;\n\n            // Swallow native change events from checkbox/radio, we already triggered them above\n            if ( this !== elem || event.isSimulated || event.isTrigger || (elem.type !== \"radio\" && elem.type !== \"checkbox\") ) {\n                return event.handleObj.handler.apply( this, arguments );\n            }\n        },\n\n        teardown: function() {\n            jQuery.event.remove( this, \"._change\" );\n\n            return !rformElems.test( this.nodeName );\n        }\n    };\n}\n\n// Create \"bubbling\" focus and blur events\nif ( !jQuery.support.focusinBubbles ) {\n    jQuery.each({ focus: \"focusin\", blur: \"focusout\" }, function( orig, fix ) {\n\n        // Attach a single capturing handler while someone wants focusin/focusout\n        var attaches = 0,\n            handler = function( event ) {\n                jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ), true );\n            };\n\n        jQuery.event.special[ fix ] = {\n            setup: function() {\n                if ( attaches++ === 0 ) {\n                    document.addEventListener( orig, handler, true );\n                }\n            },\n            teardown: function() {\n                if ( --attaches === 0 ) {\n                    document.removeEventListener( orig, handler, true );\n                }\n            }\n        };\n    });\n}\n\njQuery.fn.extend({\n\n    on: function( types, selector, data, fn, /*INTERNAL*/ one ) {\n        var type, origFn;\n\n        // Types can be a map of types/handlers\n        if ( typeof types === \"object\" ) {\n            // ( types-Object, selector, data )\n            if ( typeof selector !== \"string\" ) {\n                // ( types-Object, data )\n                data = data || selector;\n                selector = undefined;\n            }\n            for ( type in types ) {\n                this.on( type, selector, data, types[ type ], one );\n            }\n            return this;\n        }\n\n        if ( data == null && fn == null ) {\n            // ( types, fn )\n            fn = selector;\n            data = selector = undefined;\n        } else if ( fn == null ) {\n            if ( typeof selector === \"string\" ) {\n                // ( types, selector, fn )\n                fn = data;\n                data = undefined;\n            } else {\n                // ( types, data, fn )\n                fn = data;\n                data = selector;\n                selector = undefined;\n            }\n        }\n        if ( fn === false ) {\n            fn = returnFalse;\n        } else if ( !fn ) {\n            return this;\n        }\n\n        if ( one === 1 ) {\n            origFn = fn;\n            fn = function( event ) {\n                // Can use an empty set, since event contains the info\n                jQuery().off( event );\n                return origFn.apply( this, arguments );\n            };\n            // Use same guid so caller can remove using origFn\n            fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );\n        }\n        return this.each( function() {\n            jQuery.event.add( this, types, fn, data, selector );\n        });\n    },\n    one: function( types, selector, data, fn ) {\n        return this.on( types, selector, data, fn, 1 );\n    },\n    off: function( types, selector, fn ) {\n        var handleObj, type;\n        if ( types && types.preventDefault && types.handleObj ) {\n            // ( event )  dispatched jQuery.Event\n            handleObj = types.handleObj;\n            jQuery( types.delegateTarget ).off(\n                handleObj.namespace ? handleObj.origType + \".\" + handleObj.namespace : handleObj.origType,\n                handleObj.selector,\n                handleObj.handler\n            );\n            return this;\n        }\n        if ( typeof types === \"object\" ) {\n            // ( types-object [, selector] )\n            for ( type in types ) {\n                this.off( type, selector, types[ type ] );\n            }\n            return this;\n        }\n        if ( selector === false || typeof selector === \"function\" ) {\n            // ( types [, fn] )\n            fn = selector;\n            selector = undefined;\n        }\n        if ( fn === false ) {\n            fn = returnFalse;\n        }\n        return this.each(function() {\n            jQuery.event.remove( this, types, fn, selector );\n        });\n    },\n\n    trigger: function( type, data ) {\n        return this.each(function() {\n            jQuery.event.trigger( type, data, this );\n        });\n    },\n    triggerHandler: function( type, data ) {\n        var elem = this[0];\n        if ( elem ) {\n            return jQuery.event.trigger( type, data, elem, true );\n        }\n    }\n});\nvar isSimple = /^.[^:#\\[\\.,]*$/,\n    rparentsprev = /^(?:parents|prev(?:Until|All))/,\n    rneedsContext = jQuery.expr.match.needsContext,\n    // methods guaranteed to produce a unique set when starting from a unique set\n    guaranteedUnique = {\n        children: true,\n        contents: true,\n        next: true,\n        prev: true\n    };\n\njQuery.fn.extend({\n    find: function( selector ) {\n        var i,\n            ret = [],\n            self = this,\n            len = self.length;\n\n        if ( typeof selector !== \"string\" ) {\n            return this.pushStack( jQuery( selector ).filter(function() {\n                for ( i = 0; i < len; i++ ) {\n                    if ( jQuery.contains( self[ i ], this ) ) {\n                        return true;\n                    }\n                }\n            }) );\n        }\n\n        for ( i = 0; i < len; i++ ) {\n            jQuery.find( selector, self[ i ], ret );\n        }\n\n        // Needed because $( selector, context ) becomes $( context ).find( selector )\n        ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );\n        ret.selector = this.selector ? this.selector + \" \" + selector : selector;\n        return ret;\n    },\n\n    has: function( target ) {\n        var i,\n            targets = jQuery( target, this ),\n            len = targets.length;\n\n        return this.filter(function() {\n            for ( i = 0; i < len; i++ ) {\n                if ( jQuery.contains( this, targets[i] ) ) {\n                    return true;\n                }\n            }\n        });\n    },\n\n    not: function( selector ) {\n        return this.pushStack( winnow(this, selector || [], true) );\n    },\n\n    filter: function( selector ) {\n        return this.pushStack( winnow(this, selector || [], false) );\n    },\n\n    is: function( selector ) {\n        return !!winnow(\n            this,\n\n            // If this is a positional/relative selector, check membership in the returned set\n            // so $(\"p:first\").is(\"p:last\") won't return true for a doc with two \"p\".\n            typeof selector === \"string\" && rneedsContext.test( selector ) ?\n                jQuery( selector ) :\n                selector || [],\n            false\n        ).length;\n    },\n\n    closest: function( selectors, context ) {\n        var cur,\n            i = 0,\n            l = this.length,\n            ret = [],\n            pos = rneedsContext.test( selectors ) || typeof selectors !== \"string\" ?\n                jQuery( selectors, context || this.context ) :\n                0;\n\n        for ( ; i < l; i++ ) {\n            for ( cur = this[i]; cur && cur !== context; cur = cur.parentNode ) {\n                // Always skip document fragments\n                if ( cur.nodeType < 11 && (pos ?\n                    pos.index(cur) > -1 :\n\n                    // Don't pass non-elements to Sizzle\n                    cur.nodeType === 1 &&\n                        jQuery.find.matchesSelector(cur, selectors)) ) {\n\n                    cur = ret.push( cur );\n                    break;\n                }\n            }\n        }\n\n        return this.pushStack( ret.length > 1 ? jQuery.unique( ret ) : ret );\n    },\n\n    // Determine the position of an element within\n    // the matched set of elements\n    index: function( elem ) {\n\n        // No argument, return index in parent\n        if ( !elem ) {\n            return ( this[0] && this[0].parentNode ) ? this.first().prevAll().length : -1;\n        }\n\n        // index in selector\n        if ( typeof elem === \"string\" ) {\n            return jQuery.inArray( this[0], jQuery( elem ) );\n        }\n\n        // Locate the position of the desired element\n        return jQuery.inArray(\n            // If it receives a jQuery object, the first element is used\n            elem.jquery ? elem[0] : elem, this );\n    },\n\n    add: function( selector, context ) {\n        var set = typeof selector === \"string\" ?\n                jQuery( selector, context ) :\n                jQuery.makeArray( selector && selector.nodeType ? [ selector ] : selector ),\n            all = jQuery.merge( this.get(), set );\n\n        return this.pushStack( jQuery.unique(all) );\n    },\n\n    addBack: function( selector ) {\n        return this.add( selector == null ?\n            this.prevObject : this.prevObject.filter(selector)\n        );\n    }\n});\n\nfunction sibling( cur, dir ) {\n    do {\n        cur = cur[ dir ];\n    } while ( cur && cur.nodeType !== 1 );\n\n    return cur;\n}\n\njQuery.each({\n    parent: function( elem ) {\n        var parent = elem.parentNode;\n        return parent && parent.nodeType !== 11 ? parent : null;\n    },\n    parents: function( elem ) {\n        return jQuery.dir( elem, \"parentNode\" );\n    },\n    parentsUntil: function( elem, i, until ) {\n        return jQuery.dir( elem, \"parentNode\", until );\n    },\n    next: function( elem ) {\n        return sibling( elem, \"nextSibling\" );\n    },\n    prev: function( elem ) {\n        return sibling( elem, \"previousSibling\" );\n    },\n    nextAll: function( elem ) {\n        return jQuery.dir( elem, \"nextSibling\" );\n    },\n    prevAll: function( elem ) {\n        return jQuery.dir( elem, \"previousSibling\" );\n    },\n    nextUntil: function( elem, i, until ) {\n        return jQuery.dir( elem, \"nextSibling\", until );\n    },\n    prevUntil: function( elem, i, until ) {\n        return jQuery.dir( elem, \"previousSibling\", until );\n    },\n    siblings: function( elem ) {\n        return jQuery.sibling( ( elem.parentNode || {} ).firstChild, elem );\n    },\n    children: function( elem ) {\n        return jQuery.sibling( elem.firstChild );\n    },\n    contents: function( elem ) {\n        return jQuery.nodeName( elem, \"iframe\" ) ?\n            elem.contentDocument || elem.contentWindow.document :\n            jQuery.merge( [], elem.childNodes );\n    }\n}, function( name, fn ) {\n    jQuery.fn[ name ] = function( until, selector ) {\n        var ret = jQuery.map( this, fn, until );\n\n        if ( name.slice( -5 ) !== \"Until\" ) {\n            selector = until;\n        }\n\n        if ( selector && typeof selector === \"string\" ) {\n            ret = jQuery.filter( selector, ret );\n        }\n\n        if ( this.length > 1 ) {\n            // Remove duplicates\n            if ( !guaranteedUnique[ name ] ) {\n                ret = jQuery.unique( ret );\n            }\n\n            // Reverse order for parents* and prev-derivatives\n            if ( rparentsprev.test( name ) ) {\n                ret = ret.reverse();\n            }\n        }\n\n        return this.pushStack( ret );\n    };\n});\n\njQuery.extend({\n    filter: function( expr, elems, not ) {\n        var elem = elems[ 0 ];\n\n        if ( not ) {\n            expr = \":not(\" + expr + \")\";\n        }\n\n        return elems.length === 1 && elem.nodeType === 1 ?\n            jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :\n            jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {\n                return elem.nodeType === 1;\n            }));\n    },\n\n    dir: function( elem, dir, until ) {\n        var matched = [],\n            cur = elem[ dir ];\n\n        while ( cur && cur.nodeType !== 9 && (until === undefined || cur.nodeType !== 1 || !jQuery( cur ).is( until )) ) {\n            if ( cur.nodeType === 1 ) {\n                matched.push( cur );\n            }\n            cur = cur[dir];\n        }\n        return matched;\n    },\n\n    sibling: function( n, elem ) {\n        var r = [];\n\n        for ( ; n; n = n.nextSibling ) {\n            if ( n.nodeType === 1 && n !== elem ) {\n                r.push( n );\n            }\n        }\n\n        return r;\n    }\n});\n\n// Implement the identical functionality for filter and not\nfunction winnow( elements, qualifier, not ) {\n    if ( jQuery.isFunction( qualifier ) ) {\n        return jQuery.grep( elements, function( elem, i ) {\n            /* jshint -W018 */\n            return !!qualifier.call( elem, i, elem ) !== not;\n        });\n\n    }\n\n    if ( qualifier.nodeType ) {\n        return jQuery.grep( elements, function( elem ) {\n            return ( elem === qualifier ) !== not;\n        });\n\n    }\n\n    if ( typeof qualifier === \"string\" ) {\n        if ( isSimple.test( qualifier ) ) {\n            return jQuery.filter( qualifier, elements, not );\n        }\n\n        qualifier = jQuery.filter( qualifier, elements );\n    }\n\n    return jQuery.grep( elements, function( elem ) {\n        return ( jQuery.inArray( elem, qualifier ) >= 0 ) !== not;\n    });\n}\nfunction createSafeFragment( document ) {\n    var list = nodeNames.split( \"|\" ),\n        safeFrag = document.createDocumentFragment();\n\n    if ( safeFrag.createElement ) {\n        while ( list.length ) {\n            safeFrag.createElement(\n                list.pop()\n            );\n        }\n    }\n    return safeFrag;\n}\n\nvar nodeNames = \"abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|\" +\n        \"header|hgroup|mark|meter|nav|output|progress|section|summary|time|video\",\n    rinlinejQuery = / jQuery\\d+=\"(?:null|\\d+)\"/g,\n    rnoshimcache = new RegExp(\"<(?:\" + nodeNames + \")[\\\\s/>]\", \"i\"),\n    rleadingWhitespace = /^\\s+/,\n    rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\\w:]+)[^>]*)\\/>/gi,\n    rtagName = /<([\\w:]+)/,\n    rtbody = /<tbody/i,\n    rhtml = /<|&#?\\w+;/,\n    rnoInnerhtml = /<(?:script|style|link)/i,\n    manipulation_rcheckableType = /^(?:checkbox|radio)$/i,\n    // checked=\"checked\" or checked\n    rchecked = /checked\\s*(?:[^=]|=\\s*.checked.)/i,\n    rscriptType = /^$|\\/(?:java|ecma)script/i,\n    rscriptTypeMasked = /^true\\/(.*)/,\n    rcleanScript = /^\\s*<!(?:\\[CDATA\\[|--)|(?:\\]\\]|--)>\\s*$/g,\n\n    // We have to close these tags to support XHTML (#13200)\n    wrapMap = {\n        option: [ 1, \"<select multiple='multiple'>\", \"</select>\" ],\n        legend: [ 1, \"<fieldset>\", \"</fieldset>\" ],\n        area: [ 1, \"<map>\", \"</map>\" ],\n        param: [ 1, \"<object>\", \"</object>\" ],\n        thead: [ 1, \"<table>\", \"</table>\" ],\n        tr: [ 2, \"<table><tbody>\", \"</tbody></table>\" ],\n        col: [ 2, \"<table><tbody></tbody><colgroup>\", \"</colgroup></table>\" ],\n        td: [ 3, \"<table><tbody><tr>\", \"</tr></tbody></table>\" ],\n\n        // IE6-8 can't serialize link, script, style, or any html5 (NoScope) tags,\n        // unless wrapped in a div with non-breaking characters in front of it.\n        _default: jQuery.support.htmlSerialize ? [ 0, \"\", \"\" ] : [ 1, \"X<div>\", \"</div>\"  ]\n    },\n    safeFragment = createSafeFragment( document ),\n    fragmentDiv = safeFragment.appendChild( document.createElement(\"div\") );\n\nwrapMap.optgroup = wrapMap.option;\nwrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\nwrapMap.th = wrapMap.td;\n\njQuery.fn.extend({\n    text: function( value ) {\n        return jQuery.access( this, function( value ) {\n            return value === undefined ?\n                jQuery.text( this ) :\n                this.empty().append( ( this[0] && this[0].ownerDocument || document ).createTextNode( value ) );\n        }, null, value, arguments.length );\n    },\n\n    append: function() {\n        return this.domManip( arguments, function( elem ) {\n            if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n                var target = manipulationTarget( this, elem );\n                target.appendChild( elem );\n            }\n        });\n    },\n\n    prepend: function() {\n        return this.domManip( arguments, function( elem ) {\n            if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {\n                var target = manipulationTarget( this, elem );\n                target.insertBefore( elem, target.firstChild );\n            }\n        });\n    },\n\n    before: function() {\n        return this.domManip( arguments, function( elem ) {\n            if ( this.parentNode ) {\n                this.parentNode.insertBefore( elem, this );\n            }\n        });\n    },\n\n    after: function() {\n        return this.domManip( arguments, function( elem ) {\n            if ( this.parentNode ) {\n                this.parentNode.insertBefore( elem, this.nextSibling );\n            }\n        });\n    },\n\n    // keepData is for internal use only--do not document\n    remove: function( selector, keepData ) {\n        var elem,\n            elems = selector ? jQuery.filter( selector, this ) : this,\n            i = 0;\n\n        for ( ; (elem = elems[i]) != null; i++ ) {\n\n            if ( !keepData && elem.nodeType === 1 ) {\n                jQuery.cleanData( getAll( elem ) );\n            }\n\n            if ( elem.parentNode ) {\n                if ( keepData && jQuery.contains( elem.ownerDocument, elem ) ) {\n                    setGlobalEval( getAll( elem, \"script\" ) );\n                }\n                elem.parentNode.removeChild( elem );\n            }\n        }\n\n        return this;\n    },\n\n    empty: function() {\n        var elem,\n            i = 0;\n\n        for ( ; (elem = this[i]) != null; i++ ) {\n            // Remove element nodes and prevent memory leaks\n            if ( elem.nodeType === 1 ) {\n                jQuery.cleanData( getAll( elem, false ) );\n            }\n\n            // Remove any remaining nodes\n            while ( elem.firstChild ) {\n                elem.removeChild( elem.firstChild );\n            }\n\n            // If this is a select, ensure that it displays empty (#12336)\n            // Support: IE<9\n            if ( elem.options && jQuery.nodeName( elem, \"select\" ) ) {\n                elem.options.length = 0;\n            }\n        }\n\n        return this;\n    },\n\n    clone: function( dataAndEvents, deepDataAndEvents ) {\n        dataAndEvents = dataAndEvents == null ? false : dataAndEvents;\n        deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;\n\n        return this.map( function () {\n            return jQuery.clone( this, dataAndEvents, deepDataAndEvents );\n        });\n    },\n\n    html: function( value ) {\n        return jQuery.access( this, function( value ) {\n            var elem = this[0] || {},\n                i = 0,\n                l = this.length;\n\n            if ( value === undefined ) {\n                return elem.nodeType === 1 ?\n                    elem.innerHTML.replace( rinlinejQuery, \"\" ) :\n                    undefined;\n            }\n\n            // See if we can take a shortcut and just use innerHTML\n            if ( typeof value === \"string\" && !rnoInnerhtml.test( value ) &&\n                ( jQuery.support.htmlSerialize || !rnoshimcache.test( value )  ) &&\n                ( jQuery.support.leadingWhitespace || !rleadingWhitespace.test( value ) ) &&\n                !wrapMap[ ( rtagName.exec( value ) || [\"\", \"\"] )[1].toLowerCase() ] ) {\n\n                value = value.replace( rxhtmlTag, \"<$1></$2>\" );\n\n                try {\n                    for (; i < l; i++ ) {\n                        // Remove element nodes and prevent memory leaks\n                        elem = this[i] || {};\n                        if ( elem.nodeType === 1 ) {\n                            jQuery.cleanData( getAll( elem, false ) );\n                            elem.innerHTML = value;\n                        }\n                    }\n\n                    elem = 0;\n\n                // If using innerHTML throws an exception, use the fallback method\n                } catch(e) {}\n            }\n\n            if ( elem ) {\n                this.empty().append( value );\n            }\n        }, null, value, arguments.length );\n    },\n\n    replaceWith: function() {\n        var\n            // Snapshot the DOM in case .domManip sweeps something relevant into its fragment\n            args = jQuery.map( this, function( elem ) {\n                return [ elem.nextSibling, elem.parentNode ];\n            }),\n            i = 0;\n\n        // Make the changes, replacing each context element with the new content\n        this.domManip( arguments, function( elem ) {\n            var next = args[ i++ ],\n                parent = args[ i++ ];\n\n            if ( parent ) {\n                // Don't use the snapshot next if it has moved (#13810)\n                if ( next && next.parentNode !== parent ) {\n                    next = this.nextSibling;\n                }\n                jQuery( this ).remove();\n                parent.insertBefore( elem, next );\n            }\n        // Allow new content to include elements from the context set\n        }, true );\n\n        // Force removal if there was no new content (e.g., from empty arguments)\n        return i ? this : this.remove();\n    },\n\n    detach: function( selector ) {\n        return this.remove( selector, true );\n    },\n\n    domManip: function( args, callback, allowIntersection ) {\n\n        // Flatten any nested arrays\n        args = core_concat.apply( [], args );\n\n        var first, node, hasScripts,\n            scripts, doc, fragment,\n            i = 0,\n            l = this.length,\n            set = this,\n            iNoClone = l - 1,\n            value = args[0],\n            isFunction = jQuery.isFunction( value );\n\n        // We can't cloneNode fragments that contain checked, in WebKit\n        if ( isFunction || !( l <= 1 || typeof value !== \"string\" || jQuery.support.checkClone || !rchecked.test( value ) ) ) {\n            return this.each(function( index ) {\n                var self = set.eq( index );\n                if ( isFunction ) {\n                    args[0] = value.call( this, index, self.html() );\n                }\n                self.domManip( args, callback, allowIntersection );\n            });\n        }\n\n        if ( l ) {\n            fragment = jQuery.buildFragment( args, this[ 0 ].ownerDocument, false, !allowIntersection && this );\n            first = fragment.firstChild;\n\n            if ( fragment.childNodes.length === 1 ) {\n                fragment = first;\n            }\n\n            if ( first ) {\n                scripts = jQuery.map( getAll( fragment, \"script\" ), disableScript );\n                hasScripts = scripts.length;\n\n                // Use the original fragment for the last item instead of the first because it can end up\n                // being emptied incorrectly in certain situations (#8070).\n                for ( ; i < l; i++ ) {\n                    node = fragment;\n\n                    if ( i !== iNoClone ) {\n                        node = jQuery.clone( node, true, true );\n\n                        // Keep references to cloned scripts for later restoration\n                        if ( hasScripts ) {\n                            jQuery.merge( scripts, getAll( node, \"script\" ) );\n                        }\n                    }\n\n                    callback.call( this[i], node, i );\n                }\n\n                if ( hasScripts ) {\n                    doc = scripts[ scripts.length - 1 ].ownerDocument;\n\n                    // Reenable scripts\n                    jQuery.map( scripts, restoreScript );\n\n                    // Evaluate executable scripts on first document insertion\n                    for ( i = 0; i < hasScripts; i++ ) {\n                        node = scripts[ i ];\n                        if ( rscriptType.test( node.type || \"\" ) &&\n                            !jQuery._data( node, \"globalEval\" ) && jQuery.contains( doc, node ) ) {\n\n                            if ( node.src ) {\n                                // Hope ajax is available...\n                                jQuery._evalUrl( node.src );\n                            } else {\n                                jQuery.globalEval( ( node.text || node.textContent || node.innerHTML || \"\" ).replace( rcleanScript, \"\" ) );\n                            }\n                        }\n                    }\n                }\n\n                // Fix #11809: Avoid leaking memory\n                fragment = first = null;\n            }\n        }\n\n        return this;\n    }\n});\n\n// Support: IE<8\n// Manipulating tables requires a tbody\nfunction manipulationTarget( elem, content ) {\n    return jQuery.nodeName( elem, \"table\" ) &&\n        jQuery.nodeName( content.nodeType === 1 ? content : content.firstChild, \"tr\" ) ?\n\n        elem.getElementsByTagName(\"tbody\")[0] ||\n            elem.appendChild( elem.ownerDocument.createElement(\"tbody\") ) :\n        elem;\n}\n\n// Replace/restore the type attribute of script elements for safe DOM manipulation\nfunction disableScript( elem ) {\n    elem.type = (jQuery.find.attr( elem, \"type\" ) !== null) + \"/\" + elem.type;\n    return elem;\n}\nfunction restoreScript( elem ) {\n    var match = rscriptTypeMasked.exec( elem.type );\n    if ( match ) {\n        elem.type = match[1];\n    } else {\n        elem.removeAttribute(\"type\");\n    }\n    return elem;\n}\n\n// Mark scripts as having already been evaluated\nfunction setGlobalEval( elems, refElements ) {\n    var elem,\n        i = 0;\n    for ( ; (elem = elems[i]) != null; i++ ) {\n        jQuery._data( elem, \"globalEval\", !refElements || jQuery._data( refElements[i], \"globalEval\" ) );\n    }\n}\n\nfunction cloneCopyEvent( src, dest ) {\n\n    if ( dest.nodeType !== 1 || !jQuery.hasData( src ) ) {\n        return;\n    }\n\n    var type, i, l,\n        oldData = jQuery._data( src ),\n        curData = jQuery._data( dest, oldData ),\n        events = oldData.events;\n\n    if ( events ) {\n        delete curData.handle;\n        curData.events = {};\n\n        for ( type in events ) {\n            for ( i = 0, l = events[ type ].length; i < l; i++ ) {\n                jQuery.event.add( dest, type, events[ type ][ i ] );\n            }\n        }\n    }\n\n    // make the cloned public data object a copy from the original\n    if ( curData.data ) {\n        curData.data = jQuery.extend( {}, curData.data );\n    }\n}\n\nfunction fixCloneNodeIssues( src, dest ) {\n    var nodeName, e, data;\n\n    // We do not need to do anything for non-Elements\n    if ( dest.nodeType !== 1 ) {\n        return;\n    }\n\n    nodeName = dest.nodeName.toLowerCase();\n\n    // IE6-8 copies events bound via attachEvent when using cloneNode.\n    if ( !jQuery.support.noCloneEvent && dest[ jQuery.expando ] ) {\n        data = jQuery._data( dest );\n\n        for ( e in data.events ) {\n            jQuery.removeEvent( dest, e, data.handle );\n        }\n\n        // Event data gets referenced instead of copied if the expando gets copied too\n        dest.removeAttribute( jQuery.expando );\n    }\n\n    // IE blanks contents when cloning scripts, and tries to evaluate newly-set text\n    if ( nodeName === \"script\" && dest.text !== src.text ) {\n        disableScript( dest ).text = src.text;\n        restoreScript( dest );\n\n    // IE6-10 improperly clones children of object elements using classid.\n    // IE10 throws NoModificationAllowedError if parent is null, #12132.\n    } else if ( nodeName === \"object\" ) {\n        if ( dest.parentNode ) {\n            dest.outerHTML = src.outerHTML;\n        }\n\n        // This path appears unavoidable for IE9. When cloning an object\n        // element in IE9, the outerHTML strategy above is not sufficient.\n        // If the src has innerHTML and the destination does not,\n        // copy the src.innerHTML into the dest.innerHTML. #10324\n        if ( jQuery.support.html5Clone && ( src.innerHTML && !jQuery.trim(dest.innerHTML) ) ) {\n            dest.innerHTML = src.innerHTML;\n        }\n\n    } else if ( nodeName === \"input\" && manipulation_rcheckableType.test( src.type ) ) {\n        // IE6-8 fails to persist the checked state of a cloned checkbox\n        // or radio button. Worse, IE6-7 fail to give the cloned element\n        // a checked appearance if the defaultChecked value isn't also set\n\n        dest.defaultChecked = dest.checked = src.checked;\n\n        // IE6-7 get confused and end up setting the value of a cloned\n        // checkbox/radio button to an empty string instead of \"on\"\n        if ( dest.value !== src.value ) {\n            dest.value = src.value;\n        }\n\n    // IE6-8 fails to return the selected option to the default selected\n    // state when cloning options\n    } else if ( nodeName === \"option\" ) {\n        dest.defaultSelected = dest.selected = src.defaultSelected;\n\n    // IE6-8 fails to set the defaultValue to the correct value when\n    // cloning other types of input fields\n    } else if ( nodeName === \"input\" || nodeName === \"textarea\" ) {\n        dest.defaultValue = src.defaultValue;\n    }\n}\n\njQuery.each({\n    appendTo: \"append\",\n    prependTo: \"prepend\",\n    insertBefore: \"before\",\n    insertAfter: \"after\",\n    replaceAll: \"replaceWith\"\n}, function( name, original ) {\n    jQuery.fn[ name ] = function( selector ) {\n        var elems,\n            i = 0,\n            ret = [],\n            insert = jQuery( selector ),\n            last = insert.length - 1;\n\n        for ( ; i <= last; i++ ) {\n            elems = i === last ? this : this.clone(true);\n            jQuery( insert[i] )[ original ]( elems );\n\n            // Modern browsers can apply jQuery collections as arrays, but oldIE needs a .get()\n            core_push.apply( ret, elems.get() );\n        }\n\n        return this.pushStack( ret );\n    };\n});\n\nfunction getAll( context, tag ) {\n    var elems, elem,\n        i = 0,\n        found = typeof context.getElementsByTagName !== core_strundefined ? context.getElementsByTagName( tag || \"*\" ) :\n            typeof context.querySelectorAll !== core_strundefined ? context.querySelectorAll( tag || \"*\" ) :\n            undefined;\n\n    if ( !found ) {\n        for ( found = [], elems = context.childNodes || context; (elem = elems[i]) != null; i++ ) {\n            if ( !tag || jQuery.nodeName( elem, tag ) ) {\n                found.push( elem );\n            } else {\n                jQuery.merge( found, getAll( elem, tag ) );\n            }\n        }\n    }\n\n    return tag === undefined || tag && jQuery.nodeName( context, tag ) ?\n        jQuery.merge( [ context ], found ) :\n        found;\n}\n\n// Used in buildFragment, fixes the defaultChecked property\nfunction fixDefaultChecked( elem ) {\n    if ( manipulation_rcheckableType.test( elem.type ) ) {\n        elem.defaultChecked = elem.checked;\n    }\n}\n\njQuery.extend({\n    clone: function( elem, dataAndEvents, deepDataAndEvents ) {\n        var destElements, node, clone, i, srcElements,\n            inPage = jQuery.contains( elem.ownerDocument, elem );\n\n        if ( jQuery.support.html5Clone || jQuery.isXMLDoc(elem) || !rnoshimcache.test( \"<\" + elem.nodeName + \">\" ) ) {\n            clone = elem.cloneNode( true );\n\n        // IE<=8 does not properly clone detached, unknown element nodes\n        } else {\n            fragmentDiv.innerHTML = elem.outerHTML;\n            fragmentDiv.removeChild( clone = fragmentDiv.firstChild );\n        }\n\n        if ( (!jQuery.support.noCloneEvent || !jQuery.support.noCloneChecked) &&\n                (elem.nodeType === 1 || elem.nodeType === 11) && !jQuery.isXMLDoc(elem) ) {\n\n            // We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2\n            destElements = getAll( clone );\n            srcElements = getAll( elem );\n\n            // Fix all IE cloning issues\n            for ( i = 0; (node = srcElements[i]) != null; ++i ) {\n                // Ensure that the destination node is not null; Fixes #9587\n                if ( destElements[i] ) {\n                    fixCloneNodeIssues( node, destElements[i] );\n                }\n            }\n        }\n\n        // Copy the events from the original to the clone\n        if ( dataAndEvents ) {\n            if ( deepDataAndEvents ) {\n                srcElements = srcElements || getAll( elem );\n                destElements = destElements || getAll( clone );\n\n                for ( i = 0; (node = srcElements[i]) != null; i++ ) {\n                    cloneCopyEvent( node, destElements[i] );\n                }\n            } else {\n                cloneCopyEvent( elem, clone );\n            }\n        }\n\n        // Preserve script evaluation history\n        destElements = getAll( clone, \"script\" );\n        if ( destElements.length > 0 ) {\n            setGlobalEval( destElements, !inPage && getAll( elem, \"script\" ) );\n        }\n\n        destElements = srcElements = node = null;\n\n        // Return the cloned set\n        return clone;\n    },\n\n    buildFragment: function( elems, context, scripts, selection ) {\n        var j, elem, contains,\n            tmp, tag, tbody, wrap,\n            l = elems.length,\n\n            // Ensure a safe fragment\n            safe = createSafeFragment( context ),\n\n            nodes = [],\n            i = 0;\n\n        for ( ; i < l; i++ ) {\n            elem = elems[ i ];\n\n            if ( elem || elem === 0 ) {\n\n                // Add nodes directly\n                if ( jQuery.type( elem ) === \"object\" ) {\n                    jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );\n\n                // Convert non-html into a text node\n                } else if ( !rhtml.test( elem ) ) {\n                    nodes.push( context.createTextNode( elem ) );\n\n                // Convert html into DOM nodes\n                } else {\n                    tmp = tmp || safe.appendChild( context.createElement(\"div\") );\n\n                    // Deserialize a standard representation\n                    tag = ( rtagName.exec( elem ) || [\"\", \"\"] )[1].toLowerCase();\n                    wrap = wrapMap[ tag ] || wrapMap._default;\n\n                    tmp.innerHTML = wrap[1] + elem.replace( rxhtmlTag, \"<$1></$2>\" ) + wrap[2];\n\n                    // Descend through wrappers to the right content\n                    j = wrap[0];\n                    while ( j-- ) {\n                        tmp = tmp.lastChild;\n                    }\n\n                    // Manually add leading whitespace removed by IE\n                    if ( !jQuery.support.leadingWhitespace && rleadingWhitespace.test( elem ) ) {\n                        nodes.push( context.createTextNode( rleadingWhitespace.exec( elem )[0] ) );\n                    }\n\n                    // Remove IE's autoinserted <tbody> from table fragments\n                    if ( !jQuery.support.tbody ) {\n\n                        // String was a <table>, *may* have spurious <tbody>\n                        elem = tag === \"table\" && !rtbody.test( elem ) ?\n                            tmp.firstChild :\n\n                            // String was a bare <thead> or <tfoot>\n                            wrap[1] === \"<table>\" && !rtbody.test( elem ) ?\n                                tmp :\n                                0;\n\n                        j = elem && elem.childNodes.length;\n                        while ( j-- ) {\n                            if ( jQuery.nodeName( (tbody = elem.childNodes[j]), \"tbody\" ) && !tbody.childNodes.length ) {\n                                elem.removeChild( tbody );\n                            }\n                        }\n                    }\n\n                    jQuery.merge( nodes, tmp.childNodes );\n\n                    // Fix #12392 for WebKit and IE > 9\n                    tmp.textContent = \"\";\n\n                    // Fix #12392 for oldIE\n                    while ( tmp.firstChild ) {\n                        tmp.removeChild( tmp.firstChild );\n                    }\n\n                    // Remember the top-level container for proper cleanup\n                    tmp = safe.lastChild;\n                }\n            }\n        }\n\n        // Fix #11356: Clear elements from fragment\n        if ( tmp ) {\n            safe.removeChild( tmp );\n        }\n\n        // Reset defaultChecked for any radios and checkboxes\n        // about to be appended to the DOM in IE 6/7 (#8060)\n        if ( !jQuery.support.appendChecked ) {\n            jQuery.grep( getAll( nodes, \"input\" ), fixDefaultChecked );\n        }\n\n        i = 0;\n        while ( (elem = nodes[ i++ ]) ) {\n\n            // #4087 - If origin and destination elements are the same, and this is\n            // that element, do not do anything\n            if ( selection && jQuery.inArray( elem, selection ) !== -1 ) {\n                continue;\n            }\n\n            contains = jQuery.contains( elem.ownerDocument, elem );\n\n            // Append to fragment\n            tmp = getAll( safe.appendChild( elem ), \"script\" );\n\n            // Preserve script evaluation history\n            if ( contains ) {\n                setGlobalEval( tmp );\n            }\n\n            // Capture executables\n            if ( scripts ) {\n                j = 0;\n                while ( (elem = tmp[ j++ ]) ) {\n                    if ( rscriptType.test( elem.type || \"\" ) ) {\n                        scripts.push( elem );\n                    }\n                }\n            }\n        }\n\n        tmp = null;\n\n        return safe;\n    },\n\n    cleanData: function( elems, /* internal */ acceptData ) {\n        var elem, type, id, data,\n            i = 0,\n            internalKey = jQuery.expando,\n            cache = jQuery.cache,\n            deleteExpando = jQuery.support.deleteExpando,\n            special = jQuery.event.special;\n\n        for ( ; (elem = elems[i]) != null; i++ ) {\n\n            if ( acceptData || jQuery.acceptData( elem ) ) {\n\n                id = elem[ internalKey ];\n                data = id && cache[ id ];\n\n                if ( data ) {\n                    if ( data.events ) {\n                        for ( type in data.events ) {\n                            if ( special[ type ] ) {\n                                jQuery.event.remove( elem, type );\n\n                            // This is a shortcut to avoid jQuery.event.remove's overhead\n                            } else {\n                                jQuery.removeEvent( elem, type, data.handle );\n                            }\n                        }\n                    }\n\n                    // Remove cache only if it was not already removed by jQuery.event.remove\n                    if ( cache[ id ] ) {\n\n                        delete cache[ id ];\n\n                        // IE does not allow us to delete expando properties from nodes,\n                        // nor does it have a removeAttribute function on Document nodes;\n                        // we must handle all of these cases\n                        if ( deleteExpando ) {\n                            delete elem[ internalKey ];\n\n                        } else if ( typeof elem.removeAttribute !== core_strundefined ) {\n                            elem.removeAttribute( internalKey );\n\n                        } else {\n                            elem[ internalKey ] = null;\n                        }\n\n                        core_deletedIds.push( id );\n                    }\n                }\n            }\n        }\n    },\n\n    _evalUrl: function( url ) {\n        return jQuery.ajax({\n            url: url,\n            type: \"GET\",\n            dataType: \"script\",\n            async: false,\n            global: false,\n            \"throws\": true\n        });\n    }\n});\njQuery.fn.extend({\n    wrapAll: function( html ) {\n        if ( jQuery.isFunction( html ) ) {\n            return this.each(function(i) {\n                jQuery(this).wrapAll( html.call(this, i) );\n            });\n        }\n\n        if ( this[0] ) {\n            // The elements to wrap the target around\n            var wrap = jQuery( html, this[0].ownerDocument ).eq(0).clone(true);\n\n            if ( this[0].parentNode ) {\n                wrap.insertBefore( this[0] );\n            }\n\n            wrap.map(function() {\n                var elem = this;\n\n                while ( elem.firstChild && elem.firstChild.nodeType === 1 ) {\n                    elem = elem.firstChild;\n                }\n\n                return elem;\n            }).append( this );\n        }\n\n        return this;\n    },\n\n    wrapInner: function( html ) {\n        if ( jQuery.isFunction( html ) ) {\n            return this.each(function(i) {\n                jQuery(this).wrapInner( html.call(this, i) );\n            });\n        }\n\n        return this.each(function() {\n            var self = jQuery( this ),\n                contents = self.contents();\n\n            if ( contents.length ) {\n                contents.wrapAll( html );\n\n            } else {\n                self.append( html );\n            }\n        });\n    },\n\n    wrap: function( html ) {\n        var isFunction = jQuery.isFunction( html );\n\n        return this.each(function(i) {\n            jQuery( this ).wrapAll( isFunction ? html.call(this, i) : html );\n        });\n    },\n\n    unwrap: function() {\n        return this.parent().each(function() {\n            if ( !jQuery.nodeName( this, \"body\" ) ) {\n                jQuery( this ).replaceWith( this.childNodes );\n            }\n        }).end();\n    }\n});\nvar iframe, getStyles, curCSS,\n    ralpha = /alpha\\([^)]*\\)/i,\n    ropacity = /opacity\\s*=\\s*([^)]*)/,\n    rposition = /^(top|right|bottom|left)$/,\n    // swappable if display is none or starts with table except \"table\", \"table-cell\", or \"table-caption\"\n    // see here for display values: https://developer.mozilla.org/en-US/docs/CSS/display\n    rdisplayswap = /^(none|table(?!-c[ea]).+)/,\n    rmargin = /^margin/,\n    rnumsplit = new RegExp( \"^(\" + core_pnum + \")(.*)$\", \"i\" ),\n    rnumnonpx = new RegExp( \"^(\" + core_pnum + \")(?!px)[a-z%]+$\", \"i\" ),\n    rrelNum = new RegExp( \"^([+-])=(\" + core_pnum + \")\", \"i\" ),\n    elemdisplay = { BODY: \"block\" },\n\n    cssShow = { position: \"absolute\", visibility: \"hidden\", display: \"block\" },\n    cssNormalTransform = {\n        letterSpacing: 0,\n        fontWeight: 400\n    },\n\n    cssExpand = [ \"Top\", \"Right\", \"Bottom\", \"Left\" ],\n    cssPrefixes = [ \"Webkit\", \"O\", \"Moz\", \"ms\" ];\n\n// return a css property mapped to a potentially vendor prefixed property\nfunction vendorPropName( style, name ) {\n\n    // shortcut for names that are not vendor prefixed\n    if ( name in style ) {\n        return name;\n    }\n\n    // check for vendor prefixed names\n    var capName = name.charAt(0).toUpperCase() + name.slice(1),\n        origName = name,\n        i = cssPrefixes.length;\n\n    while ( i-- ) {\n        name = cssPrefixes[ i ] + capName;\n        if ( name in style ) {\n            return name;\n        }\n    }\n\n    return origName;\n}\n\nfunction isHidden( elem, el ) {\n    // isHidden might be called from jQuery#filter function;\n    // in that case, element will be second argument\n    elem = el || elem;\n    return jQuery.css( elem, \"display\" ) === \"none\" || !jQuery.contains( elem.ownerDocument, elem );\n}\n\nfunction showHide( elements, show ) {\n    var display, elem, hidden,\n        values = [],\n        index = 0,\n        length = elements.length;\n\n    for ( ; index < length; index++ ) {\n        elem = elements[ index ];\n        if ( !elem.style ) {\n            continue;\n        }\n\n        values[ index ] = jQuery._data( elem, \"olddisplay\" );\n        display = elem.style.display;\n        if ( show ) {\n            // Reset the inline display of this element to learn if it is\n            // being hidden by cascaded rules or not\n            if ( !values[ index ] && display === \"none\" ) {\n                elem.style.display = \"\";\n            }\n\n            // Set elements which have been overridden with display: none\n            // in a stylesheet to whatever the default browser style is\n            // for such an element\n            if ( elem.style.display === \"\" && isHidden( elem ) ) {\n                values[ index ] = jQuery._data( elem, \"olddisplay\", css_defaultDisplay(elem.nodeName) );\n            }\n        } else {\n\n            if ( !values[ index ] ) {\n                hidden = isHidden( elem );\n\n                if ( display && display !== \"none\" || !hidden ) {\n                    jQuery._data( elem, \"olddisplay\", hidden ? display : jQuery.css( elem, \"display\" ) );\n                }\n            }\n        }\n    }\n\n    // Set the display of most of the elements in a second loop\n    // to avoid the constant reflow\n    for ( index = 0; index < length; index++ ) {\n        elem = elements[ index ];\n        if ( !elem.style ) {\n            continue;\n        }\n        if ( !show || elem.style.display === \"none\" || elem.style.display === \"\" ) {\n            elem.style.display = show ? values[ index ] || \"\" : \"none\";\n        }\n    }\n\n    return elements;\n}\n\njQuery.fn.extend({\n    css: function( name, value ) {\n        return jQuery.access( this, function( elem, name, value ) {\n            var len, styles,\n                map = {},\n                i = 0;\n\n            if ( jQuery.isArray( name ) ) {\n                styles = getStyles( elem );\n                len = name.length;\n\n                for ( ; i < len; i++ ) {\n                    map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );\n                }\n\n                return map;\n            }\n\n            return value !== undefined ?\n                jQuery.style( elem, name, value ) :\n                jQuery.css( elem, name );\n        }, name, value, arguments.length > 1 );\n    },\n    show: function() {\n        return showHide( this, true );\n    },\n    hide: function() {\n        return showHide( this );\n    },\n    toggle: function( state ) {\n        if ( typeof state === \"boolean\" ) {\n            return state ? this.show() : this.hide();\n        }\n\n        return this.each(function() {\n            if ( isHidden( this ) ) {\n                jQuery( this ).show();\n            } else {\n                jQuery( this ).hide();\n            }\n        });\n    }\n});\n\njQuery.extend({\n    // Add in style property hooks for overriding the default\n    // behavior of getting and setting a style property\n    cssHooks: {\n        opacity: {\n            get: function( elem, computed ) {\n                if ( computed ) {\n                    // We should always get a number back from opacity\n                    var ret = curCSS( elem, \"opacity\" );\n                    return ret === \"\" ? \"1\" : ret;\n                }\n            }\n        }\n    },\n\n    // Don't automatically add \"px\" to these possibly-unitless properties\n    cssNumber: {\n        \"columnCount\": true,\n        \"fillOpacity\": true,\n        \"fontWeight\": true,\n        \"lineHeight\": true,\n        \"opacity\": true,\n        \"order\": true,\n        \"orphans\": true,\n        \"widows\": true,\n        \"zIndex\": true,\n        \"zoom\": true\n    },\n\n    // Add in properties whose names you wish to fix before\n    // setting or getting the value\n    cssProps: {\n        // normalize float css property\n        \"float\": jQuery.support.cssFloat ? \"cssFloat\" : \"styleFloat\"\n    },\n\n    // Get and set the style property on a DOM Node\n    style: function( elem, name, value, extra ) {\n        // Don't set styles on text and comment nodes\n        if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {\n            return;\n        }\n\n        // Make sure that we're working with the right name\n        var ret, type, hooks,\n            origName = jQuery.camelCase( name ),\n            style = elem.style;\n\n        name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( style, origName ) );\n\n        // gets hook for the prefixed version\n        // followed by the unprefixed version\n        hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n        // Check if we're setting a value\n        if ( value !== undefined ) {\n            type = typeof value;\n\n            // convert relative number strings (+= or -=) to relative numbers. #7345\n            if ( type === \"string\" && (ret = rrelNum.exec( value )) ) {\n                value = ( ret[1] + 1 ) * ret[2] + parseFloat( jQuery.css( elem, name ) );\n                // Fixes bug #9237\n                type = \"number\";\n            }\n\n            // Make sure that NaN and null values aren't set. See: #7116\n            if ( value == null || type === \"number\" && isNaN( value ) ) {\n                return;\n            }\n\n            // If a number was passed in, add 'px' to the (except for certain CSS properties)\n            if ( type === \"number\" && !jQuery.cssNumber[ origName ] ) {\n                value += \"px\";\n            }\n\n            // Fixes #8908, it can be done more correctly by specifing setters in cssHooks,\n            // but it would mean to define eight (for every problematic property) identical functions\n            if ( !jQuery.support.clearCloneStyle && value === \"\" && name.indexOf(\"background\") === 0 ) {\n                style[ name ] = \"inherit\";\n            }\n\n            // If a hook was provided, use that value, otherwise just set the specified value\n            if ( !hooks || !(\"set\" in hooks) || (value = hooks.set( elem, value, extra )) !== undefined ) {\n\n                // Wrapped to prevent IE from throwing errors when 'invalid' values are provided\n                // Fixes bug #5509\n                try {\n                    style[ name ] = value;\n                } catch(e) {}\n            }\n\n        } else {\n            // If a hook was provided get the non-computed value from there\n            if ( hooks && \"get\" in hooks && (ret = hooks.get( elem, false, extra )) !== undefined ) {\n                return ret;\n            }\n\n            // Otherwise just get the value from the style object\n            return style[ name ];\n        }\n    },\n\n    css: function( elem, name, extra, styles ) {\n        var num, val, hooks,\n            origName = jQuery.camelCase( name );\n\n        // Make sure that we're working with the right name\n        name = jQuery.cssProps[ origName ] || ( jQuery.cssProps[ origName ] = vendorPropName( elem.style, origName ) );\n\n        // gets hook for the prefixed version\n        // followed by the unprefixed version\n        hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];\n\n        // If a hook was provided get the computed value from there\n        if ( hooks && \"get\" in hooks ) {\n            val = hooks.get( elem, true, extra );\n        }\n\n        // Otherwise, if a way to get the computed value exists, use that\n        if ( val === undefined ) {\n            val = curCSS( elem, name, styles );\n        }\n\n        //convert \"normal\" to computed value\n        if ( val === \"normal\" && name in cssNormalTransform ) {\n            val = cssNormalTransform[ name ];\n        }\n\n        // Return, converting to number if forced or a qualifier was provided and val looks numeric\n        if ( extra === \"\" || extra ) {\n            num = parseFloat( val );\n            return extra === true || jQuery.isNumeric( num ) ? num || 0 : val;\n        }\n        return val;\n    }\n});\n\n// NOTE: we've included the \"window\" in window.getComputedStyle\n// because jsdom on node.js will break without it.\nif ( window.getComputedStyle ) {\n    getStyles = function( elem ) {\n        return window.getComputedStyle( elem, null );\n    };\n\n    curCSS = function( elem, name, _computed ) {\n        var width, minWidth, maxWidth,\n            computed = _computed || getStyles( elem ),\n\n            // getPropertyValue is only needed for .css('filter') in IE9, see #12537\n            ret = computed ? computed.getPropertyValue( name ) || computed[ name ] : undefined,\n            style = elem.style;\n\n        if ( computed ) {\n\n            if ( ret === \"\" && !jQuery.contains( elem.ownerDocument, elem ) ) {\n                ret = jQuery.style( elem, name );\n            }\n\n            // A tribute to the \"awesome hack by Dean Edwards\"\n            // Chrome < 17 and Safari 5.0 uses \"computed value\" instead of \"used value\" for margin-right\n            // Safari 5.1.7 (at least) returns percentage for a larger set of values, but width seems to be reliably pixels\n            // this is against the CSSOM draft spec: http://dev.w3.org/csswg/cssom/#resolved-values\n            if ( rnumnonpx.test( ret ) && rmargin.test( name ) ) {\n\n                // Remember the original values\n                width = style.width;\n                minWidth = style.minWidth;\n                maxWidth = style.maxWidth;\n\n                // Put in the new values to get a computed value out\n                style.minWidth = style.maxWidth = style.width = ret;\n                ret = computed.width;\n\n                // Revert the changed values\n                style.width = width;\n                style.minWidth = minWidth;\n                style.maxWidth = maxWidth;\n            }\n        }\n\n        return ret;\n    };\n} else if ( document.documentElement.currentStyle ) {\n    getStyles = function( elem ) {\n        return elem.currentStyle;\n    };\n\n    curCSS = function( elem, name, _computed ) {\n        var left, rs, rsLeft,\n            computed = _computed || getStyles( elem ),\n            ret = computed ? computed[ name ] : undefined,\n            style = elem.style;\n\n        // Avoid setting ret to empty string here\n        // so we don't default to auto\n        if ( ret == null && style && style[ name ] ) {\n            ret = style[ name ];\n        }\n\n        // From the awesome hack by Dean Edwards\n        // http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291\n\n        // If we're not dealing with a regular pixel number\n        // but a number that has a weird ending, we need to convert it to pixels\n        // but not position css attributes, as those are proportional to the parent element instead\n        // and we can't measure the parent instead because it might trigger a \"stacking dolls\" problem\n        if ( rnumnonpx.test( ret ) && !rposition.test( name ) ) {\n\n            // Remember the original values\n            left = style.left;\n            rs = elem.runtimeStyle;\n            rsLeft = rs && rs.left;\n\n            // Put in the new values to get a computed value out\n            if ( rsLeft ) {\n                rs.left = elem.currentStyle.left;\n            }\n            style.left = name === \"fontSize\" ? \"1em\" : ret;\n            ret = style.pixelLeft + \"px\";\n\n            // Revert the changed values\n            style.left = left;\n            if ( rsLeft ) {\n                rs.left = rsLeft;\n            }\n        }\n\n        return ret === \"\" ? \"auto\" : ret;\n    };\n}\n\nfunction setPositiveNumber( elem, value, subtract ) {\n    var matches = rnumsplit.exec( value );\n    return matches ?\n        // Guard against undefined \"subtract\", e.g., when used as in cssHooks\n        Math.max( 0, matches[ 1 ] - ( subtract || 0 ) ) + ( matches[ 2 ] || \"px\" ) :\n        value;\n}\n\nfunction augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {\n    var i = extra === ( isBorderBox ? \"border\" : \"content\" ) ?\n        // If we already have the right measurement, avoid augmentation\n        4 :\n        // Otherwise initialize for horizontal or vertical properties\n        name === \"width\" ? 1 : 0,\n\n        val = 0;\n\n    for ( ; i < 4; i += 2 ) {\n        // both box models exclude margin, so add it if we want it\n        if ( extra === \"margin\" ) {\n            val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );\n        }\n\n        if ( isBorderBox ) {\n            // border-box includes padding, so remove it if we want content\n            if ( extra === \"content\" ) {\n                val -= jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n            }\n\n            // at this point, extra isn't border nor margin, so remove border\n            if ( extra !== \"margin\" ) {\n                val -= jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n            }\n        } else {\n            // at this point, extra isn't content, so add padding\n            val += jQuery.css( elem, \"padding\" + cssExpand[ i ], true, styles );\n\n            // at this point, extra isn't content nor padding, so add border\n            if ( extra !== \"padding\" ) {\n                val += jQuery.css( elem, \"border\" + cssExpand[ i ] + \"Width\", true, styles );\n            }\n        }\n    }\n\n    return val;\n}\n\nfunction getWidthOrHeight( elem, name, extra ) {\n\n    // Start with offset property, which is equivalent to the border-box value\n    var valueIsBorderBox = true,\n        val = name === \"width\" ? elem.offsetWidth : elem.offsetHeight,\n        styles = getStyles( elem ),\n        isBorderBox = jQuery.support.boxSizing && jQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\";\n\n    // some non-html elements return undefined for offsetWidth, so check for null/undefined\n    // svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285\n    // MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668\n    if ( val <= 0 || val == null ) {\n        // Fall back to computed then uncomputed css if necessary\n        val = curCSS( elem, name, styles );\n        if ( val < 0 || val == null ) {\n            val = elem.style[ name ];\n        }\n\n        // Computed unit is not pixels. Stop here and return.\n        if ( rnumnonpx.test(val) ) {\n            return val;\n        }\n\n        // we need the check for style in case a browser which returns unreliable values\n        // for getComputedStyle silently falls back to the reliable elem.style\n        valueIsBorderBox = isBorderBox && ( jQuery.support.boxSizingReliable || val === elem.style[ name ] );\n\n        // Normalize \"\", auto, and prepare for extra\n        val = parseFloat( val ) || 0;\n    }\n\n    // use the active box-sizing model to add/subtract irrelevant styles\n    return ( val +\n        augmentWidthOrHeight(\n            elem,\n            name,\n            extra || ( isBorderBox ? \"border\" : \"content\" ),\n            valueIsBorderBox,\n            styles\n        )\n    ) + \"px\";\n}\n\n// Try to determine the default display value of an element\nfunction css_defaultDisplay( nodeName ) {\n    var doc = document,\n        display = elemdisplay[ nodeName ];\n\n    if ( !display ) {\n        display = actualDisplay( nodeName, doc );\n\n        // If the simple way fails, read from inside an iframe\n        if ( display === \"none\" || !display ) {\n            // Use the already-created iframe if possible\n            iframe = ( iframe ||\n                jQuery(\"<iframe frameborder='0' width='0' height='0'/>\")\n                .css( \"cssText\", \"display:block !important\" )\n            ).appendTo( doc.documentElement );\n\n            // Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse\n            doc = ( iframe[0].contentWindow || iframe[0].contentDocument ).document;\n            doc.write(\"<!doctype html><html><body>\");\n            doc.close();\n\n            display = actualDisplay( nodeName, doc );\n            iframe.detach();\n        }\n\n        // Store the correct default display\n        elemdisplay[ nodeName ] = display;\n    }\n\n    return display;\n}\n\n// Called ONLY from within css_defaultDisplay\nfunction actualDisplay( name, doc ) {\n    var elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),\n        display = jQuery.css( elem[0], \"display\" );\n    elem.remove();\n    return display;\n}\n\njQuery.each([ \"height\", \"width\" ], function( i, name ) {\n    jQuery.cssHooks[ name ] = {\n        get: function( elem, computed, extra ) {\n            if ( computed ) {\n                // certain elements can have dimension info if we invisibly show them\n                // however, it must have a current display style that would benefit from this\n                return elem.offsetWidth === 0 && rdisplayswap.test( jQuery.css( elem, \"display\" ) ) ?\n                    jQuery.swap( elem, cssShow, function() {\n                        return getWidthOrHeight( elem, name, extra );\n                    }) :\n                    getWidthOrHeight( elem, name, extra );\n            }\n        },\n\n        set: function( elem, value, extra ) {\n            var styles = extra && getStyles( elem );\n            return setPositiveNumber( elem, value, extra ?\n                augmentWidthOrHeight(\n                    elem,\n                    name,\n                    extra,\n                    jQuery.support.boxSizing && jQuery.css( elem, \"boxSizing\", false, styles ) === \"border-box\",\n                    styles\n                ) : 0\n            );\n        }\n    };\n});\n\nif ( !jQuery.support.opacity ) {\n    jQuery.cssHooks.opacity = {\n        get: function( elem, computed ) {\n            // IE uses filters for opacity\n            return ropacity.test( (computed && elem.currentStyle ? elem.currentStyle.filter : elem.style.filter) || \"\" ) ?\n                ( 0.01 * parseFloat( RegExp.$1 ) ) + \"\" :\n                computed ? \"1\" : \"\";\n        },\n\n        set: function( elem, value ) {\n            var style = elem.style,\n                currentStyle = elem.currentStyle,\n                opacity = jQuery.isNumeric( value ) ? \"alpha(opacity=\" + value * 100 + \")\" : \"\",\n                filter = currentStyle && currentStyle.filter || style.filter || \"\";\n\n            // IE has trouble with opacity if it does not have layout\n            // Force it by setting the zoom level\n            style.zoom = 1;\n\n            // if setting opacity to 1, and no other filters exist - attempt to remove filter attribute #6652\n            // if value === \"\", then remove inline opacity #12685\n            if ( ( value >= 1 || value === \"\" ) &&\n                    jQuery.trim( filter.replace( ralpha, \"\" ) ) === \"\" &&\n                    style.removeAttribute ) {\n\n                // Setting style.filter to null, \"\" & \" \" still leave \"filter:\" in the cssText\n                // if \"filter:\" is present at all, clearType is disabled, we want to avoid this\n                // style.removeAttribute is IE Only, but so apparently is this code path...\n                style.removeAttribute( \"filter\" );\n\n                // if there is no filter style applied in a css rule or unset inline opacity, we are done\n                if ( value === \"\" || currentStyle && !currentStyle.filter ) {\n                    return;\n                }\n            }\n\n            // otherwise, set new filter values\n            style.filter = ralpha.test( filter ) ?\n                filter.replace( ralpha, opacity ) :\n                filter + \" \" + opacity;\n        }\n    };\n}\n\n// These hooks cannot be added until DOM ready because the support test\n// for it is not run until after DOM ready\njQuery(function() {\n    if ( !jQuery.support.reliableMarginRight ) {\n        jQuery.cssHooks.marginRight = {\n            get: function( elem, computed ) {\n                if ( computed ) {\n                    // WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right\n                    // Work around by temporarily setting element display to inline-block\n                    return jQuery.swap( elem, { \"display\": \"inline-block\" },\n                        curCSS, [ elem, \"marginRight\" ] );\n                }\n            }\n        };\n    }\n\n    // Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084\n    // getComputedStyle returns percent when specified for top/left/bottom/right\n    // rather than make the css module depend on the offset module, we just check for it here\n    if ( !jQuery.support.pixelPosition && jQuery.fn.position ) {\n        jQuery.each( [ \"top\", \"left\" ], function( i, prop ) {\n            jQuery.cssHooks[ prop ] = {\n                get: function( elem, computed ) {\n                    if ( computed ) {\n                        computed = curCSS( elem, prop );\n                        // if curCSS returns percentage, fallback to offset\n                        return rnumnonpx.test( computed ) ?\n                            jQuery( elem ).position()[ prop ] + \"px\" :\n                            computed;\n                    }\n                }\n            };\n        });\n    }\n\n});\n\nif ( jQuery.expr && jQuery.expr.filters ) {\n    jQuery.expr.filters.hidden = function( elem ) {\n        // Support: Opera <= 12.12\n        // Opera reports offsetWidths and offsetHeights less than zero on some elements\n        return elem.offsetWidth <= 0 && elem.offsetHeight <= 0 ||\n            (!jQuery.support.reliableHiddenOffsets && ((elem.style && elem.style.display) || jQuery.css( elem, \"display\" )) === \"none\");\n    };\n\n    jQuery.expr.filters.visible = function( elem ) {\n        return !jQuery.expr.filters.hidden( elem );\n    };\n}\n\n// These hooks are used by animate to expand properties\njQuery.each({\n    margin: \"\",\n    padding: \"\",\n    border: \"Width\"\n}, function( prefix, suffix ) {\n    jQuery.cssHooks[ prefix + suffix ] = {\n        expand: function( value ) {\n            var i = 0,\n                expanded = {},\n\n                // assumes a single number if not a string\n                parts = typeof value === \"string\" ? value.split(\" \") : [ value ];\n\n            for ( ; i < 4; i++ ) {\n                expanded[ prefix + cssExpand[ i ] + suffix ] =\n                    parts[ i ] || parts[ i - 2 ] || parts[ 0 ];\n            }\n\n            return expanded;\n        }\n    };\n\n    if ( !rmargin.test( prefix ) ) {\n        jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;\n    }\n});\nvar r20 = /%20/g,\n    rbracket = /\\[\\]$/,\n    rCRLF = /\\r?\\n/g,\n    rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,\n    rsubmittable = /^(?:input|select|textarea|keygen)/i;\n\njQuery.fn.extend({\n    serialize: function() {\n        return jQuery.param( this.serializeArray() );\n    },\n    serializeArray: function() {\n        return this.map(function(){\n            // Can add propHook for \"elements\" to filter or add form elements\n            var elements = jQuery.prop( this, \"elements\" );\n            return elements ? jQuery.makeArray( elements ) : this;\n        })\n        .filter(function(){\n            var type = this.type;\n            // Use .is(\":disabled\") so that fieldset[disabled] works\n            return this.name && !jQuery( this ).is( \":disabled\" ) &&\n                rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&\n                ( this.checked || !manipulation_rcheckableType.test( type ) );\n        })\n        .map(function( i, elem ){\n            var val = jQuery( this ).val();\n\n            return val == null ?\n                null :\n                jQuery.isArray( val ) ?\n                    jQuery.map( val, function( val ){\n                        return { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n                    }) :\n                    { name: elem.name, value: val.replace( rCRLF, \"\\r\\n\" ) };\n        }).get();\n    }\n});\n\n//Serialize an array of form elements or a set of\n//key/values into a query string\njQuery.param = function( a, traditional ) {\n    var prefix,\n        s = [],\n        add = function( key, value ) {\n            // If value is a function, invoke it and return its value\n            value = jQuery.isFunction( value ) ? value() : ( value == null ? \"\" : value );\n            s[ s.length ] = encodeURIComponent( key ) + \"=\" + encodeURIComponent( value );\n        };\n\n    // Set traditional to true for jQuery <= 1.3.2 behavior.\n    if ( traditional === undefined ) {\n        traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;\n    }\n\n    // If an array was passed in, assume that it is an array of form elements.\n    if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {\n        // Serialize the form elements\n        jQuery.each( a, function() {\n            add( this.name, this.value );\n        });\n\n    } else {\n        // If traditional, encode the \"old\" way (the way 1.3.2 or older\n        // did it), otherwise encode params recursively.\n        for ( prefix in a ) {\n            buildParams( prefix, a[ prefix ], traditional, add );\n        }\n    }\n\n    // Return the resulting serialization\n    return s.join( \"&\" ).replace( r20, \"+\" );\n};\n\nfunction buildParams( prefix, obj, traditional, add ) {\n    var name;\n\n    if ( jQuery.isArray( obj ) ) {\n        // Serialize array item.\n        jQuery.each( obj, function( i, v ) {\n            if ( traditional || rbracket.test( prefix ) ) {\n                // Treat each array item as a scalar.\n                add( prefix, v );\n\n            } else {\n                // Item is non-scalar (array or object), encode its numeric index.\n                buildParams( prefix + \"[\" + ( typeof v === \"object\" ? i : \"\" ) + \"]\", v, traditional, add );\n            }\n        });\n\n    } else if ( !traditional && jQuery.type( obj ) === \"object\" ) {\n        // Serialize object item.\n        for ( name in obj ) {\n            buildParams( prefix + \"[\" + name + \"]\", obj[ name ], traditional, add );\n        }\n\n    } else {\n        // Serialize scalar item.\n        add( prefix, obj );\n    }\n}\njQuery.each( (\"blur focus focusin focusout load resize scroll unload click dblclick \" +\n    \"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave \" +\n    \"change select submit keydown keypress keyup error contextmenu\").split(\" \"), function( i, name ) {\n\n    // Handle event binding\n    jQuery.fn[ name ] = function( data, fn ) {\n        return arguments.length > 0 ?\n            this.on( name, null, data, fn ) :\n            this.trigger( name );\n    };\n});\n\njQuery.fn.extend({\n    hover: function( fnOver, fnOut ) {\n        return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );\n    },\n\n    bind: function( types, data, fn ) {\n        return this.on( types, null, data, fn );\n    },\n    unbind: function( types, fn ) {\n        return this.off( types, null, fn );\n    },\n\n    delegate: function( selector, types, data, fn ) {\n        return this.on( types, selector, data, fn );\n    },\n    undelegate: function( selector, types, fn ) {\n        // ( namespace ) or ( selector, types [, fn] )\n        return arguments.length === 1 ? this.off( selector, \"**\" ) : this.off( types, selector || \"**\", fn );\n    }\n});\nvar\n    // Document location\n    ajaxLocParts,\n    ajaxLocation,\n    ajax_nonce = jQuery.now(),\n\n    ajax_rquery = /\\?/,\n    rhash = /#.*$/,\n    rts = /([?&])_=[^&]*/,\n    rheaders = /^(.*?):[ \\t]*([^\\r\\n]*)\\r?$/mg, // IE leaves an \\r character at EOL\n    // #7653, #8125, #8152: local protocol detection\n    rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,\n    rnoContent = /^(?:GET|HEAD)$/,\n    rprotocol = /^\\/\\//,\n    rurl = /^([\\w.+-]+:)(?:\\/\\/([^\\/?#:]*)(?::(\\d+)|)|)/,\n\n    // Keep a copy of the old load method\n    _load = jQuery.fn.load,\n\n    /* Prefilters\n     * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)\n     * 2) These are called:\n     *    - BEFORE asking for a transport\n     *    - AFTER param serialization (s.data is a string if s.processData is true)\n     * 3) key is the dataType\n     * 4) the catchall symbol \"*\" can be used\n     * 5) execution will start with transport dataType and THEN continue down to \"*\" if needed\n     */\n    prefilters = {},\n\n    /* Transports bindings\n     * 1) key is the dataType\n     * 2) the catchall symbol \"*\" can be used\n     * 3) selection will start with transport dataType and THEN go to \"*\" if needed\n     */\n    transports = {},\n\n    // Avoid comment-prolog char sequence (#10098); must appease lint and evade compression\n    allTypes = \"*/\".concat(\"*\");\n\n// #8138, IE may throw an exception when accessing\n// a field from window.location if document.domain has been set\ntry {\n    ajaxLocation = location.href;\n} catch( e ) {\n    // Use the href attribute of an A element\n    // since IE will modify it given document.location\n    ajaxLocation = document.createElement( \"a\" );\n    ajaxLocation.href = \"\";\n    ajaxLocation = ajaxLocation.href;\n}\n\n// Segment location into parts\najaxLocParts = rurl.exec( ajaxLocation.toLowerCase() ) || [];\n\n// Base \"constructor\" for jQuery.ajaxPrefilter and jQuery.ajaxTransport\nfunction addToPrefiltersOrTransports( structure ) {\n\n    // dataTypeExpression is optional and defaults to \"*\"\n    return function( dataTypeExpression, func ) {\n\n        if ( typeof dataTypeExpression !== \"string\" ) {\n            func = dataTypeExpression;\n            dataTypeExpression = \"*\";\n        }\n\n        var dataType,\n            i = 0,\n            dataTypes = dataTypeExpression.toLowerCase().match( core_rnotwhite ) || [];\n\n        if ( jQuery.isFunction( func ) ) {\n            // For each dataType in the dataTypeExpression\n            while ( (dataType = dataTypes[i++]) ) {\n                // Prepend if requested\n                if ( dataType[0] === \"+\" ) {\n                    dataType = dataType.slice( 1 ) || \"*\";\n                    (structure[ dataType ] = structure[ dataType ] || []).unshift( func );\n\n                // Otherwise append\n                } else {\n                    (structure[ dataType ] = structure[ dataType ] || []).push( func );\n                }\n            }\n        }\n    };\n}\n\n// Base inspection function for prefilters and transports\nfunction inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {\n\n    var inspected = {},\n        seekingTransport = ( structure === transports );\n\n    function inspect( dataType ) {\n        var selected;\n        inspected[ dataType ] = true;\n        jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {\n            var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );\n            if( typeof dataTypeOrTransport === \"string\" && !seekingTransport && !inspected[ dataTypeOrTransport ] ) {\n                options.dataTypes.unshift( dataTypeOrTransport );\n                inspect( dataTypeOrTransport );\n                return false;\n            } else if ( seekingTransport ) {\n                return !( selected = dataTypeOrTransport );\n            }\n        });\n        return selected;\n    }\n\n    return inspect( options.dataTypes[ 0 ] ) || !inspected[ \"*\" ] && inspect( \"*\" );\n}\n\n// A special extend for ajax options\n// that takes \"flat\" options (not to be deep extended)\n// Fixes #9887\nfunction ajaxExtend( target, src ) {\n    var deep, key,\n        flatOptions = jQuery.ajaxSettings.flatOptions || {};\n\n    for ( key in src ) {\n        if ( src[ key ] !== undefined ) {\n            ( flatOptions[ key ] ? target : ( deep || (deep = {}) ) )[ key ] = src[ key ];\n        }\n    }\n    if ( deep ) {\n        jQuery.extend( true, target, deep );\n    }\n\n    return target;\n}\n\njQuery.fn.load = function( url, params, callback ) {\n    if ( typeof url !== \"string\" && _load ) {\n        return _load.apply( this, arguments );\n    }\n\n    var selector, response, type,\n        self = this,\n        off = url.indexOf(\" \");\n\n    if ( off >= 0 ) {\n        selector = url.slice( off, url.length );\n        url = url.slice( 0, off );\n    }\n\n    // If it's a function\n    if ( jQuery.isFunction( params ) ) {\n\n        // We assume that it's the callback\n        callback = params;\n        params = undefined;\n\n    // Otherwise, build a param string\n    } else if ( params && typeof params === \"object\" ) {\n        type = \"POST\";\n    }\n\n    // If we have elements to modify, make the request\n    if ( self.length > 0 ) {\n        jQuery.ajax({\n            url: url,\n\n            // if \"type\" variable is undefined, then \"GET\" method will be used\n            type: type,\n            dataType: \"html\",\n            data: params\n        }).done(function( responseText ) {\n\n            // Save response for use in complete callback\n            response = arguments;\n\n            self.html( selector ?\n\n                // If a selector was specified, locate the right elements in a dummy div\n                // Exclude scripts to avoid IE 'Permission Denied' errors\n                jQuery(\"<div>\").append( jQuery.parseHTML( responseText ) ).find( selector ) :\n\n                // Otherwise use the full result\n                responseText );\n\n        }).complete( callback && function( jqXHR, status ) {\n            self.each( callback, response || [ jqXHR.responseText, status, jqXHR ] );\n        });\n    }\n\n    return this;\n};\n\n// Attach a bunch of functions for handling common AJAX events\njQuery.each( [ \"ajaxStart\", \"ajaxStop\", \"ajaxComplete\", \"ajaxError\", \"ajaxSuccess\", \"ajaxSend\" ], function( i, type ){\n    jQuery.fn[ type ] = function( fn ){\n        return this.on( type, fn );\n    };\n});\n\njQuery.extend({\n\n    // Counter for holding the number of active queries\n    active: 0,\n\n    // Last-Modified header cache for next request\n    lastModified: {},\n    etag: {},\n\n    ajaxSettings: {\n        url: ajaxLocation,\n        type: \"GET\",\n        isLocal: rlocalProtocol.test( ajaxLocParts[ 1 ] ),\n        global: true,\n        processData: true,\n        async: true,\n        contentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\n        /*\n        timeout: 0,\n        data: null,\n        dataType: null,\n        username: null,\n        password: null,\n        cache: null,\n        throws: false,\n        traditional: false,\n        headers: {},\n        */\n\n        accepts: {\n            \"*\": allTypes,\n            text: \"text/plain\",\n            html: \"text/html\",\n            xml: \"application/xml, text/xml\",\n            json: \"application/json, text/javascript\"\n        },\n\n        contents: {\n            xml: /xml/,\n            html: /html/,\n            json: /json/\n        },\n\n        responseFields: {\n            xml: \"responseXML\",\n            text: \"responseText\",\n            json: \"responseJSON\"\n        },\n\n        // Data converters\n        // Keys separate source (or catchall \"*\") and destination types with a single space\n        converters: {\n\n            // Convert anything to text\n            \"* text\": String,\n\n            // Text to html (true = no transformation)\n            \"text html\": true,\n\n            // Evaluate text as a json expression\n            \"text json\": jQuery.parseJSON,\n\n            // Parse text as xml\n            \"text xml\": jQuery.parseXML\n        },\n\n        // For options that shouldn't be deep extended:\n        // you can add your own custom options here if\n        // and when you create one that shouldn't be\n        // deep extended (see ajaxExtend)\n        flatOptions: {\n            url: true,\n            context: true\n        }\n    },\n\n    // Creates a full fledged settings object into target\n    // with both ajaxSettings and settings fields.\n    // If target is omitted, writes into ajaxSettings.\n    ajaxSetup: function( target, settings ) {\n        return settings ?\n\n            // Building a settings object\n            ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :\n\n            // Extending ajaxSettings\n            ajaxExtend( jQuery.ajaxSettings, target );\n    },\n\n    ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),\n    ajaxTransport: addToPrefiltersOrTransports( transports ),\n\n    // Main method\n    ajax: function( url, options ) {\n\n        // If url is an object, simulate pre-1.5 signature\n        if ( typeof url === \"object\" ) {\n            options = url;\n            url = undefined;\n        }\n\n        // Force options to be an object\n        options = options || {};\n\n        var // Cross-domain detection vars\n            parts,\n            // Loop variable\n            i,\n            // URL without anti-cache param\n            cacheURL,\n            // Response headers as string\n            responseHeadersString,\n            // timeout handle\n            timeoutTimer,\n\n            // To know if global events are to be dispatched\n            fireGlobals,\n\n            transport,\n            // Response headers\n            responseHeaders,\n            // Create the final options object\n            s = jQuery.ajaxSetup( {}, options ),\n            // Callbacks context\n            callbackContext = s.context || s,\n            // Context for global events is callbackContext if it is a DOM node or jQuery collection\n            globalEventContext = s.context && ( callbackContext.nodeType || callbackContext.jquery ) ?\n                jQuery( callbackContext ) :\n                jQuery.event,\n            // Deferreds\n            deferred = jQuery.Deferred(),\n            completeDeferred = jQuery.Callbacks(\"once memory\"),\n            // Status-dependent callbacks\n            statusCode = s.statusCode || {},\n            // Headers (they are sent all at once)\n            requestHeaders = {},\n            requestHeadersNames = {},\n            // The jqXHR state\n            state = 0,\n            // Default abort message\n            strAbort = \"canceled\",\n            // Fake xhr\n            jqXHR = {\n                readyState: 0,\n\n                // Builds headers hashtable if needed\n                getResponseHeader: function( key ) {\n                    var match;\n                    if ( state === 2 ) {\n                        if ( !responseHeaders ) {\n                            responseHeaders = {};\n                            while ( (match = rheaders.exec( responseHeadersString )) ) {\n                                responseHeaders[ match[1].toLowerCase() ] = match[ 2 ];\n                            }\n                        }\n                        match = responseHeaders[ key.toLowerCase() ];\n                    }\n                    return match == null ? null : match;\n                },\n\n                // Raw string\n                getAllResponseHeaders: function() {\n                    return state === 2 ? responseHeadersString : null;\n                },\n\n                // Caches the header\n                setRequestHeader: function( name, value ) {\n                    var lname = name.toLowerCase();\n                    if ( !state ) {\n                        name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;\n                        requestHeaders[ name ] = value;\n                    }\n                    return this;\n                },\n\n                // Overrides response content-type header\n                overrideMimeType: function( type ) {\n                    if ( !state ) {\n                        s.mimeType = type;\n                    }\n                    return this;\n                },\n\n                // Status-dependent callbacks\n                statusCode: function( map ) {\n                    var code;\n                    if ( map ) {\n                        if ( state < 2 ) {\n                            for ( code in map ) {\n                                // Lazy-add the new callback in a way that preserves old ones\n                                statusCode[ code ] = [ statusCode[ code ], map[ code ] ];\n                            }\n                        } else {\n                            // Execute the appropriate callbacks\n                            jqXHR.always( map[ jqXHR.status ] );\n                        }\n                    }\n                    return this;\n                },\n\n                // Cancel the request\n                abort: function( statusText ) {\n                    var finalText = statusText || strAbort;\n                    if ( transport ) {\n                        transport.abort( finalText );\n                    }\n                    done( 0, finalText );\n                    return this;\n                }\n            };\n\n        // Attach deferreds\n        deferred.promise( jqXHR ).complete = completeDeferred.add;\n        jqXHR.success = jqXHR.done;\n        jqXHR.error = jqXHR.fail;\n\n        // Remove hash character (#7531: and string promotion)\n        // Add protocol if not provided (#5866: IE7 issue with protocol-less urls)\n        // Handle falsy url in the settings object (#10093: consistency with old signature)\n        // We also use the url parameter if available\n        s.url = ( ( url || s.url || ajaxLocation ) + \"\" ).replace( rhash, \"\" ).replace( rprotocol, ajaxLocParts[ 1 ] + \"//\" );\n\n        // Alias method option to type as per ticket #12004\n        s.type = options.method || options.type || s.method || s.type;\n\n        // Extract dataTypes list\n        s.dataTypes = jQuery.trim( s.dataType || \"*\" ).toLowerCase().match( core_rnotwhite ) || [\"\"];\n\n        // A cross-domain request is in order when we have a protocol:host:port mismatch\n        if ( s.crossDomain == null ) {\n            parts = rurl.exec( s.url.toLowerCase() );\n            s.crossDomain = !!( parts &&\n                ( parts[ 1 ] !== ajaxLocParts[ 1 ] || parts[ 2 ] !== ajaxLocParts[ 2 ] ||\n                    ( parts[ 3 ] || ( parts[ 1 ] === \"http:\" ? \"80\" : \"443\" ) ) !==\n                        ( ajaxLocParts[ 3 ] || ( ajaxLocParts[ 1 ] === \"http:\" ? \"80\" : \"443\" ) ) )\n            );\n        }\n\n        // Convert data if not already a string\n        if ( s.data && s.processData && typeof s.data !== \"string\" ) {\n            s.data = jQuery.param( s.data, s.traditional );\n        }\n\n        // Apply prefilters\n        inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );\n\n        // If request was aborted inside a prefilter, stop there\n        if ( state === 2 ) {\n            return jqXHR;\n        }\n\n        // We can fire global events as of now if asked to\n        fireGlobals = s.global;\n\n        // Watch for a new set of requests\n        if ( fireGlobals && jQuery.active++ === 0 ) {\n            jQuery.event.trigger(\"ajaxStart\");\n        }\n\n        // Uppercase the type\n        s.type = s.type.toUpperCase();\n\n        // Determine if request has content\n        s.hasContent = !rnoContent.test( s.type );\n\n        // Save the URL in case we're toying with the If-Modified-Since\n        // and/or If-None-Match header later on\n        cacheURL = s.url;\n\n        // More options handling for requests with no content\n        if ( !s.hasContent ) {\n\n            // If data is available, append data to url\n            if ( s.data ) {\n                cacheURL = ( s.url += ( ajax_rquery.test( cacheURL ) ? \"&\" : \"?\" ) + s.data );\n                // #9682: remove data so that it's not used in an eventual retry\n                delete s.data;\n            }\n\n            // Add anti-cache in url if needed\n            if ( s.cache === false ) {\n                s.url = rts.test( cacheURL ) ?\n\n                    // If there is already a '_' parameter, set its value\n                    cacheURL.replace( rts, \"$1_=\" + ajax_nonce++ ) :\n\n                    // Otherwise add one to the end\n                    cacheURL + ( ajax_rquery.test( cacheURL ) ? \"&\" : \"?\" ) + \"_=\" + ajax_nonce++;\n            }\n        }\n\n        // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n        if ( s.ifModified ) {\n            if ( jQuery.lastModified[ cacheURL ] ) {\n                jqXHR.setRequestHeader( \"If-Modified-Since\", jQuery.lastModified[ cacheURL ] );\n            }\n            if ( jQuery.etag[ cacheURL ] ) {\n                jqXHR.setRequestHeader( \"If-None-Match\", jQuery.etag[ cacheURL ] );\n            }\n        }\n\n        // Set the correct header, if data is being sent\n        if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {\n            jqXHR.setRequestHeader( \"Content-Type\", s.contentType );\n        }\n\n        // Set the Accepts header for the server, depending on the dataType\n        jqXHR.setRequestHeader(\n            \"Accept\",\n            s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[0] ] ?\n                s.accepts[ s.dataTypes[0] ] + ( s.dataTypes[ 0 ] !== \"*\" ? \", \" + allTypes + \"; q=0.01\" : \"\" ) :\n                s.accepts[ \"*\" ]\n        );\n\n        // Check for headers option\n        for ( i in s.headers ) {\n            jqXHR.setRequestHeader( i, s.headers[ i ] );\n        }\n\n        // Allow custom headers/mimetypes and early abort\n        if ( s.beforeSend && ( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {\n            // Abort if not done already and return\n            return jqXHR.abort();\n        }\n\n        // aborting is no longer a cancellation\n        strAbort = \"abort\";\n\n        // Install callbacks on deferreds\n        for ( i in { success: 1, error: 1, complete: 1 } ) {\n            jqXHR[ i ]( s[ i ] );\n        }\n\n        // Get transport\n        transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );\n\n        // If no transport, we auto-abort\n        if ( !transport ) {\n            done( -1, \"No Transport\" );\n        } else {\n            jqXHR.readyState = 1;\n\n            // Send global event\n            if ( fireGlobals ) {\n                globalEventContext.trigger( \"ajaxSend\", [ jqXHR, s ] );\n            }\n            // Timeout\n            if ( s.async && s.timeout > 0 ) {\n                timeoutTimer = setTimeout(function() {\n                    jqXHR.abort(\"timeout\");\n                }, s.timeout );\n            }\n\n            try {\n                state = 1;\n                transport.send( requestHeaders, done );\n            } catch ( e ) {\n                // Propagate exception as error if not done\n                if ( state < 2 ) {\n                    done( -1, e );\n                // Simply rethrow otherwise\n                } else {\n                    throw e;\n                }\n            }\n        }\n\n        // Callback for when everything is done\n        function done( status, nativeStatusText, responses, headers ) {\n            var isSuccess, success, error, response, modified,\n                statusText = nativeStatusText;\n\n            // Called once\n            if ( state === 2 ) {\n                return;\n            }\n\n            // State is \"done\" now\n            state = 2;\n\n            // Clear timeout if it exists\n            if ( timeoutTimer ) {\n                clearTimeout( timeoutTimer );\n            }\n\n            // Dereference transport for early garbage collection\n            // (no matter how long the jqXHR object will be used)\n            transport = undefined;\n\n            // Cache response headers\n            responseHeadersString = headers || \"\";\n\n            // Set readyState\n            jqXHR.readyState = status > 0 ? 4 : 0;\n\n            // Determine if successful\n            isSuccess = status >= 200 && status < 300 || status === 304;\n\n            // Get response data\n            if ( responses ) {\n                response = ajaxHandleResponses( s, jqXHR, responses );\n            }\n\n            // Convert no matter what (that way responseXXX fields are always set)\n            response = ajaxConvert( s, response, jqXHR, isSuccess );\n\n            // If successful, handle type chaining\n            if ( isSuccess ) {\n\n                // Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.\n                if ( s.ifModified ) {\n                    modified = jqXHR.getResponseHeader(\"Last-Modified\");\n                    if ( modified ) {\n                        jQuery.lastModified[ cacheURL ] = modified;\n                    }\n                    modified = jqXHR.getResponseHeader(\"etag\");\n                    if ( modified ) {\n                        jQuery.etag[ cacheURL ] = modified;\n                    }\n                }\n\n                // if no content\n                if ( status === 204 || s.type === \"HEAD\" ) {\n                    statusText = \"nocontent\";\n\n                // if not modified\n                } else if ( status === 304 ) {\n                    statusText = \"notmodified\";\n\n                // If we have data, let's convert it\n                } else {\n                    statusText = response.state;\n                    success = response.data;\n                    error = response.error;\n                    isSuccess = !error;\n                }\n            } else {\n                // We extract error from statusText\n                // then normalize statusText and status for non-aborts\n                error = statusText;\n                if ( status || !statusText ) {\n                    statusText = \"error\";\n                    if ( status < 0 ) {\n                        status = 0;\n                    }\n                }\n            }\n\n            // Set data for the fake xhr object\n            jqXHR.status = status;\n            jqXHR.statusText = ( nativeStatusText || statusText ) + \"\";\n\n            // Success/Error\n            if ( isSuccess ) {\n                deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );\n            } else {\n                deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );\n            }\n\n            // Status-dependent callbacks\n            jqXHR.statusCode( statusCode );\n            statusCode = undefined;\n\n            if ( fireGlobals ) {\n                globalEventContext.trigger( isSuccess ? \"ajaxSuccess\" : \"ajaxError\",\n                    [ jqXHR, s, isSuccess ? success : error ] );\n            }\n\n            // Complete\n            completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );\n\n            if ( fireGlobals ) {\n                globalEventContext.trigger( \"ajaxComplete\", [ jqXHR, s ] );\n                // Handle the global AJAX counter\n                if ( !( --jQuery.active ) ) {\n                    jQuery.event.trigger(\"ajaxStop\");\n                }\n            }\n        }\n\n        return jqXHR;\n    },\n\n    getJSON: function( url, data, callback ) {\n        return jQuery.get( url, data, callback, \"json\" );\n    },\n\n    getScript: function( url, callback ) {\n        return jQuery.get( url, undefined, callback, \"script\" );\n    }\n});\n\njQuery.each( [ \"get\", \"post\" ], function( i, method ) {\n    jQuery[ method ] = function( url, data, callback, type ) {\n        // shift arguments if data argument was omitted\n        if ( jQuery.isFunction( data ) ) {\n            type = type || callback;\n            callback = data;\n            data = undefined;\n        }\n\n        return jQuery.ajax({\n            url: url,\n            type: method,\n            dataType: type,\n            data: data,\n            success: callback\n        });\n    };\n});\n\n/* Handles responses to an ajax request:\n * - finds the right dataType (mediates between content-type and expected dataType)\n * - returns the corresponding response\n */\nfunction ajaxHandleResponses( s, jqXHR, responses ) {\n    var firstDataType, ct, finalDataType, type,\n        contents = s.contents,\n        dataTypes = s.dataTypes;\n\n    // Remove auto dataType and get content-type in the process\n    while( dataTypes[ 0 ] === \"*\" ) {\n        dataTypes.shift();\n        if ( ct === undefined ) {\n            ct = s.mimeType || jqXHR.getResponseHeader(\"Content-Type\");\n        }\n    }\n\n    // Check if we're dealing with a known content-type\n    if ( ct ) {\n        for ( type in contents ) {\n            if ( contents[ type ] && contents[ type ].test( ct ) ) {\n                dataTypes.unshift( type );\n                break;\n            }\n        }\n    }\n\n    // Check to see if we have a response for the expected dataType\n    if ( dataTypes[ 0 ] in responses ) {\n        finalDataType = dataTypes[ 0 ];\n    } else {\n        // Try convertible dataTypes\n        for ( type in responses ) {\n            if ( !dataTypes[ 0 ] || s.converters[ type + \" \" + dataTypes[0] ] ) {\n                finalDataType = type;\n                break;\n            }\n            if ( !firstDataType ) {\n                firstDataType = type;\n            }\n        }\n        // Or just use first one\n        finalDataType = finalDataType || firstDataType;\n    }\n\n    // If we found a dataType\n    // We add the dataType to the list if needed\n    // and return the corresponding response\n    if ( finalDataType ) {\n        if ( finalDataType !== dataTypes[ 0 ] ) {\n            dataTypes.unshift( finalDataType );\n        }\n        return responses[ finalDataType ];\n    }\n}\n\n/* Chain conversions given the request and the original response\n * Also sets the responseXXX fields on the jqXHR instance\n */\nfunction ajaxConvert( s, response, jqXHR, isSuccess ) {\n    var conv2, current, conv, tmp, prev,\n        converters = {},\n        // Work with a copy of dataTypes in case we need to modify it for conversion\n        dataTypes = s.dataTypes.slice();\n\n    // Create converters map with lowercased keys\n    if ( dataTypes[ 1 ] ) {\n        for ( conv in s.converters ) {\n            converters[ conv.toLowerCase() ] = s.converters[ conv ];\n        }\n    }\n\n    current = dataTypes.shift();\n\n    // Convert to each sequential dataType\n    while ( current ) {\n\n        if ( s.responseFields[ current ] ) {\n            jqXHR[ s.responseFields[ current ] ] = response;\n        }\n\n        // Apply the dataFilter if provided\n        if ( !prev && isSuccess && s.dataFilter ) {\n            response = s.dataFilter( response, s.dataType );\n        }\n\n        prev = current;\n        current = dataTypes.shift();\n\n        if ( current ) {\n\n            // There's only work to do if current dataType is non-auto\n            if ( current === \"*\" ) {\n\n                current = prev;\n\n            // Convert response if prev dataType is non-auto and differs from current\n            } else if ( prev !== \"*\" && prev !== current ) {\n\n                // Seek a direct converter\n                conv = converters[ prev + \" \" + current ] || converters[ \"* \" + current ];\n\n                // If none found, seek a pair\n                if ( !conv ) {\n                    for ( conv2 in converters ) {\n\n                        // If conv2 outputs current\n                        tmp = conv2.split( \" \" );\n                        if ( tmp[ 1 ] === current ) {\n\n                            // If prev can be converted to accepted input\n                            conv = converters[ prev + \" \" + tmp[ 0 ] ] ||\n                                converters[ \"* \" + tmp[ 0 ] ];\n                            if ( conv ) {\n                                // Condense equivalence converters\n                                if ( conv === true ) {\n                                    conv = converters[ conv2 ];\n\n                                // Otherwise, insert the intermediate dataType\n                                } else if ( converters[ conv2 ] !== true ) {\n                                    current = tmp[ 0 ];\n                                    dataTypes.unshift( tmp[ 1 ] );\n                                }\n                                break;\n                            }\n                        }\n                    }\n                }\n\n                // Apply converter (if not an equivalence)\n                if ( conv !== true ) {\n\n                    // Unless errors are allowed to bubble, catch and return them\n                    if ( conv && s[ \"throws\" ] ) {\n                        response = conv( response );\n                    } else {\n                        try {\n                            response = conv( response );\n                        } catch ( e ) {\n                            return { state: \"parsererror\", error: conv ? e : \"No conversion from \" + prev + \" to \" + current };\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    return { state: \"success\", data: response };\n}\n// Install script dataType\njQuery.ajaxSetup({\n    accepts: {\n        script: \"text/javascript, application/javascript, application/ecmascript, application/x-ecmascript\"\n    },\n    contents: {\n        script: /(?:java|ecma)script/\n    },\n    converters: {\n        \"text script\": function( text ) {\n            jQuery.globalEval( text );\n            return text;\n        }\n    }\n});\n\n// Handle cache's special case and global\njQuery.ajaxPrefilter( \"script\", function( s ) {\n    if ( s.cache === undefined ) {\n        s.cache = false;\n    }\n    if ( s.crossDomain ) {\n        s.type = \"GET\";\n        s.global = false;\n    }\n});\n\n// Bind script tag hack transport\njQuery.ajaxTransport( \"script\", function(s) {\n\n    // This transport only deals with cross domain requests\n    if ( s.crossDomain ) {\n\n        var script,\n            head = document.head || jQuery(\"head\")[0] || document.documentElement;\n\n        return {\n\n            send: function( _, callback ) {\n\n                script = document.createElement(\"script\");\n\n                script.async = true;\n\n                if ( s.scriptCharset ) {\n                    script.charset = s.scriptCharset;\n                }\n\n                script.src = s.url;\n\n                // Attach handlers for all browsers\n                script.onload = script.onreadystatechange = function( _, isAbort ) {\n\n                    if ( isAbort || !script.readyState || /loaded|complete/.test( script.readyState ) ) {\n\n                        // Handle memory leak in IE\n                        script.onload = script.onreadystatechange = null;\n\n                        // Remove the script\n                        if ( script.parentNode ) {\n                            script.parentNode.removeChild( script );\n                        }\n\n                        // Dereference the script\n                        script = null;\n\n                        // Callback if not abort\n                        if ( !isAbort ) {\n                            callback( 200, \"success\" );\n                        }\n                    }\n                };\n\n                // Circumvent IE6 bugs with base elements (#2709 and #4378) by prepending\n                // Use native DOM manipulation to avoid our domManip AJAX trickery\n                head.insertBefore( script, head.firstChild );\n            },\n\n            abort: function() {\n                if ( script ) {\n                    script.onload( undefined, true );\n                }\n            }\n        };\n    }\n});\nvar oldCallbacks = [],\n    rjsonp = /(=)\\?(?=&|$)|\\?\\?/;\n\n// Default jsonp settings\njQuery.ajaxSetup({\n    jsonp: \"callback\",\n    jsonpCallback: function() {\n        var callback = oldCallbacks.pop() || ( jQuery.expando + \"_\" + ( ajax_nonce++ ) );\n        this[ callback ] = true;\n        return callback;\n    }\n});\n\n// Detect, normalize options and install callbacks for jsonp requests\njQuery.ajaxPrefilter( \"json jsonp\", function( s, originalSettings, jqXHR ) {\n\n    var callbackName, overwritten, responseContainer,\n        jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?\n            \"url\" :\n            typeof s.data === \"string\" && !( s.contentType || \"\" ).indexOf(\"application/x-www-form-urlencoded\") && rjsonp.test( s.data ) && \"data\"\n        );\n\n    // Handle iff the expected data type is \"jsonp\" or we have a parameter to set\n    if ( jsonProp || s.dataTypes[ 0 ] === \"jsonp\" ) {\n\n        // Get callback name, remembering preexisting value associated with it\n        callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?\n            s.jsonpCallback() :\n            s.jsonpCallback;\n\n        // Insert callback into url or form data\n        if ( jsonProp ) {\n            s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, \"$1\" + callbackName );\n        } else if ( s.jsonp !== false ) {\n            s.url += ( ajax_rquery.test( s.url ) ? \"&\" : \"?\" ) + s.jsonp + \"=\" + callbackName;\n        }\n\n        // Use data converter to retrieve json after script execution\n        s.converters[\"script json\"] = function() {\n            if ( !responseContainer ) {\n                jQuery.error( callbackName + \" was not called\" );\n            }\n            return responseContainer[ 0 ];\n        };\n\n        // force json dataType\n        s.dataTypes[ 0 ] = \"json\";\n\n        // Install callback\n        overwritten = window[ callbackName ];\n        window[ callbackName ] = function() {\n            responseContainer = arguments;\n        };\n\n        // Clean-up function (fires after converters)\n        jqXHR.always(function() {\n            // Restore preexisting value\n            window[ callbackName ] = overwritten;\n\n            // Save back as free\n            if ( s[ callbackName ] ) {\n                // make sure that re-using the options doesn't screw things around\n                s.jsonpCallback = originalSettings.jsonpCallback;\n\n                // save the callback name for future use\n                oldCallbacks.push( callbackName );\n            }\n\n            // Call if it was a function and we have a response\n            if ( responseContainer && jQuery.isFunction( overwritten ) ) {\n                overwritten( responseContainer[ 0 ] );\n            }\n\n            responseContainer = overwritten = undefined;\n        });\n\n        // Delegate to script\n        return \"script\";\n    }\n});\nvar xhrCallbacks, xhrSupported,\n    xhrId = 0,\n    // #5280: Internet Explorer will keep connections alive if we don't abort on unload\n    xhrOnUnloadAbort = window.ActiveXObject && function() {\n        // Abort all pending requests\n        var key;\n        for ( key in xhrCallbacks ) {\n            xhrCallbacks[ key ]( undefined, true );\n        }\n    };\n\n// Functions to create xhrs\nfunction createStandardXHR() {\n    try {\n        return new window.XMLHttpRequest();\n    } catch( e ) {}\n}\n\nfunction createActiveXHR() {\n    try {\n        return new window.ActiveXObject(\"Microsoft.XMLHTTP\");\n    } catch( e ) {}\n}\n\n// Create the request object\n// (This is still attached to ajaxSettings for backward compatibility)\njQuery.ajaxSettings.xhr = window.ActiveXObject ?\n    /* Microsoft failed to properly\n     * implement the XMLHttpRequest in IE7 (can't request local files),\n     * so we use the ActiveXObject when it is available\n     * Additionally XMLHttpRequest can be disabled in IE7/IE8 so\n     * we need a fallback.\n     */\n    function() {\n        return !this.isLocal && createStandardXHR() || createActiveXHR();\n    } :\n    // For all other browsers, use the standard XMLHttpRequest object\n    createStandardXHR;\n\n// Determine support properties\nxhrSupported = jQuery.ajaxSettings.xhr();\njQuery.support.cors = !!xhrSupported && ( \"withCredentials\" in xhrSupported );\nxhrSupported = jQuery.support.ajax = !!xhrSupported;\n\n// Create transport if the browser can provide an xhr\nif ( xhrSupported ) {\n\n    jQuery.ajaxTransport(function( s ) {\n        // Cross domain only allowed if supported through XMLHttpRequest\n        if ( !s.crossDomain || jQuery.support.cors ) {\n\n            var callback;\n\n            return {\n                send: function( headers, complete ) {\n\n                    // Get a new xhr\n                    var handle, i,\n                        xhr = s.xhr();\n\n                    // Open the socket\n                    // Passing null username, generates a login popup on Opera (#2865)\n                    if ( s.username ) {\n                        xhr.open( s.type, s.url, s.async, s.username, s.password );\n                    } else {\n                        xhr.open( s.type, s.url, s.async );\n                    }\n\n                    // Apply custom fields if provided\n                    if ( s.xhrFields ) {\n                        for ( i in s.xhrFields ) {\n                            xhr[ i ] = s.xhrFields[ i ];\n                        }\n                    }\n\n                    // Override mime type if needed\n                    if ( s.mimeType && xhr.overrideMimeType ) {\n                        xhr.overrideMimeType( s.mimeType );\n                    }\n\n                    // X-Requested-With header\n                    // For cross-domain requests, seeing as conditions for a preflight are\n                    // akin to a jigsaw puzzle, we simply never set it to be sure.\n                    // (it can always be set on a per-request basis or even using ajaxSetup)\n                    // For same-domain requests, won't change header if already provided.\n                    if ( !s.crossDomain && !headers[\"X-Requested-With\"] ) {\n                        headers[\"X-Requested-With\"] = \"XMLHttpRequest\";\n                    }\n\n                    // Need an extra try/catch for cross domain requests in Firefox 3\n                    try {\n                        for ( i in headers ) {\n                            xhr.setRequestHeader( i, headers[ i ] );\n                        }\n                    } catch( err ) {}\n\n                    // Do send the request\n                    // This may raise an exception which is actually\n                    // handled in jQuery.ajax (so no try/catch here)\n                    xhr.send( ( s.hasContent && s.data ) || null );\n\n                    // Listener\n                    callback = function( _, isAbort ) {\n                        var status, responseHeaders, statusText, responses;\n\n                        // Firefox throws exceptions when accessing properties\n                        // of an xhr when a network error occurred\n                        // http://helpful.knobs-dials.com/index.php/Component_returned_failure_code:_0x80040111_(NS_ERROR_NOT_AVAILABLE)\n                        try {\n\n                            // Was never called and is aborted or complete\n                            if ( callback && ( isAbort || xhr.readyState === 4 ) ) {\n\n                                // Only called once\n                                callback = undefined;\n\n                                // Do not keep as active anymore\n                                if ( handle ) {\n                                    xhr.onreadystatechange = jQuery.noop;\n                                    if ( xhrOnUnloadAbort ) {\n                                        delete xhrCallbacks[ handle ];\n                                    }\n                                }\n\n                                // If it's an abort\n                                if ( isAbort ) {\n                                    // Abort it manually if needed\n                                    if ( xhr.readyState !== 4 ) {\n                                        xhr.abort();\n                                    }\n                                } else {\n                                    responses = {};\n                                    status = xhr.status;\n                                    responseHeaders = xhr.getAllResponseHeaders();\n\n                                    // When requesting binary data, IE6-9 will throw an exception\n                                    // on any attempt to access responseText (#11426)\n                                    if ( typeof xhr.responseText === \"string\" ) {\n                                        responses.text = xhr.responseText;\n                                    }\n\n                                    // Firefox throws an exception when accessing\n                                    // statusText for faulty cross-domain requests\n                                    try {\n                                        statusText = xhr.statusText;\n                                    } catch( e ) {\n                                        // We normalize with Webkit giving an empty statusText\n                                        statusText = \"\";\n                                    }\n\n                                    // Filter status for non standard behaviors\n\n                                    // If the request is local and we have data: assume a success\n                                    // (success with no data won't get notified, that's the best we\n                                    // can do given current implementations)\n                                    if ( !status && s.isLocal && !s.crossDomain ) {\n                                        status = responses.text ? 200 : 404;\n                                    // IE - #1450: sometimes returns 1223 when it should be 204\n                                    } else if ( status === 1223 ) {\n                                        status = 204;\n                                    }\n                                }\n                            }\n                        } catch( firefoxAccessException ) {\n                            if ( !isAbort ) {\n                                complete( -1, firefoxAccessException );\n                            }\n                        }\n\n                        // Call complete if needed\n                        if ( responses ) {\n                            complete( status, statusText, responses, responseHeaders );\n                        }\n                    };\n\n                    if ( !s.async ) {\n                        // if we're in sync mode we fire the callback\n                        callback();\n                    } else if ( xhr.readyState === 4 ) {\n                        // (IE6 & IE7) if it's in cache and has been\n                        // retrieved directly we need to fire the callback\n                        setTimeout( callback );\n                    } else {\n                        handle = ++xhrId;\n                        if ( xhrOnUnloadAbort ) {\n                            // Create the active xhrs callbacks list if needed\n                            // and attach the unload handler\n                            if ( !xhrCallbacks ) {\n                                xhrCallbacks = {};\n                                jQuery( window ).unload( xhrOnUnloadAbort );\n                            }\n                            // Add to list of active xhrs callbacks\n                            xhrCallbacks[ handle ] = callback;\n                        }\n                        xhr.onreadystatechange = callback;\n                    }\n                },\n\n                abort: function() {\n                    if ( callback ) {\n                        callback( undefined, true );\n                    }\n                }\n            };\n        }\n    });\n}\nvar fxNow, timerId,\n    rfxtypes = /^(?:toggle|show|hide)$/,\n    rfxnum = new RegExp( \"^(?:([+-])=|)(\" + core_pnum + \")([a-z%]*)$\", \"i\" ),\n    rrun = /queueHooks$/,\n    animationPrefilters = [ defaultPrefilter ],\n    tweeners = {\n        \"*\": [function( prop, value ) {\n            var tween = this.createTween( prop, value ),\n                target = tween.cur(),\n                parts = rfxnum.exec( value ),\n                unit = parts && parts[ 3 ] || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" ),\n\n                // Starting value computation is required for potential unit mismatches\n                start = ( jQuery.cssNumber[ prop ] || unit !== \"px\" && +target ) &&\n                    rfxnum.exec( jQuery.css( tween.elem, prop ) ),\n                scale = 1,\n                maxIterations = 20;\n\n            if ( start && start[ 3 ] !== unit ) {\n                // Trust units reported by jQuery.css\n                unit = unit || start[ 3 ];\n\n                // Make sure we update the tween properties later on\n                parts = parts || [];\n\n                // Iteratively approximate from a nonzero starting point\n                start = +target || 1;\n\n                do {\n                    // If previous iteration zeroed out, double until we get *something*\n                    // Use a string for doubling factor so we don't accidentally see scale as unchanged below\n                    scale = scale || \".5\";\n\n                    // Adjust and apply\n                    start = start / scale;\n                    jQuery.style( tween.elem, prop, start + unit );\n\n                // Update scale, tolerating zero or NaN from tween.cur()\n                // And breaking the loop if scale is unchanged or perfect, or if we've just had enough\n                } while ( scale !== (scale = tween.cur() / target) && scale !== 1 && --maxIterations );\n            }\n\n            // Update tween properties\n            if ( parts ) {\n                start = tween.start = +start || +target || 0;\n                tween.unit = unit;\n                // If a +=/-= token was provided, we're doing a relative animation\n                tween.end = parts[ 1 ] ?\n                    start + ( parts[ 1 ] + 1 ) * parts[ 2 ] :\n                    +parts[ 2 ];\n            }\n\n            return tween;\n        }]\n    };\n\n// Animations created synchronously will run synchronously\nfunction createFxNow() {\n    setTimeout(function() {\n        fxNow = undefined;\n    });\n    return ( fxNow = jQuery.now() );\n}\n\nfunction createTween( value, prop, animation ) {\n    var tween,\n        collection = ( tweeners[ prop ] || [] ).concat( tweeners[ \"*\" ] ),\n        index = 0,\n        length = collection.length;\n    for ( ; index < length; index++ ) {\n        if ( (tween = collection[ index ].call( animation, prop, value )) ) {\n\n            // we're done with this property\n            return tween;\n        }\n    }\n}\n\nfunction Animation( elem, properties, options ) {\n    var result,\n        stopped,\n        index = 0,\n        length = animationPrefilters.length,\n        deferred = jQuery.Deferred().always( function() {\n            // don't match elem in the :animated selector\n            delete tick.elem;\n        }),\n        tick = function() {\n            if ( stopped ) {\n                return false;\n            }\n            var currentTime = fxNow || createFxNow(),\n                remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),\n                // archaic crash bug won't allow us to use 1 - ( 0.5 || 0 ) (#12497)\n                temp = remaining / animation.duration || 0,\n                percent = 1 - temp,\n                index = 0,\n                length = animation.tweens.length;\n\n            for ( ; index < length ; index++ ) {\n                animation.tweens[ index ].run( percent );\n            }\n\n            deferred.notifyWith( elem, [ animation, percent, remaining ]);\n\n            if ( percent < 1 && length ) {\n                return remaining;\n            } else {\n                deferred.resolveWith( elem, [ animation ] );\n                return false;\n            }\n        },\n        animation = deferred.promise({\n            elem: elem,\n            props: jQuery.extend( {}, properties ),\n            opts: jQuery.extend( true, { specialEasing: {} }, options ),\n            originalProperties: properties,\n            originalOptions: options,\n            startTime: fxNow || createFxNow(),\n            duration: options.duration,\n            tweens: [],\n            createTween: function( prop, end ) {\n                var tween = jQuery.Tween( elem, animation.opts, prop, end,\n                        animation.opts.specialEasing[ prop ] || animation.opts.easing );\n                animation.tweens.push( tween );\n                return tween;\n            },\n            stop: function( gotoEnd ) {\n                var index = 0,\n                    // if we are going to the end, we want to run all the tweens\n                    // otherwise we skip this part\n                    length = gotoEnd ? animation.tweens.length : 0;\n                if ( stopped ) {\n                    return this;\n                }\n                stopped = true;\n                for ( ; index < length ; index++ ) {\n                    animation.tweens[ index ].run( 1 );\n                }\n\n                // resolve when we played the last frame\n                // otherwise, reject\n                if ( gotoEnd ) {\n                    deferred.resolveWith( elem, [ animation, gotoEnd ] );\n                } else {\n                    deferred.rejectWith( elem, [ animation, gotoEnd ] );\n                }\n                return this;\n            }\n        }),\n        props = animation.props;\n\n    propFilter( props, animation.opts.specialEasing );\n\n    for ( ; index < length ; index++ ) {\n        result = animationPrefilters[ index ].call( animation, elem, props, animation.opts );\n        if ( result ) {\n            return result;\n        }\n    }\n\n    jQuery.map( props, createTween, animation );\n\n    if ( jQuery.isFunction( animation.opts.start ) ) {\n        animation.opts.start.call( elem, animation );\n    }\n\n    jQuery.fx.timer(\n        jQuery.extend( tick, {\n            elem: elem,\n            anim: animation,\n            queue: animation.opts.queue\n        })\n    );\n\n    // attach callbacks from options\n    return animation.progress( animation.opts.progress )\n        .done( animation.opts.done, animation.opts.complete )\n        .fail( animation.opts.fail )\n        .always( animation.opts.always );\n}\n\nfunction propFilter( props, specialEasing ) {\n    var index, name, easing, value, hooks;\n\n    // camelCase, specialEasing and expand cssHook pass\n    for ( index in props ) {\n        name = jQuery.camelCase( index );\n        easing = specialEasing[ name ];\n        value = props[ index ];\n        if ( jQuery.isArray( value ) ) {\n            easing = value[ 1 ];\n            value = props[ index ] = value[ 0 ];\n        }\n\n        if ( index !== name ) {\n            props[ name ] = value;\n            delete props[ index ];\n        }\n\n        hooks = jQuery.cssHooks[ name ];\n        if ( hooks && \"expand\" in hooks ) {\n            value = hooks.expand( value );\n            delete props[ name ];\n\n            // not quite $.extend, this wont overwrite keys already present.\n            // also - reusing 'index' from above because we have the correct \"name\"\n            for ( index in value ) {\n                if ( !( index in props ) ) {\n                    props[ index ] = value[ index ];\n                    specialEasing[ index ] = easing;\n                }\n            }\n        } else {\n            specialEasing[ name ] = easing;\n        }\n    }\n}\n\njQuery.Animation = jQuery.extend( Animation, {\n\n    tweener: function( props, callback ) {\n        if ( jQuery.isFunction( props ) ) {\n            callback = props;\n            props = [ \"*\" ];\n        } else {\n            props = props.split(\" \");\n        }\n\n        var prop,\n            index = 0,\n            length = props.length;\n\n        for ( ; index < length ; index++ ) {\n            prop = props[ index ];\n            tweeners[ prop ] = tweeners[ prop ] || [];\n            tweeners[ prop ].unshift( callback );\n        }\n    },\n\n    prefilter: function( callback, prepend ) {\n        if ( prepend ) {\n            animationPrefilters.unshift( callback );\n        } else {\n            animationPrefilters.push( callback );\n        }\n    }\n});\n\nfunction defaultPrefilter( elem, props, opts ) {\n    /* jshint validthis: true */\n    var prop, value, toggle, tween, hooks, oldfire,\n        anim = this,\n        orig = {},\n        style = elem.style,\n        hidden = elem.nodeType && isHidden( elem ),\n        dataShow = jQuery._data( elem, \"fxshow\" );\n\n    // handle queue: false promises\n    if ( !opts.queue ) {\n        hooks = jQuery._queueHooks( elem, \"fx\" );\n        if ( hooks.unqueued == null ) {\n            hooks.unqueued = 0;\n            oldfire = hooks.empty.fire;\n            hooks.empty.fire = function() {\n                if ( !hooks.unqueued ) {\n                    oldfire();\n                }\n            };\n        }\n        hooks.unqueued++;\n\n        anim.always(function() {\n            // doing this makes sure that the complete handler will be called\n            // before this completes\n            anim.always(function() {\n                hooks.unqueued--;\n                if ( !jQuery.queue( elem, \"fx\" ).length ) {\n                    hooks.empty.fire();\n                }\n            });\n        });\n    }\n\n    // height/width overflow pass\n    if ( elem.nodeType === 1 && ( \"height\" in props || \"width\" in props ) ) {\n        // Make sure that nothing sneaks out\n        // Record all 3 overflow attributes because IE does not\n        // change the overflow attribute when overflowX and\n        // overflowY are set to the same value\n        opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];\n\n        // Set display property to inline-block for height/width\n        // animations on inline elements that are having width/height animated\n        if ( jQuery.css( elem, \"display\" ) === \"inline\" &&\n                jQuery.css( elem, \"float\" ) === \"none\" ) {\n\n            // inline-level elements accept inline-block;\n            // block-level elements need to be inline with layout\n            if ( !jQuery.support.inlineBlockNeedsLayout || css_defaultDisplay( elem.nodeName ) === \"inline\" ) {\n                style.display = \"inline-block\";\n\n            } else {\n                style.zoom = 1;\n            }\n        }\n    }\n\n    if ( opts.overflow ) {\n        style.overflow = \"hidden\";\n        if ( !jQuery.support.shrinkWrapBlocks ) {\n            anim.always(function() {\n                style.overflow = opts.overflow[ 0 ];\n                style.overflowX = opts.overflow[ 1 ];\n                style.overflowY = opts.overflow[ 2 ];\n            });\n        }\n    }\n\n\n    // show/hide pass\n    for ( prop in props ) {\n        value = props[ prop ];\n        if ( rfxtypes.exec( value ) ) {\n            delete props[ prop ];\n            toggle = toggle || value === \"toggle\";\n            if ( value === ( hidden ? \"hide\" : \"show\" ) ) {\n                continue;\n            }\n            orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );\n        }\n    }\n\n    if ( !jQuery.isEmptyObject( orig ) ) {\n        if ( dataShow ) {\n            if ( \"hidden\" in dataShow ) {\n                hidden = dataShow.hidden;\n            }\n        } else {\n            dataShow = jQuery._data( elem, \"fxshow\", {} );\n        }\n\n        // store state if its toggle - enables .stop().toggle() to \"reverse\"\n        if ( toggle ) {\n            dataShow.hidden = !hidden;\n        }\n        if ( hidden ) {\n            jQuery( elem ).show();\n        } else {\n            anim.done(function() {\n                jQuery( elem ).hide();\n            });\n        }\n        anim.done(function() {\n            var prop;\n            jQuery._removeData( elem, \"fxshow\" );\n            for ( prop in orig ) {\n                jQuery.style( elem, prop, orig[ prop ] );\n            }\n        });\n        for ( prop in orig ) {\n            tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );\n\n            if ( !( prop in dataShow ) ) {\n                dataShow[ prop ] = tween.start;\n                if ( hidden ) {\n                    tween.end = tween.start;\n                    tween.start = prop === \"width\" || prop === \"height\" ? 1 : 0;\n                }\n            }\n        }\n    }\n}\n\nfunction Tween( elem, options, prop, end, easing ) {\n    return new Tween.prototype.init( elem, options, prop, end, easing );\n}\njQuery.Tween = Tween;\n\nTween.prototype = {\n    constructor: Tween,\n    init: function( elem, options, prop, end, easing, unit ) {\n        this.elem = elem;\n        this.prop = prop;\n        this.easing = easing || \"swing\";\n        this.options = options;\n        this.start = this.now = this.cur();\n        this.end = end;\n        this.unit = unit || ( jQuery.cssNumber[ prop ] ? \"\" : \"px\" );\n    },\n    cur: function() {\n        var hooks = Tween.propHooks[ this.prop ];\n\n        return hooks && hooks.get ?\n            hooks.get( this ) :\n            Tween.propHooks._default.get( this );\n    },\n    run: function( percent ) {\n        var eased,\n            hooks = Tween.propHooks[ this.prop ];\n\n        if ( this.options.duration ) {\n            this.pos = eased = jQuery.easing[ this.easing ](\n                percent, this.options.duration * percent, 0, 1, this.options.duration\n            );\n        } else {\n            this.pos = eased = percent;\n        }\n        this.now = ( this.end - this.start ) * eased + this.start;\n\n        if ( this.options.step ) {\n            this.options.step.call( this.elem, this.now, this );\n        }\n\n        if ( hooks && hooks.set ) {\n            hooks.set( this );\n        } else {\n            Tween.propHooks._default.set( this );\n        }\n        return this;\n    }\n};\n\nTween.prototype.init.prototype = Tween.prototype;\n\nTween.propHooks = {\n    _default: {\n        get: function( tween ) {\n            var result;\n\n            if ( tween.elem[ tween.prop ] != null &&\n                (!tween.elem.style || tween.elem.style[ tween.prop ] == null) ) {\n                return tween.elem[ tween.prop ];\n            }\n\n            // passing an empty string as a 3rd parameter to .css will automatically\n            // attempt a parseFloat and fallback to a string if the parse fails\n            // so, simple values such as \"10px\" are parsed to Float.\n            // complex values such as \"rotate(1rad)\" are returned as is.\n            result = jQuery.css( tween.elem, tween.prop, \"\" );\n            // Empty strings, null, undefined and \"auto\" are converted to 0.\n            return !result || result === \"auto\" ? 0 : result;\n        },\n        set: function( tween ) {\n            // use step hook for back compat - use cssHook if its there - use .style if its\n            // available and use plain properties where available\n            if ( jQuery.fx.step[ tween.prop ] ) {\n                jQuery.fx.step[ tween.prop ]( tween );\n            } else if ( tween.elem.style && ( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null || jQuery.cssHooks[ tween.prop ] ) ) {\n                jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );\n            } else {\n                tween.elem[ tween.prop ] = tween.now;\n            }\n        }\n    }\n};\n\n// Support: IE <=9\n// Panic based approach to setting things on disconnected nodes\n\nTween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {\n    set: function( tween ) {\n        if ( tween.elem.nodeType && tween.elem.parentNode ) {\n            tween.elem[ tween.prop ] = tween.now;\n        }\n    }\n};\n\njQuery.each([ \"toggle\", \"show\", \"hide\" ], function( i, name ) {\n    var cssFn = jQuery.fn[ name ];\n    jQuery.fn[ name ] = function( speed, easing, callback ) {\n        return speed == null || typeof speed === \"boolean\" ?\n            cssFn.apply( this, arguments ) :\n            this.animate( genFx( name, true ), speed, easing, callback );\n    };\n});\n\njQuery.fn.extend({\n    fadeTo: function( speed, to, easing, callback ) {\n\n        // show any hidden elements after setting opacity to 0\n        return this.filter( isHidden ).css( \"opacity\", 0 ).show()\n\n            // animate to the value specified\n            .end().animate({ opacity: to }, speed, easing, callback );\n    },\n    animate: function( prop, speed, easing, callback ) {\n        var empty = jQuery.isEmptyObject( prop ),\n            optall = jQuery.speed( speed, easing, callback ),\n            doAnimation = function() {\n                // Operate on a copy of prop so per-property easing won't be lost\n                var anim = Animation( this, jQuery.extend( {}, prop ), optall );\n\n                // Empty animations, or finishing resolves immediately\n                if ( empty || jQuery._data( this, \"finish\" ) ) {\n                    anim.stop( true );\n                }\n            };\n            doAnimation.finish = doAnimation;\n\n        return empty || optall.queue === false ?\n            this.each( doAnimation ) :\n            this.queue( optall.queue, doAnimation );\n    },\n    stop: function( type, clearQueue, gotoEnd ) {\n        var stopQueue = function( hooks ) {\n            var stop = hooks.stop;\n            delete hooks.stop;\n            stop( gotoEnd );\n        };\n\n        if ( typeof type !== \"string\" ) {\n            gotoEnd = clearQueue;\n            clearQueue = type;\n            type = undefined;\n        }\n        if ( clearQueue && type !== false ) {\n            this.queue( type || \"fx\", [] );\n        }\n\n        return this.each(function() {\n            var dequeue = true,\n                index = type != null && type + \"queueHooks\",\n                timers = jQuery.timers,\n                data = jQuery._data( this );\n\n            if ( index ) {\n                if ( data[ index ] && data[ index ].stop ) {\n                    stopQueue( data[ index ] );\n                }\n            } else {\n                for ( index in data ) {\n                    if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {\n                        stopQueue( data[ index ] );\n                    }\n                }\n            }\n\n            for ( index = timers.length; index--; ) {\n                if ( timers[ index ].elem === this && (type == null || timers[ index ].queue === type) ) {\n                    timers[ index ].anim.stop( gotoEnd );\n                    dequeue = false;\n                    timers.splice( index, 1 );\n                }\n            }\n\n            // start the next in the queue if the last step wasn't forced\n            // timers currently will call their complete callbacks, which will dequeue\n            // but only if they were gotoEnd\n            if ( dequeue || !gotoEnd ) {\n                jQuery.dequeue( this, type );\n            }\n        });\n    },\n    finish: function( type ) {\n        if ( type !== false ) {\n            type = type || \"fx\";\n        }\n        return this.each(function() {\n            var index,\n                data = jQuery._data( this ),\n                queue = data[ type + \"queue\" ],\n                hooks = data[ type + \"queueHooks\" ],\n                timers = jQuery.timers,\n                length = queue ? queue.length : 0;\n\n            // enable finishing flag on private data\n            data.finish = true;\n\n            // empty the queue first\n            jQuery.queue( this, type, [] );\n\n            if ( hooks && hooks.stop ) {\n                hooks.stop.call( this, true );\n            }\n\n            // look for any active animations, and finish them\n            for ( index = timers.length; index--; ) {\n                if ( timers[ index ].elem === this && timers[ index ].queue === type ) {\n                    timers[ index ].anim.stop( true );\n                    timers.splice( index, 1 );\n                }\n            }\n\n            // look for any animations in the old queue and finish them\n            for ( index = 0; index < length; index++ ) {\n                if ( queue[ index ] && queue[ index ].finish ) {\n                    queue[ index ].finish.call( this );\n                }\n            }\n\n            // turn off finishing flag\n            delete data.finish;\n        });\n    }\n});\n\n// Generate parameters to create a standard animation\nfunction genFx( type, includeWidth ) {\n    var which,\n        attrs = { height: type },\n        i = 0;\n\n    // if we include width, step value is 1 to do all cssExpand values,\n    // if we don't include width, step value is 2 to skip over Left and Right\n    includeWidth = includeWidth? 1 : 0;\n    for( ; i < 4 ; i += 2 - includeWidth ) {\n        which = cssExpand[ i ];\n        attrs[ \"margin\" + which ] = attrs[ \"padding\" + which ] = type;\n    }\n\n    if ( includeWidth ) {\n        attrs.opacity = attrs.width = type;\n    }\n\n    return attrs;\n}\n\n// Generate shortcuts for custom animations\njQuery.each({\n    slideDown: genFx(\"show\"),\n    slideUp: genFx(\"hide\"),\n    slideToggle: genFx(\"toggle\"),\n    fadeIn: { opacity: \"show\" },\n    fadeOut: { opacity: \"hide\" },\n    fadeToggle: { opacity: \"toggle\" }\n}, function( name, props ) {\n    jQuery.fn[ name ] = function( speed, easing, callback ) {\n        return this.animate( props, speed, easing, callback );\n    };\n});\n\njQuery.speed = function( speed, easing, fn ) {\n    var opt = speed && typeof speed === \"object\" ? jQuery.extend( {}, speed ) : {\n        complete: fn || !fn && easing ||\n            jQuery.isFunction( speed ) && speed,\n        duration: speed,\n        easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing\n    };\n\n    opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === \"number\" ? opt.duration :\n        opt.duration in jQuery.fx.speeds ? jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;\n\n    // normalize opt.queue - true/undefined/null -> \"fx\"\n    if ( opt.queue == null || opt.queue === true ) {\n        opt.queue = \"fx\";\n    }\n\n    // Queueing\n    opt.old = opt.complete;\n\n    opt.complete = function() {\n        if ( jQuery.isFunction( opt.old ) ) {\n            opt.old.call( this );\n        }\n\n        if ( opt.queue ) {\n            jQuery.dequeue( this, opt.queue );\n        }\n    };\n\n    return opt;\n};\n\njQuery.easing = {\n    linear: function( p ) {\n        return p;\n    },\n    swing: function( p ) {\n        return 0.5 - Math.cos( p*Math.PI ) / 2;\n    }\n};\n\njQuery.timers = [];\njQuery.fx = Tween.prototype.init;\njQuery.fx.tick = function() {\n    var timer,\n        timers = jQuery.timers,\n        i = 0;\n\n    fxNow = jQuery.now();\n\n    for ( ; i < timers.length; i++ ) {\n        timer = timers[ i ];\n        // Checks the timer has not already been removed\n        if ( !timer() && timers[ i ] === timer ) {\n            timers.splice( i--, 1 );\n        }\n    }\n\n    if ( !timers.length ) {\n        jQuery.fx.stop();\n    }\n    fxNow = undefined;\n};\n\njQuery.fx.timer = function( timer ) {\n    if ( timer() && jQuery.timers.push( timer ) ) {\n        jQuery.fx.start();\n    }\n};\n\njQuery.fx.interval = 13;\n\njQuery.fx.start = function() {\n    if ( !timerId ) {\n        timerId = setInterval( jQuery.fx.tick, jQuery.fx.interval );\n    }\n};\n\njQuery.fx.stop = function() {\n    clearInterval( timerId );\n    timerId = null;\n};\n\njQuery.fx.speeds = {\n    slow: 600,\n    fast: 200,\n    // Default speed\n    _default: 400\n};\n\n// Back Compat <1.8 extension point\njQuery.fx.step = {};\n\nif ( jQuery.expr && jQuery.expr.filters ) {\n    jQuery.expr.filters.animated = function( elem ) {\n        return jQuery.grep(jQuery.timers, function( fn ) {\n            return elem === fn.elem;\n        }).length;\n    };\n}\njQuery.fn.offset = function( options ) {\n    if ( arguments.length ) {\n        return options === undefined ?\n            this :\n            this.each(function( i ) {\n                jQuery.offset.setOffset( this, options, i );\n            });\n    }\n\n    var docElem, win,\n        box = { top: 0, left: 0 },\n        elem = this[ 0 ],\n        doc = elem && elem.ownerDocument;\n\n    if ( !doc ) {\n        return;\n    }\n\n    docElem = doc.documentElement;\n\n    // Make sure it's not a disconnected DOM node\n    if ( !jQuery.contains( docElem, elem ) ) {\n        return box;\n    }\n\n    // If we don't have gBCR, just use 0,0 rather than error\n    // BlackBerry 5, iOS 3 (original iPhone)\n    if ( typeof elem.getBoundingClientRect !== core_strundefined ) {\n        box = elem.getBoundingClientRect();\n    }\n    win = getWindow( doc );\n    return {\n        top: box.top  + ( win.pageYOffset || docElem.scrollTop )  - ( docElem.clientTop  || 0 ),\n        left: box.left + ( win.pageXOffset || docElem.scrollLeft ) - ( docElem.clientLeft || 0 )\n    };\n};\n\njQuery.offset = {\n\n    setOffset: function( elem, options, i ) {\n        var position = jQuery.css( elem, \"position\" );\n\n        // set position first, in-case top/left are set even on static elem\n        if ( position === \"static\" ) {\n            elem.style.position = \"relative\";\n        }\n\n        var curElem = jQuery( elem ),\n            curOffset = curElem.offset(),\n            curCSSTop = jQuery.css( elem, \"top\" ),\n            curCSSLeft = jQuery.css( elem, \"left\" ),\n            calculatePosition = ( position === \"absolute\" || position === \"fixed\" ) && jQuery.inArray(\"auto\", [curCSSTop, curCSSLeft]) > -1,\n            props = {}, curPosition = {}, curTop, curLeft;\n\n        // need to be able to calculate position if either top or left is auto and position is either absolute or fixed\n        if ( calculatePosition ) {\n            curPosition = curElem.position();\n            curTop = curPosition.top;\n            curLeft = curPosition.left;\n        } else {\n            curTop = parseFloat( curCSSTop ) || 0;\n            curLeft = parseFloat( curCSSLeft ) || 0;\n        }\n\n        if ( jQuery.isFunction( options ) ) {\n            options = options.call( elem, i, curOffset );\n        }\n\n        if ( options.top != null ) {\n            props.top = ( options.top - curOffset.top ) + curTop;\n        }\n        if ( options.left != null ) {\n            props.left = ( options.left - curOffset.left ) + curLeft;\n        }\n\n        if ( \"using\" in options ) {\n            options.using.call( elem, props );\n        } else {\n            curElem.css( props );\n        }\n    }\n};\n\n\njQuery.fn.extend({\n\n    position: function() {\n        if ( !this[ 0 ] ) {\n            return;\n        }\n\n        var offsetParent, offset,\n            parentOffset = { top: 0, left: 0 },\n            elem = this[ 0 ];\n\n        // fixed elements are offset from window (parentOffset = {top:0, left: 0}, because it is it's only offset parent\n        if ( jQuery.css( elem, \"position\" ) === \"fixed\" ) {\n            // we assume that getBoundingClientRect is available when computed position is fixed\n            offset = elem.getBoundingClientRect();\n        } else {\n            // Get *real* offsetParent\n            offsetParent = this.offsetParent();\n\n            // Get correct offsets\n            offset = this.offset();\n            if ( !jQuery.nodeName( offsetParent[ 0 ], \"html\" ) ) {\n                parentOffset = offsetParent.offset();\n            }\n\n            // Add offsetParent borders\n            parentOffset.top  += jQuery.css( offsetParent[ 0 ], \"borderTopWidth\", true );\n            parentOffset.left += jQuery.css( offsetParent[ 0 ], \"borderLeftWidth\", true );\n        }\n\n        // Subtract parent offsets and element margins\n        // note: when an element has margin: auto the offsetLeft and marginLeft\n        // are the same in Safari causing offset.left to incorrectly be 0\n        return {\n            top:  offset.top  - parentOffset.top - jQuery.css( elem, \"marginTop\", true ),\n            left: offset.left - parentOffset.left - jQuery.css( elem, \"marginLeft\", true)\n        };\n    },\n\n    offsetParent: function() {\n        return this.map(function() {\n            var offsetParent = this.offsetParent || docElem;\n            while ( offsetParent && ( !jQuery.nodeName( offsetParent, \"html\" ) && jQuery.css( offsetParent, \"position\") === \"static\" ) ) {\n                offsetParent = offsetParent.offsetParent;\n            }\n            return offsetParent || docElem;\n        });\n    }\n});\n\n\n// Create scrollLeft and scrollTop methods\njQuery.each( {scrollLeft: \"pageXOffset\", scrollTop: \"pageYOffset\"}, function( method, prop ) {\n    var top = /Y/.test( prop );\n\n    jQuery.fn[ method ] = function( val ) {\n        return jQuery.access( this, function( elem, method, val ) {\n            var win = getWindow( elem );\n\n            if ( val === undefined ) {\n                return win ? (prop in win) ? win[ prop ] :\n                    win.document.documentElement[ method ] :\n                    elem[ method ];\n            }\n\n            if ( win ) {\n                win.scrollTo(\n                    !top ? val : jQuery( win ).scrollLeft(),\n                    top ? val : jQuery( win ).scrollTop()\n                );\n\n            } else {\n                elem[ method ] = val;\n            }\n        }, method, val, arguments.length, null );\n    };\n});\n\nfunction getWindow( elem ) {\n    return jQuery.isWindow( elem ) ?\n        elem :\n        elem.nodeType === 9 ?\n            elem.defaultView || elem.parentWindow :\n            false;\n}\n// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods\njQuery.each( { Height: \"height\", Width: \"width\" }, function( name, type ) {\n    jQuery.each( { padding: \"inner\" + name, content: type, \"\": \"outer\" + name }, function( defaultExtra, funcName ) {\n        // margin is only for outerHeight, outerWidth\n        jQuery.fn[ funcName ] = function( margin, value ) {\n            var chainable = arguments.length && ( defaultExtra || typeof margin !== \"boolean\" ),\n                extra = defaultExtra || ( margin === true || value === true ? \"margin\" : \"border\" );\n\n            return jQuery.access( this, function( elem, type, value ) {\n                var doc;\n\n                if ( jQuery.isWindow( elem ) ) {\n                    // As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there\n                    // isn't a whole lot we can do. See pull request at this URL for discussion:\n                    // https://github.com/jquery/jquery/pull/764\n                    return elem.document.documentElement[ \"client\" + name ];\n                }\n\n                // Get document width or height\n                if ( elem.nodeType === 9 ) {\n                    doc = elem.documentElement;\n\n                    // Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height], whichever is greatest\n                    // unfortunately, this causes bug #3838 in IE6/8 only, but there is currently no good, small way to fix it.\n                    return Math.max(\n                        elem.body[ \"scroll\" + name ], doc[ \"scroll\" + name ],\n                        elem.body[ \"offset\" + name ], doc[ \"offset\" + name ],\n                        doc[ \"client\" + name ]\n                    );\n                }\n\n                return value === undefined ?\n                    // Get width or height on the element, requesting but not forcing parseFloat\n                    jQuery.css( elem, type, extra ) :\n\n                    // Set width or height on the element\n                    jQuery.style( elem, type, value, extra );\n            }, type, chainable ? margin : undefined, chainable, null );\n        };\n    });\n});\n// Limit scope pollution from any deprecated API\n// (function() {\n\n// The number of elements contained in the matched element set\njQuery.fn.size = function() {\n    return this.length;\n};\n\njQuery.fn.andSelf = jQuery.fn.addBack;\n\n// })();\nif ( typeof module === \"object\" && module && typeof module.exports === \"object\" ) {\n    // Expose jQuery as module.exports in loaders that implement the Node\n    // module pattern (including browserify). Do not create the global, since\n    // the user will be storing it themselves locally, and globals are frowned\n    // upon in the Node module world.\n    module.exports = jQuery;\n} else {\n    // Otherwise expose jQuery to the global object as usual\n    window.jQuery = window.$ = jQuery;\n\n    // Register as a named AMD module, since jQuery can be concatenated with other\n    // files that may use define, but not via a proper concatenation script that\n    // understands anonymous AMD modules. A named AMD is safest and most robust\n    // way to register. Lowercase jquery is used because AMD module names are\n    // derived from file names, and jQuery is normally delivered in a lowercase\n    // file name. Do this after creating the global so that if an AMD module wants\n    // to call noConflict to hide this version of jQuery, it will work.\n    if ( typeof define === \"function\" && define.amd ) {\n        define( \"jquery\", [], function () { return jQuery; } );\n    }\n}\n\n})( window );","\ndefine('../dep/jqueryPrivate',['jquery'], function ($) {\n    return $.noConflict( true );\n});","\n/**\n * @license AngularJS v1.2.0-rc.2\n * (c) 2010-2012 Google, Inc. http://angularjs.org\n * License: MIT\n */\n(function(window, document, undefined) {'use strict';\n\n/**\n * @description\n *\n * This object provides a utility for producing rich Error messages within\n * Angular. It can be called as follows:\n *\n * var exampleMinErr = minErr('example');\n * throw exampleMinErr('one', 'This {0} is {1}', foo, bar);\n *\n * The above creates an instance of minErr in the example namespace. The\n * resulting error will have a namespaced error code of example.one.  The\n * resulting error will replace {0} with the value of foo, and {1} with the\n * value of bar. The object is not restricted in the number of arguments it can\n * take.\n *\n * If fewer arguments are specified than necessary for interpolation, the extra\n * interpolation markers will be preserved in the final string.\n *\n * Since data will be parsed statically during a build step, some restrictions\n * are applied with respect to how minErr instances are created and called.\n * Instances should have names of the form namespaceMinErr for a minErr created\n * using minErr('namespace') . Error codes, namespaces and template strings\n * should all be static strings, not variables or general expressions.\n *\n * @param {string} module The namespace to use for the new minErr instance.\n * @returns {function(string, string, ...): Error} instance\n */\n\nfunction minErr(module) {\n  return function () {\n    var code = arguments[0],\n      prefix = '[' + (module ? module + ':' : '') + code + '] ',\n      template = arguments[1],\n      templateArgs = arguments,\n      stringify = function (obj) {\n        if (isFunction(obj)) {\n          return obj.toString().replace(/ \\{[\\s\\S]*$/, '');\n        } else if (isUndefined(obj)) {\n          return 'undefined';\n        } else if (!isString(obj)) {\n          return JSON.stringify(obj);\n        }\n        return obj;\n      },\n      message, i;\n\n    message = prefix + template.replace(/\\{\\d+\\}/g, function (match) {\n      var index = +match.slice(1, -1), arg;\n\n      if (index + 2 < templateArgs.length) {\n        arg = templateArgs[index + 2];\n        if (isFunction(arg)) {\n          return arg.toString().replace(/ ?\\{[\\s\\S]*$/, '');\n        } else if (isUndefined(arg)) {\n          return 'undefined';\n        } else if (!isString(arg)) {\n          return toJson(arg);\n        }\n        return arg;\n      }\n      return match;\n    });\n\n    message = message + '\\nhttp://errors.angularjs.org/' + version.full + '/' +\n      (module ? module + '/' : '') + code;\n    for (i = 2; i < arguments.length; i++) {\n      message = message + (i == 2 ? '?' : '&') + 'p' + (i-2) + '=' +\n        encodeURIComponent(stringify(arguments[i]));\n    }\n\n    return new Error(message);\n  };\n}\n\n////////////////////////////////////\n\n/**\n * hasOwnProperty may be overwritten by a property of the same name, or entirely\n * absent from an object that does not inherit Object.prototype; this copy is\n * used instead\n */\nvar hasOwnPropertyFn = Object.prototype.hasOwnProperty;\nvar hasOwnPropertyLocal = function(obj, key) {\n  return hasOwnPropertyFn.call(obj, key);\n};\n\n/**\n * @ngdoc function\n * @name angular.lowercase\n * @function\n *\n * @description Converts the specified string to lowercase.\n * @param {string} string String to be converted to lowercase.\n * @returns {string} Lowercased string.\n */\nvar lowercase = function(string){return isString(string) ? string.toLowerCase() : string;};\n\n\n/**\n * @ngdoc function\n * @name angular.uppercase\n * @function\n *\n * @description Converts the specified string to uppercase.\n * @param {string} string String to be converted to uppercase.\n * @returns {string} Uppercased string.\n */\nvar uppercase = function(string){return isString(string) ? string.toUpperCase() : string;};\n\n\nvar manualLowercase = function(s) {\n  return isString(s)\n      ? s.replace(/[A-Z]/g, function(ch) {return String.fromCharCode(ch.charCodeAt(0) | 32);})\n      : s;\n};\nvar manualUppercase = function(s) {\n  return isString(s)\n      ? s.replace(/[a-z]/g, function(ch) {return String.fromCharCode(ch.charCodeAt(0) & ~32);})\n      : s;\n};\n\n\n// String#toLowerCase and String#toUpperCase don't produce correct results in browsers with Turkish\n// locale, for this reason we need to detect this case and redefine lowercase/uppercase methods\n// with correct but slower alternatives.\nif ('i' !== 'I'.toLowerCase()) {\n  lowercase = manualLowercase;\n  uppercase = manualUppercase;\n}\n\n\nvar /** holds major version number for IE or NaN for real browsers */\n    msie,\n    jqLite,           // delay binding since jQuery could be loaded after us.\n    jQuery,           // delay binding\n    slice             = [].slice,\n    push              = [].push,\n    toString          = Object.prototype.toString,\n    ngMinErr          = minErr('ng'),\n\n\n    _angular          = window.angular,\n    /** @name angular */\n    angular           = window.angular || (window.angular = {}),\n    angularModule,\n    nodeName_,\n    uid               = ['0', '0', '0'];\n\n/**\n * IE 11 changed the format of the UserAgent string.\n * See http://msdn.microsoft.com/en-us/library/ms537503.aspx\n */\nmsie = int((/msie (\\d+)/.exec(lowercase(navigator.userAgent)) || [])[1]);\nif (isNaN(msie)) {\n  msie = int((/trident\\/.*; rv:(\\d+)/.exec(lowercase(navigator.userAgent)) || [])[1]);\n}\n\n\n/**\n * @private\n * @param {*} obj\n * @return {boolean} Returns true if `obj` is an array or array-like object (NodeList, Arguments, ...)\n */\nfunction isArrayLike(obj) {\n  if (obj == null || isWindow(obj)) {\n    return false;\n  }\n  \n  var length = obj.length;\n\n  if (obj.nodeType === 1 && length) {\n    return true;\n  }\n\n  return isArray(obj) || !isFunction(obj) && (\n    length === 0 || typeof length === \"number\" && length > 0 && (length - 1) in obj\n  );\n}\n\n/**\n * @ngdoc function\n * @name angular.forEach\n * @function\n *\n * @description\n * Invokes the `iterator` function once for each item in `obj` collection, which can be either an\n * object or an array. The `iterator` function is invoked with `iterator(value, key)`, where `value`\n * is the value of an object property or an array element and `key` is the object property key or\n * array element index. Specifying a `context` for the function is optional.\n *\n * Note: this function was previously known as `angular.foreach`.\n *\n   <pre>\n     var values = {name: 'misko', gender: 'male'};\n     var log = [];\n     angular.forEach(values, function(value, key){\n       this.push(key + ': ' + value);\n     }, log);\n     expect(log).toEqual(['name: misko', 'gender:male']);\n   </pre>\n *\n * @param {Object|Array} obj Object to iterate over.\n * @param {Function} iterator Iterator function.\n * @param {Object=} context Object to become context (`this`) for the iterator function.\n * @returns {Object|Array} Reference to `obj`.\n */\nfunction forEach(obj, iterator, context) {\n  var key;\n  if (obj) {\n    if (isFunction(obj)){\n      for (key in obj) {\n        if (key != 'prototype' && key != 'length' && key != 'name' && obj.hasOwnProperty(key)) {\n          iterator.call(context, obj[key], key);\n        }\n      }\n    } else if (obj.forEach && obj.forEach !== forEach) {\n      obj.forEach(iterator, context);\n    } else if (isArrayLike(obj)) {\n      for (key = 0; key < obj.length; key++)\n        iterator.call(context, obj[key], key);\n    } else {\n      for (key in obj) {\n        if (obj.hasOwnProperty(key)) {\n          iterator.call(context, obj[key], key);\n        }\n      }\n    }\n  }\n  return obj;\n}\n\nfunction sortedKeys(obj) {\n  var keys = [];\n  for (var key in obj) {\n    if (obj.hasOwnProperty(key)) {\n      keys.push(key);\n    }\n  }\n  return keys.sort();\n}\n\nfunction forEachSorted(obj, iterator, context) {\n  var keys = sortedKeys(obj);\n  for ( var i = 0; i < keys.length; i++) {\n    iterator.call(context, obj[keys[i]], keys[i]);\n  }\n  return keys;\n}\n\n\n/**\n * when using forEach the params are value, key, but it is often useful to have key, value.\n * @param {function(string, *)} iteratorFn\n * @returns {function(*, string)}\n */\nfunction reverseParams(iteratorFn) {\n  return function(value, key) { iteratorFn(key, value) };\n}\n\n/**\n * A consistent way of creating unique IDs in angular. The ID is a sequence of alpha numeric\n * characters such as '012ABC'. The reason why we are not using simply a number counter is that\n * the number string gets longer over time, and it can also overflow, where as the nextId\n * will grow much slower, it is a string, and it will never overflow.\n *\n * @returns an unique alpha-numeric string\n */\nfunction nextUid() {\n  var index = uid.length;\n  var digit;\n\n  while(index) {\n    index--;\n    digit = uid[index].charCodeAt(0);\n    if (digit == 57 /*'9'*/) {\n      uid[index] = 'A';\n      return uid.join('');\n    }\n    if (digit == 90  /*'Z'*/) {\n      uid[index] = '0';\n    } else {\n      uid[index] = String.fromCharCode(digit + 1);\n      return uid.join('');\n    }\n  }\n  uid.unshift('0');\n  return uid.join('');\n}\n\n\n/**\n * Set or clear the hashkey for an object.\n * @param obj object\n * @param h the hashkey (!truthy to delete the hashkey)\n */\nfunction setHashKey(obj, h) {\n  if (h) {\n    obj.$$hashKey = h;\n  }\n  else {\n    delete obj.$$hashKey;\n  }\n}\n\n/**\n * @ngdoc function\n * @name angular.extend\n * @function\n *\n * @description\n * Extends the destination object `dst` by copying all of the properties from the `src` object(s)\n * to `dst`. You can specify multiple `src` objects.\n *\n * @param {Object} dst Destination object.\n * @param {...Object} src Source object(s).\n * @returns {Object} Reference to `dst`.\n */\nfunction extend(dst) {\n  var h = dst.$$hashKey;\n  forEach(arguments, function(obj){\n    if (obj !== dst) {\n      forEach(obj, function(value, key){\n        dst[key] = value;\n      });\n    }\n  });\n\n  setHashKey(dst,h);\n  return dst;\n}\n\nfunction int(str) {\n  return parseInt(str, 10);\n}\n\n\nfunction inherit(parent, extra) {\n  return extend(new (extend(function() {}, {prototype:parent}))(), extra);\n}\n\n/**\n * @ngdoc function\n * @name angular.noop\n * @function\n *\n * @description\n * A function that performs no operations. This function can be useful when writing code in the\n * functional style.\n   <pre>\n     function foo(callback) {\n       var result = calculateResult();\n       (callback || angular.noop)(result);\n     }\n   </pre>\n */\nfunction noop() {}\nnoop.$inject = [];\n\n\n/**\n * @ngdoc function\n * @name angular.identity\n * @function\n *\n * @description\n * A function that returns its first argument. This function is useful when writing code in the\n * functional style.\n *\n   <pre>\n     function transformer(transformationFn, value) {\n       return (transformationFn || angular.identity)(value);\n     };\n   </pre>\n */\nfunction identity($) {return $;}\nidentity.$inject = [];\n\n\nfunction valueFn(value) {return function() {return value;};}\n\n/**\n * @ngdoc function\n * @name angular.isUndefined\n * @function\n *\n * @description\n * Determines if a reference is undefined.\n *\n * @param {*} value Reference to check.\n * @returns {boolean} True if `value` is undefined.\n */\nfunction isUndefined(value){return typeof value == 'undefined';}\n\n\n/**\n * @ngdoc function\n * @name angular.isDefined\n * @function\n *\n * @description\n * Determines if a reference is defined.\n *\n * @param {*} value Reference to check.\n * @returns {boolean} True if `value` is defined.\n */\nfunction isDefined(value){return typeof value != 'undefined';}\n\n\n/**\n * @ngdoc function\n * @name angular.isObject\n * @function\n *\n * @description\n * Determines if a reference is an `Object`. Unlike `typeof` in JavaScript, `null`s are not\n * considered to be objects.\n *\n * @param {*} value Reference to check.\n * @returns {boolean} True if `value` is an `Object` but not `null`.\n */\nfunction isObject(value){return value != null && typeof value == 'object';}\n\n\n/**\n * @ngdoc function\n * @name angular.isString\n * @function\n *\n * @description\n * Determines if a reference is a `String`.\n *\n * @param {*} value Reference to check.\n * @returns {boolean} True if `value` is a `String`.\n */\nfunction isString(value){return typeof value == 'string';}\n\n\n/**\n * @ngdoc function\n * @name angular.isNumber\n * @function\n *\n * @description\n * Determines if a reference is a `Number`.\n *\n * @param {*} value Reference to check.\n * @returns {boolean} True if `value` is a `Number`.\n */\nfunction isNumber(value){return typeof value == 'number';}\n\n\n/**\n * @ngdoc function\n * @name angular.isDate\n * @function\n *\n * @description\n * Determines if a value is a date.\n *\n * @param {*} value Reference to check.\n * @returns {boolean} True if `value` is a `Date`.\n */\nfunction isDate(value){\n  return toString.apply(value) == '[object Date]';\n}\n\n\n/**\n * @ngdoc function\n * @name angular.isArray\n * @function\n *\n * @description\n * Determines if a reference is an `Array`.\n *\n * @param {*} value Reference to check.\n * @returns {boolean} True if `value` is an `Array`.\n */\nfunction isArray(value) {\n  return toString.apply(value) == '[object Array]';\n}\n\n\n/**\n * @ngdoc function\n * @name angular.isFunction\n * @function\n *\n * @description\n * Determines if a reference is a `Function`.\n *\n * @param {*} value Reference to check.\n * @returns {boolean} True if `value` is a `Function`.\n */\nfunction isFunction(value){return typeof value == 'function';}\n\n\n/**\n * Determines if a value is a regular expression object.\n *\n * @private\n * @param {*} value Reference to check.\n * @returns {boolean} True if `value` is a `RegExp`.\n */\nfunction isRegExp(value) {\n  return toString.apply(value) == '[object RegExp]';\n}\n\n\n/**\n * Checks if `obj` is a window object.\n *\n * @private\n * @param {*} obj Object to check\n * @returns {boolean} True if `obj` is a window obj.\n */\nfunction isWindow(obj) {\n  return obj && obj.document && obj.location && obj.alert && obj.setInterval;\n}\n\n\nfunction isScope(obj) {\n  return obj && obj.$evalAsync && obj.$watch;\n}\n\n\nfunction isFile(obj) {\n  return toString.apply(obj) === '[object File]';\n}\n\n\nfunction isBoolean(value) {\n  return typeof value == 'boolean';\n}\n\n\nvar trim = (function() {\n  // native trim is way faster: http://jsperf.com/angular-trim-test\n  // but IE doesn't have it... :-(\n  // TODO: we should move this into IE/ES5 polyfill\n  if (!String.prototype.trim) {\n    return function(value) {\n      return isString(value) ? value.replace(/^\\s*/, '').replace(/\\s*$/, '') : value;\n    };\n  }\n  return function(value) {\n    return isString(value) ? value.trim() : value;\n  };\n})();\n\n\n/**\n * @ngdoc function\n * @name angular.isElement\n * @function\n *\n * @description\n * Determines if a reference is a DOM element (or wrapped jQuery element).\n *\n * @param {*} value Reference to check.\n * @returns {boolean} True if `value` is a DOM element (or wrapped jQuery element).\n */\nfunction isElement(node) {\n  return node &&\n    (node.nodeName  // we are a direct element\n    || (node.on && node.find));  // we have an on and find method part of jQuery API\n}\n\n/**\n * @param str 'key1,key2,...'\n * @returns {object} in the form of {key1:true, key2:true, ...}\n */\nfunction makeMap(str){\n  var obj = {}, items = str.split(\",\"), i;\n  for ( i = 0; i < items.length; i++ )\n    obj[ items[i] ] = true;\n  return obj;\n}\n\n\nif (msie < 9) {\n  nodeName_ = function(element) {\n    element = element.nodeName ? element : element[0];\n    return (element.scopeName && element.scopeName != 'HTML')\n      ? uppercase(element.scopeName + ':' + element.nodeName) : element.nodeName;\n  };\n} else {\n  nodeName_ = function(element) {\n    return element.nodeName ? element.nodeName : element[0].nodeName;\n  };\n}\n\n\nfunction map(obj, iterator, context) {\n  var results = [];\n  forEach(obj, function(value, index, list) {\n    results.push(iterator.call(context, value, index, list));\n  });\n  return results;\n}\n\n\n/**\n * @description\n * Determines the number of elements in an array, the number of properties an object has, or\n * the length of a string.\n *\n * Note: This function is used to augment the Object type in Angular expressions. See\n * {@link angular.Object} for more information about Angular arrays.\n *\n * @param {Object|Array|string} obj Object, array, or string to inspect.\n * @param {boolean} [ownPropsOnly=false] Count only \"own\" properties in an object\n * @returns {number} The size of `obj` or `0` if `obj` is neither an object nor an array.\n */\nfunction size(obj, ownPropsOnly) {\n  var size = 0, key;\n\n  if (isArray(obj) || isString(obj)) {\n    return obj.length;\n  } else if (isObject(obj)){\n    for (key in obj)\n      if (!ownPropsOnly || obj.hasOwnProperty(key))\n        size++;\n  }\n\n  return size;\n}\n\n\nfunction includes(array, obj) {\n  return indexOf(array, obj) != -1;\n}\n\nfunction indexOf(array, obj) {\n  if (array.indexOf) return array.indexOf(obj);\n\n  for ( var i = 0; i < array.length; i++) {\n    if (obj === array[i]) return i;\n  }\n  return -1;\n}\n\nfunction arrayRemove(array, value) {\n  var index = indexOf(array, value);\n  if (index >=0)\n    array.splice(index, 1);\n  return value;\n}\n\nfunction isLeafNode (node) {\n  if (node) {\n    switch (node.nodeName) {\n    case \"OPTION\":\n    case \"PRE\":\n    case \"TITLE\":\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * @ngdoc function\n * @name angular.copy\n * @function\n *\n * @description\n * Creates a deep copy of `source`, which should be an object or an array.\n *\n * * If no destination is supplied, a copy of the object or array is created.\n * * If a destination is provided, all of its elements (for array) or properties (for objects)\n *   are deleted and then all elements/properties from the source are copied to it.\n * * If  `source` is not an object or array, `source` is returned.\n *\n * Note: this function is used to augment the Object type in Angular expressions. See\n * {@link ng.$filter} for more information about Angular arrays.\n *\n * @param {*} source The source that will be used to make a copy.\n *                   Can be any type, including primitives, `null`, and `undefined`.\n * @param {(Object|Array)=} destination Destination into which the source is copied. If\n *     provided, must be of the same type as `source`.\n * @returns {*} The copy or updated `destination`, if `destination` was specified.\n */\nfunction copy(source, destination){\n  if (isWindow(source) || isScope(source)) {\n    throw ngMinErr('cpws', \"Can't copy! Making copies of Window or Scope instances is not supported.\");\n  }\n\n  if (!destination) {\n    destination = source;\n    if (source) {\n      if (isArray(source)) {\n        destination = copy(source, []);\n      } else if (isDate(source)) {\n        destination = new Date(source.getTime());\n      } else if (isRegExp(source)) {\n        destination = new RegExp(source.source);\n      } else if (isObject(source)) {\n        destination = copy(source, {});\n      }\n    }\n  } else {\n    if (source === destination) throw ngMinErr('cpi', \"Can't copy! Source and destination are identical.\");\n    if (isArray(source)) {\n      destination.length = 0;\n      for ( var i = 0; i < source.length; i++) {\n        destination.push(copy(source[i]));\n      }\n    } else {\n      var h = destination.$$hashKey;\n      forEach(destination, function(value, key){\n        delete destination[key];\n      });\n      for ( var key in source) {\n        destination[key] = copy(source[key]);\n      }\n      setHashKey(destination,h);\n    }\n  }\n  return destination;\n}\n\n/**\n * Create a shallow copy of an object\n */\nfunction shallowCopy(src, dst) {\n  dst = dst || {};\n\n  for(var key in src) {\n    if (src.hasOwnProperty(key) && key.substr(0, 2) !== '$$') {\n      dst[key] = src[key];\n    }\n  }\n\n  return dst;\n}\n\n\n/**\n * @ngdoc function\n * @name angular.equals\n * @function\n *\n * @description\n * Determines if two objects or two values are equivalent. Supports value types, regular expressions, arrays and\n * objects.\n *\n * Two objects or values are considered equivalent if at least one of the following is true:\n *\n * * Both objects or values pass `===` comparison.\n * * Both objects or values are of the same type and all of their properties pass `===` comparison.\n * * Both values are NaN. (In JavasScript, NaN == NaN => false. But we consider two NaN as equal)\n * * Both values represent the same regular expression (In JavasScript,\n *   /abc/ == /abc/ => false. But we consider two regular expressions as equal when their textual\n *   representation matches).\n *\n * During a property comparison, properties of `function` type and properties with names\n * that begin with `$` are ignored.\n *\n * Scope and DOMWindow objects are being compared only by identify (`===`).\n *\n * @param {*} o1 Object or value to compare.\n * @param {*} o2 Object or value to compare.\n * @returns {boolean} True if arguments are equal.\n */\nfunction equals(o1, o2) {\n  if (o1 === o2) return true;\n  if (o1 === null || o2 === null) return false;\n  if (o1 !== o1 && o2 !== o2) return true; // NaN === NaN\n  var t1 = typeof o1, t2 = typeof o2, length, key, keySet;\n  if (t1 == t2) {\n    if (t1 == 'object') {\n      if (isArray(o1)) {\n        if (!isArray(o2)) return false;\n        if ((length = o1.length) == o2.length) {\n          for(key=0; key<length; key++) {\n            if (!equals(o1[key], o2[key])) return false;\n          }\n          return true;\n        }\n      } else if (isDate(o1)) {\n        return isDate(o2) && o1.getTime() == o2.getTime();\n      } else if (isRegExp(o1) && isRegExp(o2)) {\n        return o1.toString() == o2.toString();\n      } else {\n        if (isScope(o1) || isScope(o2) || isWindow(o1) || isWindow(o2) || isArray(o2)) return false;\n        keySet = {};\n        for(key in o1) {\n          if (key.charAt(0) === '$' || isFunction(o1[key])) continue;\n          if (!equals(o1[key], o2[key])) return false;\n          keySet[key] = true;\n        }\n        for(key in o2) {\n          if (!keySet.hasOwnProperty(key) &&\n              key.charAt(0) !== '$' &&\n              o2[key] !== undefined &&\n              !isFunction(o2[key])) return false;\n        }\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\n\nfunction concat(array1, array2, index) {\n  return array1.concat(slice.call(array2, index));\n}\n\nfunction sliceArgs(args, startIndex) {\n  return slice.call(args, startIndex || 0);\n}\n\n\n/**\n * @ngdoc function\n * @name angular.bind\n * @function\n *\n * @description\n * Returns a function which calls function `fn` bound to `self` (`self` becomes the `this` for\n * `fn`). You can supply optional `args` that are prebound to the function. This feature is also\n * known as [function currying](http://en.wikipedia.org/wiki/Currying).\n *\n * @param {Object} self Context which `fn` should be evaluated in.\n * @param {function()} fn Function to be bound.\n * @param {...*} args Optional arguments to be prebound to the `fn` function call.\n * @returns {function()} Function that wraps the `fn` with all the specified bindings.\n */\nfunction bind(self, fn) {\n  var curryArgs = arguments.length > 2 ? sliceArgs(arguments, 2) : [];\n  if (isFunction(fn) && !(fn instanceof RegExp)) {\n    return curryArgs.length\n      ? function() {\n          return arguments.length\n            ? fn.apply(self, curryArgs.concat(slice.call(arguments, 0)))\n            : fn.apply(self, curryArgs);\n        }\n      : function() {\n          return arguments.length\n            ? fn.apply(self, arguments)\n            : fn.call(self);\n        };\n  } else {\n    // in IE, native methods are not functions so they cannot be bound (note: they don't need to be)\n    return fn;\n  }\n}\n\n\nfunction toJsonReplacer(key, value) {\n  var val = value;\n\n  if (/^\\$+/.test(key)) {\n    val = undefined;\n  } else if (isWindow(value)) {\n    val = '$WINDOW';\n  } else if (value &&  document === value) {\n    val = '$DOCUMENT';\n  } else if (isScope(value)) {\n    val = '$SCOPE';\n  }\n\n  return val;\n}\n\n\n/**\n * @ngdoc function\n * @name angular.toJson\n * @function\n *\n * @description\n * Serializes input into a JSON-formatted string. Properties with leading $ characters will be\n * stripped since angular uses this notation internally.\n *\n * @param {Object|Array|Date|string|number} obj Input to be serialized into JSON.\n * @param {boolean=} pretty If set to true, the JSON output will contain newlines and whitespace.\n * @returns {string|undefined} JSON-ified string representing `obj`.\n */\nfunction toJson(obj, pretty) {\n  if (typeof obj === 'undefined') return undefined;\n  return JSON.stringify(obj, toJsonReplacer, pretty ? '  ' : null);\n}\n\n\n/**\n * @ngdoc function\n * @name angular.fromJson\n * @function\n *\n * @description\n * Deserializes a JSON string.\n *\n * @param {string} json JSON string to deserialize.\n * @returns {Object|Array|Date|string|number} Deserialized thingy.\n */\nfunction fromJson(json) {\n  return isString(json)\n      ? JSON.parse(json)\n      : json;\n}\n\n\nfunction toBoolean(value) {\n  if (value && value.length !== 0) {\n    var v = lowercase(\"\" + value);\n    value = !(v == 'f' || v == '0' || v == 'false' || v == 'no' || v == 'n' || v == '[]');\n  } else {\n    value = false;\n  }\n  return value;\n}\n\n/**\n * @returns {string} Returns the string representation of the element.\n */\nfunction startingTag(element) {\n  element = jqLite(element).clone();\n  try {\n    // turns out IE does not let you set .html() on elements which\n    // are not allowed to have children. So we just ignore it.\n    element.html('');\n  } catch(e) {}\n  // As Per DOM Standards\n  var TEXT_NODE = 3;\n  var elemHtml = jqLite('<div>').append(element).html();\n  try {\n    return element[0].nodeType === TEXT_NODE ? lowercase(elemHtml) :\n        elemHtml.\n          match(/^(<[^>]+>)/)[1].\n          replace(/^<([\\w\\-]+)/, function(match, nodeName) { return '<' + lowercase(nodeName); });\n  } catch(e) {\n    return lowercase(elemHtml);\n  }\n\n}\n\n\n/////////////////////////////////////////////////\n\n/**\n * Tries to decode the URI component without throwing an exception.\n *\n * @private\n * @param str value potential URI component to check.\n * @returns {boolean} True if `value` can be decoded\n * with the decodeURIComponent function.\n */\nfunction tryDecodeURIComponent(value) {\n  try {\n    return decodeURIComponent(value);\n  } catch(e) {\n    // Ignore any invalid uri component\n  }\n}\n\n\n/**\n * Parses an escaped url query string into key-value pairs.\n * @returns Object.<(string|boolean)>\n */\nfunction parseKeyValue(/**string*/keyValue) {\n  var obj = {}, key_value, key;\n  forEach((keyValue || \"\").split('&'), function(keyValue){\n    if ( keyValue ) {\n      key_value = keyValue.split('=');\n      key = tryDecodeURIComponent(key_value[0]);\n      if ( isDefined(key) ) {\n        var val = isDefined(key_value[1]) ? tryDecodeURIComponent(key_value[1]) : true;\n        if (!obj[key]) {\n          obj[key] = val;\n        } else if(isArray(obj[key])) {\n          obj[key].push(val);\n        } else {\n          obj[key] = [obj[key],val];\n        }\n      }\n    }\n  });\n  return obj;\n}\n\nfunction toKeyValue(obj) {\n  var parts = [];\n  forEach(obj, function(value, key) {\n    if (isArray(value)) {\n      forEach(value, function(arrayValue) {\n        parts.push(encodeUriQuery(key, true) + (arrayValue === true ? '' : '=' + encodeUriQuery(arrayValue, true)));\n      });\n    } else {\n    parts.push(encodeUriQuery(key, true) + (value === true ? '' : '=' + encodeUriQuery(value, true)));\n    }\n  });\n  return parts.length ? parts.join('&') : '';\n}\n\n\n/**\n * We need our custom method because encodeURIComponent is too aggressive and doesn't follow\n * http://www.ietf.org/rfc/rfc3986.txt with regards to the character set (pchar) allowed in path\n * segments:\n *    segment       = *pchar\n *    pchar         = unreserved / pct-encoded / sub-delims / \":\" / \"@\"\n *    pct-encoded   = \"%\" HEXDIG HEXDIG\n *    unreserved    = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n *    sub-delims    = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\"\n *                     / \"*\" / \"+\" / \",\" / \";\" / \"=\"\n */\nfunction encodeUriSegment(val) {\n  return encodeUriQuery(val, true).\n             replace(/%26/gi, '&').\n             replace(/%3D/gi, '=').\n             replace(/%2B/gi, '+');\n}\n\n\n/**\n * This method is intended for encoding *key* or *value* parts of query component. We need a custom\n * method because encodeURIComponent is too aggressive and encodes stuff that doesn't have to be\n * encoded per http://tools.ietf.org/html/rfc3986:\n *    query       = *( pchar / \"/\" / \"?\" )\n *    pchar         = unreserved / pct-encoded / sub-delims / \":\" / \"@\"\n *    unreserved    = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n *    pct-encoded   = \"%\" HEXDIG HEXDIG\n *    sub-delims    = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\"\n *                     / \"*\" / \"+\" / \",\" / \";\" / \"=\"\n */\nfunction encodeUriQuery(val, pctEncodeSpaces) {\n  return encodeURIComponent(val).\n             replace(/%40/gi, '@').\n             replace(/%3A/gi, ':').\n             replace(/%24/g, '$').\n             replace(/%2C/gi, ',').\n             replace(/%20/g, (pctEncodeSpaces ? '%20' : '+'));\n}\n\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngApp\n *\n * @element ANY\n * @param {angular.Module} ngApp an optional application\n *   {@link angular.module module} name to load.\n *\n * @description\n *\n * Use this directive to auto-bootstrap an application. Only\n * one ngApp directive can be used per HTML document. The directive\n * designates the root of the application and is typically placed\n * at the root of the page.\n *\n * The first ngApp found in the document will be auto-bootstrapped. To use multiple applications in an\n * HTML document you must manually bootstrap them using {@link angular.bootstrap}.\n * Applications cannot be nested.\n *\n * In the example below if the `ngApp` directive would not be placed\n * on the `html` element then the document would not be compiled\n * and the `{{ 1+2 }}` would not be resolved to `3`.\n *\n * `ngApp` is the easiest way to bootstrap an application.\n *\n <doc:example>\n   <doc:source>\n    I can add: 1 + 2 =  {{ 1+2 }}\n   </doc:source>\n </doc:example>\n *\n */\nfunction angularInit(element, bootstrap) {\n  var elements = [element],\n      appElement,\n      module,\n      names = ['ng:app', 'ng-app', 'x-ng-app', 'data-ng-app'],\n      NG_APP_CLASS_REGEXP = /\\sng[:\\-]app(:\\s*([\\w\\d_]+);?)?\\s/;\n\n  function append(element) {\n    element && elements.push(element);\n  }\n\n  forEach(names, function(name) {\n    names[name] = true;\n    append(document.getElementById(name));\n    name = name.replace(':', '\\\\:');\n    if (element.querySelectorAll) {\n      forEach(element.querySelectorAll('.' + name), append);\n      forEach(element.querySelectorAll('.' + name + '\\\\:'), append);\n      forEach(element.querySelectorAll('[' + name + ']'), append);\n    }\n  });\n\n  forEach(elements, function(element) {\n    if (!appElement) {\n      var className = ' ' + element.className + ' ';\n      var match = NG_APP_CLASS_REGEXP.exec(className);\n      if (match) {\n        appElement = element;\n        module = (match[2] || '').replace(/\\s+/g, ',');\n      } else {\n        forEach(element.attributes, function(attr) {\n          if (!appElement && names[attr.name]) {\n            appElement = element;\n            module = attr.value;\n          }\n        });\n      }\n    }\n  });\n  if (appElement) {\n    bootstrap(appElement, module ? [module] : []);\n  }\n}\n\n/**\n * @ngdoc function\n * @name angular.bootstrap\n * @description\n * Use this function to manually start up angular application.\n *\n * See: {@link guide/bootstrap Bootstrap}\n *\n * Note that ngScenario-based end-to-end tests cannot use this function to bootstrap manually.\n * They must use {@link api/ng.directive:ngApp ngApp}.\n *\n * @param {Element} element DOM element which is the root of angular application.\n * @param {Array<String|Function>=} modules an array of module declarations. See: {@link angular.module modules}\n * @returns {AUTO.$injector} Returns the newly created injector for this app.\n */\nfunction bootstrap(element, modules) {\n  var doBootstrap = function() {\n    element = jqLite(element);\n\n    if (element.injector()) {\n      var tag = (element[0] === document) ? 'document' : startingTag(element);\n      throw ngMinErr('btstrpd', \"App Already Bootstrapped with this Element '{0}'\", tag);\n    }\n\n    modules = modules || [];\n    modules.unshift(['$provide', function($provide) {\n      $provide.value('$rootElement', element);\n    }]);\n    modules.unshift('ng');\n    var injector = createInjector(modules);\n    injector.invoke(['$rootScope', '$rootElement', '$compile', '$injector', '$animate',\n       function(scope, element, compile, injector, animate) {\n        scope.$apply(function() {\n          element.data('$injector', injector);\n          compile(element)(scope);\n        });\n        animate.enabled(true);\n      }]\n    );\n    return injector;\n  };\n\n  var NG_DEFER_BOOTSTRAP = /^NG_DEFER_BOOTSTRAP!/;\n\n  if (window && !NG_DEFER_BOOTSTRAP.test(window.name)) {\n    return doBootstrap();\n  }\n\n  window.name = window.name.replace(NG_DEFER_BOOTSTRAP, '');\n  angular.resumeBootstrap = function(extraModules) {\n    forEach(extraModules, function(module) {\n      modules.push(module);\n    });\n    doBootstrap();\n  };\n}\n\nvar SNAKE_CASE_REGEXP = /[A-Z]/g;\nfunction snake_case(name, separator){\n  separator = separator || '_';\n  return name.replace(SNAKE_CASE_REGEXP, function(letter, pos) {\n    return (pos ? separator : '') + letter.toLowerCase();\n  });\n}\n\nfunction bindJQuery() {\n  // bind to jQuery if present;\n  jQuery = window.jQuery;\n  // reset to jQuery or default to us.\n  if (jQuery) {\n    jqLite = jQuery;\n    extend(jQuery.fn, {\n      scope: JQLitePrototype.scope,\n      controller: JQLitePrototype.controller,\n      injector: JQLitePrototype.injector,\n      inheritedData: JQLitePrototype.inheritedData\n    });\n    // Method signature: JQLitePatchJQueryRemove(name, dispatchThis, filterElems, getterIfNoArguments)\n    JQLitePatchJQueryRemove('remove', true, true, false);\n    JQLitePatchJQueryRemove('empty', false, false, false);\n    JQLitePatchJQueryRemove('html', false, false, true);\n  } else {\n    jqLite = JQLite;\n  }\n  angular.element = jqLite;\n}\n\n/**\n * throw error if the argument is falsy.\n */\nfunction assertArg(arg, name, reason) {\n  if (!arg) {\n    throw ngMinErr('areq', \"Argument '{0}' is {1}\", (name || '?'), (reason || \"required\"));\n  }\n  return arg;\n}\n\nfunction assertArgFn(arg, name, acceptArrayAnnotation) {\n  if (acceptArrayAnnotation && isArray(arg)) {\n      arg = arg[arg.length - 1];\n  }\n\n  assertArg(isFunction(arg), name, 'not a function, got ' +\n      (arg && typeof arg == 'object' ? arg.constructor.name || 'Object' : typeof arg));\n  return arg;\n}\n\n/**\n * Return the value accessible from the object by path. Any undefined traversals are ignored\n * @param {Object} obj starting object\n * @param {string} path path to traverse\n * @param {boolean=true} bindFnToScope\n * @returns value as accessible by path\n */\n//TODO(misko): this function needs to be removed\nfunction getter(obj, path, bindFnToScope) {\n  if (!path) return obj;\n  var keys = path.split('.');\n  var key;\n  var lastInstance = obj;\n  var len = keys.length;\n\n  for (var i = 0; i < len; i++) {\n    key = keys[i];\n    if (obj) {\n      obj = (lastInstance = obj)[key];\n    }\n  }\n  if (!bindFnToScope && isFunction(obj)) {\n    return bind(lastInstance, obj);\n  }\n  return obj;\n}\n\n/**\n * @ngdoc interface\n * @name angular.Module\n * @description\n *\n * Interface for configuring angular {@link angular.module modules}.\n */\n\nfunction setupModuleLoader(window) {\n\n  function ensure(obj, name, factory) {\n    return obj[name] || (obj[name] = factory());\n  }\n\n  return ensure(ensure(window, 'angular', Object), 'module', function() {\n    /** @type {Object.<string, angular.Module>} */\n    var modules = {};\n\n    /**\n     * @ngdoc function\n     * @name angular.module\n     * @description\n     *\n     * The `angular.module` is a global place for creating, registering and retrieving Angular modules.\n     * All modules (angular core or 3rd party) that should be available to an application must be\n     * registered using this mechanism.\n     *\n     * When passed two or more arguments, a new module is created.  If passed only one argument, an\n     * existing module (the name passed as the first argument to `module`) is retrieved.\n     *\n     *\n     * # Module\n     *\n     * A module is a collection of services, directives, filters, and configuration information.\n     * `angular.module` is used to configure the {@link AUTO.$injector $injector}.\n     *\n     * <pre>\n     * // Create a new module\n     * var myModule = angular.module('myModule', []);\n     *\n     * // register a new service\n     * myModule.value('appName', 'MyCoolApp');\n     *\n     * // configure existing services inside initialization blocks.\n     * myModule.config(function($locationProvider) {\n     *   // Configure existing providers\n     *   $locationProvider.hashPrefix('!');\n     * });\n     * </pre>\n     *\n     * Then you can create an injector and load your modules like this:\n     *\n     * <pre>\n     * var injector = angular.injector(['ng', 'MyModule'])\n     * </pre>\n     *\n     * However it's more likely that you'll just use\n     * {@link ng.directive:ngApp ngApp} or\n     * {@link angular.bootstrap} to simplify this process for you.\n     *\n     * @param {!string} name The name of the module to create or retrieve.\n     * @param {Array.<string>=} requires If specified then new module is being created. If unspecified then the\n     *        the module is being retrieved for further configuration.\n     * @param {Function} configFn Optional configuration function for the module. Same as\n     *        {@link angular.Module#config Module#config()}.\n     * @returns {module} new module with the {@link angular.Module} api.\n     */\n    return function module(name, requires, configFn) {\n      if (requires && modules.hasOwnProperty(name)) {\n        modules[name] = null;\n      }\n      return ensure(modules, name, function() {\n        if (!requires) {\n          throw minErr('$injector')('nomod', \"Module '{0}' is not available! You either misspelled the module name \" +\n              \"or forgot to load it. If registering a module ensure that you specify the dependencies as the second \" +\n              \"argument.\", name);\n        }\n\n        /** @type {!Array.<Array.<*>>} */\n        var invokeQueue = [];\n\n        /** @type {!Array.<Function>} */\n        var runBlocks = [];\n\n        var config = invokeLater('$injector', 'invoke');\n\n        /** @type {angular.Module} */\n        var moduleInstance = {\n          // Private state\n          _invokeQueue: invokeQueue,\n          _runBlocks: runBlocks,\n\n          /**\n           * @ngdoc property\n           * @name angular.Module#requires\n           * @propertyOf angular.Module\n           * @returns {Array.<string>} List of module names which must be loaded before this module.\n           * @description\n           * Holds the list of modules which the injector will load before the current module is loaded.\n           */\n          requires: requires,\n\n          /**\n           * @ngdoc property\n           * @name angular.Module#name\n           * @propertyOf angular.Module\n           * @returns {string} Name of the module.\n           * @description\n           */\n          name: name,\n\n\n          /**\n           * @ngdoc method\n           * @name angular.Module#provider\n           * @methodOf angular.Module\n           * @param {string} name service name\n           * @param {Function} providerType Construction function for creating new instance of the service.\n           * @description\n           * See {@link AUTO.$provide#provider $provide.provider()}.\n           */\n          provider: invokeLater('$provide', 'provider'),\n\n          /**\n           * @ngdoc method\n           * @name angular.Module#factory\n           * @methodOf angular.Module\n           * @param {string} name service name\n           * @param {Function} providerFunction Function for creating new instance of the service.\n           * @description\n           * See {@link AUTO.$provide#factory $provide.factory()}.\n           */\n          factory: invokeLater('$provide', 'factory'),\n\n          /**\n           * @ngdoc method\n           * @name angular.Module#service\n           * @methodOf angular.Module\n           * @param {string} name service name\n           * @param {Function} constructor A constructor function that will be instantiated.\n           * @description\n           * See {@link AUTO.$provide#service $provide.service()}.\n           */\n          service: invokeLater('$provide', 'service'),\n\n          /**\n           * @ngdoc method\n           * @name angular.Module#value\n           * @methodOf angular.Module\n           * @param {string} name service name\n           * @param {*} object Service instance object.\n           * @description\n           * See {@link AUTO.$provide#value $provide.value()}.\n           */\n          value: invokeLater('$provide', 'value'),\n\n          /**\n           * @ngdoc method\n           * @name angular.Module#constant\n           * @methodOf angular.Module\n           * @param {string} name constant name\n           * @param {*} object Constant value.\n           * @description\n           * Because the constant are fixed, they get applied before other provide methods.\n           * See {@link AUTO.$provide#constant $provide.constant()}.\n           */\n          constant: invokeLater('$provide', 'constant', 'unshift'),\n\n          /**\n           * @ngdoc method\n           * @name angular.Module#animation\n           * @methodOf angular.Module\n           * @param {string} name animation name\n           * @param {Function} animationFactory Factory function for creating new instance of an animation.\n           * @description\n           *\n           * **NOTE**: animations are take effect only if the **ngAnimate** module is loaded.\n           *\n           *\n           * Defines an animation hook that can be later used with {@link ngAnimate.$animate $animate} service and\n           * directives that use this service.\n           *\n           * <pre>\n           * module.animation('.animation-name', function($inject1, $inject2) {\n           *   return {\n           *     eventName : function(element, done) {\n           *       //code to run the animation\n           *       //once complete, then run done()\n           *       return function cancellationFunction(element) {\n           *         //code to cancel the animation\n           *       }\n           *     }\n           *   }\n           * })\n           * </pre>\n           *\n           * See {@link ngAnimate.$animateProvider#register $animateProvider.register()} and\n           * {@link ngAnimate ngAnimate module} for more information.\n           */\n          animation: invokeLater('$animateProvider', 'register'),\n\n          /**\n           * @ngdoc method\n           * @name angular.Module#filter\n           * @methodOf angular.Module\n           * @param {string} name Filter name.\n           * @param {Function} filterFactory Factory function for creating new instance of filter.\n           * @description\n           * See {@link ng.$filterProvider#register $filterProvider.register()}.\n           */\n          filter: invokeLater('$filterProvider', 'register'),\n\n          /**\n           * @ngdoc method\n           * @name angular.Module#controller\n           * @methodOf angular.Module\n           * @param {string} name Controller name.\n           * @param {Function} constructor Controller constructor function.\n           * @description\n           * See {@link ng.$controllerProvider#register $controllerProvider.register()}.\n           */\n          controller: invokeLater('$controllerProvider', 'register'),\n\n          /**\n           * @ngdoc method\n           * @name angular.Module#directive\n           * @methodOf angular.Module\n           * @param {string} name directive name\n           * @param {Function} directiveFactory Factory function for creating new instance of\n           * directives.\n           * @description\n           * See {@link ng.$compileProvider#directive $compileProvider.directive()}.\n           */\n          directive: invokeLater('$compileProvider', 'directive'),\n\n          /**\n           * @ngdoc method\n           * @name angular.Module#config\n           * @methodOf angular.Module\n           * @param {Function} configFn Execute this function on module load. Useful for service\n           *    configuration.\n           * @description\n           * Use this method to register work which needs to be performed on module loading.\n           */\n          config: config,\n\n          /**\n           * @ngdoc method\n           * @name angular.Module#run\n           * @methodOf angular.Module\n           * @param {Function} initializationFn Execute this function after injector creation.\n           *    Useful for application initialization.\n           * @description\n           * Use this method to register work which should be performed when the injector is done\n           * loading all modules.\n           */\n          run: function(block) {\n            runBlocks.push(block);\n            return this;\n          }\n        };\n\n        if (configFn) {\n          config(configFn);\n        }\n\n        return  moduleInstance;\n\n        /**\n         * @param {string} provider\n         * @param {string} method\n         * @param {String=} insertMethod\n         * @returns {angular.Module}\n         */\n        function invokeLater(provider, method, insertMethod) {\n          return function() {\n            invokeQueue[insertMethod || 'push']([provider, method, arguments]);\n            return moduleInstance;\n          }\n        }\n      });\n    };\n  });\n\n}\n\n/**\n * @ngdoc property\n * @name angular.version\n * @description\n * An object that contains information about the current AngularJS version. This object has the\n * following properties:\n *\n * - `full` – `{string}` – Full version string, such as \"0.9.18\".\n * - `major` – `{number}` – Major version number, such as \"0\".\n * - `minor` – `{number}` – Minor version number, such as \"9\".\n * - `dot` – `{number}` – Dot version number, such as \"18\".\n * - `codeName` – `{string}` – Code name of the release, such as \"jiggling-armfat\".\n */\nvar version = {\n  full: '1.2.0-rc.2',    // all of these placeholder strings will be replaced by grunt's\n  major: 1,    // package task\n  minor: 2,\n  dot: 0,\n  codeName: 'barehand-atomsplitting'\n};\n\n\nfunction publishExternalAPI(angular){\n  extend(angular, {\n    'bootstrap': bootstrap,\n    'copy': copy,\n    'extend': extend,\n    'equals': equals,\n    'element': jqLite,\n    'forEach': forEach,\n    'injector': createInjector,\n    'noop':noop,\n    'bind':bind,\n    'toJson': toJson,\n    'fromJson': fromJson,\n    'identity':identity,\n    'isUndefined': isUndefined,\n    'isDefined': isDefined,\n    'isString': isString,\n    'isFunction': isFunction,\n    'isObject': isObject,\n    'isNumber': isNumber,\n    'isElement': isElement,\n    'isArray': isArray,\n    '$$minErr': minErr,\n    'version': version,\n    'isDate': isDate,\n    'lowercase': lowercase,\n    'uppercase': uppercase,\n    'callbacks': {counter: 0}\n  });\n\n  angularModule = setupModuleLoader(window);\n  try {\n    angularModule('ngLocale');\n  } catch (e) {\n    angularModule('ngLocale', []).provider('$locale', $LocaleProvider);\n  }\n\n  angularModule('ng', ['ngLocale'], ['$provide',\n    function ngModule($provide) {\n      $provide.provider('$compile', $CompileProvider).\n        directive({\n            a: htmlAnchorDirective,\n            input: inputDirective,\n            textarea: inputDirective,\n            form: formDirective,\n            script: scriptDirective,\n            select: selectDirective,\n            style: styleDirective,\n            option: optionDirective,\n            ngBind: ngBindDirective,\n            ngBindHtml: ngBindHtmlDirective,\n            ngBindTemplate: ngBindTemplateDirective,\n            ngClass: ngClassDirective,\n            ngClassEven: ngClassEvenDirective,\n            ngClassOdd: ngClassOddDirective,\n            ngCsp: ngCspDirective,\n            ngCloak: ngCloakDirective,\n            ngController: ngControllerDirective,\n            ngForm: ngFormDirective,\n            ngHide: ngHideDirective,\n            ngIf: ngIfDirective,\n            ngInclude: ngIncludeDirective,\n            ngInit: ngInitDirective,\n            ngNonBindable: ngNonBindableDirective,\n            ngPluralize: ngPluralizeDirective,\n            ngRepeat: ngRepeatDirective,\n            ngShow: ngShowDirective,\n            ngStyle: ngStyleDirective,\n            ngSwitch: ngSwitchDirective,\n            ngSwitchWhen: ngSwitchWhenDirective,\n            ngSwitchDefault: ngSwitchDefaultDirective,\n            ngOptions: ngOptionsDirective,\n            ngTransclude: ngTranscludeDirective,\n            ngModel: ngModelDirective,\n            ngList: ngListDirective,\n            ngChange: ngChangeDirective,\n            required: requiredDirective,\n            ngRequired: requiredDirective,\n            ngValue: ngValueDirective\n        }).\n        directive(ngAttributeAliasDirectives).\n        directive(ngEventDirectives);\n      $provide.provider({\n        $anchorScroll: $AnchorScrollProvider,\n        $animate: $AnimateProvider,\n        $browser: $BrowserProvider,\n        $cacheFactory: $CacheFactoryProvider,\n        $controller: $ControllerProvider,\n        $document: $DocumentProvider,\n        $exceptionHandler: $ExceptionHandlerProvider,\n        $filter: $FilterProvider,\n        $interpolate: $InterpolateProvider,\n        $http: $HttpProvider,\n        $httpBackend: $HttpBackendProvider,\n        $location: $LocationProvider,\n        $log: $LogProvider,\n        $parse: $ParseProvider,\n        $rootScope: $RootScopeProvider,\n        $q: $QProvider,\n        $sce: $SceProvider,\n        $sceDelegate: $SceDelegateProvider,\n        $sniffer: $SnifferProvider,\n        $templateCache: $TemplateCacheProvider,\n        $timeout: $TimeoutProvider,\n        $window: $WindowProvider,\n        $$urlUtils: $$UrlUtilsProvider\n      });\n    }\n  ]);\n}\n\n//////////////////////////////////\n//JQLite\n//////////////////////////////////\n\n/**\n * @ngdoc function\n * @name angular.element\n * @function\n *\n * @description\n * Wraps a raw DOM element or HTML string as a [jQuery](http://jquery.com) element.\n * `angular.element` can be either an alias for [jQuery](http://api.jquery.com/jQuery/) function, if\n * jQuery is available, or a function that wraps the element or string in Angular's jQuery lite\n * implementation (commonly referred to as jqLite).\n *\n * Real jQuery always takes precedence over jqLite, provided it was loaded before `DOMContentLoaded`\n * event fired.\n *\n * jqLite is a tiny, API-compatible subset of jQuery that allows\n * Angular to manipulate the DOM. jqLite implements only the most commonly needed functionality\n * within a very small footprint, so only a subset of the jQuery API - methods, arguments and\n * invocation styles - are supported.\n *\n * Note: All element references in Angular are always wrapped with jQuery or jqLite; they are never\n * raw DOM references.\n *\n * ## Angular's jqLite\n * Angular's lite version of jQuery provides only the following jQuery methods:\n *\n * - [addClass()](http://api.jquery.com/addClass/)\n * - [after()](http://api.jquery.com/after/)\n * - [append()](http://api.jquery.com/append/)\n * - [attr()](http://api.jquery.com/attr/)\n * - [bind()](http://api.jquery.com/on/) - Does not support namespaces, selectors or eventData\n * - [children()](http://api.jquery.com/children/) - Does not support selectors\n * - [clone()](http://api.jquery.com/clone/)\n * - [contents()](http://api.jquery.com/contents/)\n * - [css()](http://api.jquery.com/css/)\n * - [data()](http://api.jquery.com/data/)\n * - [eq()](http://api.jquery.com/eq/)\n * - [find()](http://api.jquery.com/find/) - Limited to lookups by tag name\n * - [hasClass()](http://api.jquery.com/hasClass/)\n * - [html()](http://api.jquery.com/html/)\n * - [next()](http://api.jquery.com/next/) - Does not support selectors\n * - [on()](http://api.jquery.com/on/) - Does not support namespaces, selectors or eventData\n * - [off()](http://api.jquery.com/off/) - Does not support namespaces or selectors\n * - [parent()](http://api.jquery.com/parent/) - Does not support selectors\n * - [prepend()](http://api.jquery.com/prepend/)\n * - [prop()](http://api.jquery.com/prop/)\n * - [ready()](http://api.jquery.com/ready/)\n * - [remove()](http://api.jquery.com/remove/)\n * - [removeAttr()](http://api.jquery.com/removeAttr/)\n * - [removeClass()](http://api.jquery.com/removeClass/)\n * - [removeData()](http://api.jquery.com/removeData/)\n * - [replaceWith()](http://api.jquery.com/replaceWith/)\n * - [text()](http://api.jquery.com/text/)\n * - [toggleClass()](http://api.jquery.com/toggleClass/)\n * - [triggerHandler()](http://api.jquery.com/triggerHandler/) - Passes a dummy event object to handlers.\n * - [unbind()](http://api.jquery.com/off/) - Does not support namespaces\n * - [val()](http://api.jquery.com/val/)\n * - [wrap()](http://api.jquery.com/wrap/)\n *\n * ## jQuery/jqLite Extras\n * Angular also provides the following additional methods and events to both jQuery and jqLite:\n *\n * ### Events\n * - `$destroy` - AngularJS intercepts all jqLite/jQuery's DOM destruction apis and fires this event\n *    on all DOM nodes being removed.  This can be used to clean up and 3rd party bindings to the DOM\n *    element before it is removed.\n * ### Methods\n * - `controller(name)` - retrieves the controller of the current element or its parent. By default\n *   retrieves controller associated with the `ngController` directive. If `name` is provided as\n *   camelCase directive name, then the controller for this directive will be retrieved (e.g.\n *   `'ngModel'`).\n * - `injector()` - retrieves the injector of the current element or its parent.\n * - `scope()` - retrieves the {@link api/ng.$rootScope.Scope scope} of the current\n *   element or its parent.\n * - `inheritedData()` - same as `data()`, but walks up the DOM until a value is found or the top\n *   parent element is reached.\n *\n * @param {string|DOMElement} element HTML string or DOMElement to be wrapped into jQuery.\n * @returns {Object} jQuery object.\n */\n\nvar jqCache = JQLite.cache = {},\n    jqName = JQLite.expando = 'ng-' + new Date().getTime(),\n    jqId = 1,\n    addEventListenerFn = (window.document.addEventListener\n      ? function(element, type, fn) {element.addEventListener(type, fn, false);}\n      : function(element, type, fn) {element.attachEvent('on' + type, fn);}),\n    removeEventListenerFn = (window.document.removeEventListener\n      ? function(element, type, fn) {element.removeEventListener(type, fn, false); }\n      : function(element, type, fn) {element.detachEvent('on' + type, fn); });\n\nfunction jqNextId() { return ++jqId; }\n\n\nvar SPECIAL_CHARS_REGEXP = /([\\:\\-\\_]+(.))/g;\nvar MOZ_HACK_REGEXP = /^moz([A-Z])/;\nvar jqLiteMinErr = minErr('jqLite');\n\n/**\n * Converts snake_case to camelCase.\n * Also there is special case for Moz prefix starting with upper case letter.\n * @param name Name to normalize\n */\nfunction camelCase(name) {\n  return name.\n    replace(SPECIAL_CHARS_REGEXP, function(_, separator, letter, offset) {\n      return offset ? letter.toUpperCase() : letter;\n    }).\n    replace(MOZ_HACK_REGEXP, 'Moz$1');\n}\n\n/////////////////////////////////////////////\n// jQuery mutation patch\n//\n// In conjunction with bindJQuery intercepts all jQuery's DOM destruction apis and fires a\n// $destroy event on all DOM nodes being removed.\n//\n/////////////////////////////////////////////\n\nfunction JQLitePatchJQueryRemove(name, dispatchThis, filterElems, getterIfNoArguments) {\n  var originalJqFn = jQuery.fn[name];\n  originalJqFn = originalJqFn.$original || originalJqFn;\n  removePatch.$original = originalJqFn;\n  jQuery.fn[name] = removePatch;\n\n  function removePatch(param) {\n    var list = filterElems && param ? [this.filter(param)] : [this],\n        fireEvent = dispatchThis,\n        set, setIndex, setLength,\n        element, childIndex, childLength, children;\n\n    if (!getterIfNoArguments || param != null) {\n      while(list.length) {\n        set = list.shift();\n        for(setIndex = 0, setLength = set.length; setIndex < setLength; setIndex++) {\n          element = jqLite(set[setIndex]);\n          if (fireEvent) {\n            element.triggerHandler('$destroy');\n          } else {\n            fireEvent = !fireEvent;\n          }\n          for(childIndex = 0, childLength = (children = element.children()).length;\n              childIndex < childLength;\n              childIndex++) {\n            list.push(jQuery(children[childIndex]));\n          }\n        }\n      }\n    }\n    return originalJqFn.apply(this, arguments);\n  }\n}\n\n/////////////////////////////////////////////\nfunction JQLite(element) {\n  if (element instanceof JQLite) {\n    return element;\n  }\n  if (!(this instanceof JQLite)) {\n    if (isString(element) && element.charAt(0) != '<') {\n      throw jqLiteMinErr('nosel', 'Looking up elements via selectors is not supported by jqLite! See: http://docs.angularjs.org/api/angular.element');\n    }\n    return new JQLite(element);\n  }\n\n  if (isString(element)) {\n    var div = document.createElement('div');\n    // Read about the NoScope elements here:\n    // http://msdn.microsoft.com/en-us/library/ms533897(VS.85).aspx\n    div.innerHTML = '<div>&#160;</div>' + element; // IE insanity to make NoScope elements work!\n    div.removeChild(div.firstChild); // remove the superfluous div\n    JQLiteAddNodes(this, div.childNodes);\n    var fragment = jqLite(document.createDocumentFragment());\n    fragment.append(this); // detach the elements from the temporary DOM div.\n  } else {\n    JQLiteAddNodes(this, element);\n  }\n}\n\nfunction JQLiteClone(element) {\n  return element.cloneNode(true);\n}\n\nfunction JQLiteDealoc(element){\n  JQLiteRemoveData(element);\n  for ( var i = 0, children = element.childNodes || []; i < children.length; i++) {\n    JQLiteDealoc(children[i]);\n  }\n}\n\nfunction JQLiteOff(element, type, fn, unsupported) {\n  if (isDefined(unsupported)) throw jqLiteMinErr('offargs', 'jqLite#off() does not support the `selector` argument');\n\n  var events = JQLiteExpandoStore(element, 'events'),\n      handle = JQLiteExpandoStore(element, 'handle');\n\n  if (!handle) return; //no listeners registered\n\n  if (isUndefined(type)) {\n    forEach(events, function(eventHandler, type) {\n      removeEventListenerFn(element, type, eventHandler);\n      delete events[type];\n    });\n  } else {\n    forEach(type.split(' '), function(type) {\n      if (isUndefined(fn)) {\n        removeEventListenerFn(element, type, events[type]);\n        delete events[type];\n      } else {\n        arrayRemove(events[type] || [], fn);\n      }\n    });\n  }\n}\n\nfunction JQLiteRemoveData(element, name) {\n  var expandoId = element[jqName],\n      expandoStore = jqCache[expandoId];\n\n  if (expandoStore) {\n    if (name) {\n      delete jqCache[expandoId].data[name];\n      return;\n    }\n\n    if (expandoStore.handle) {\n      expandoStore.events.$destroy && expandoStore.handle({}, '$destroy');\n      JQLiteOff(element);\n    }\n    delete jqCache[expandoId];\n    element[jqName] = undefined; // ie does not allow deletion of attributes on elements.\n  }\n}\n\nfunction JQLiteExpandoStore(element, key, value) {\n  var expandoId = element[jqName],\n      expandoStore = jqCache[expandoId || -1];\n\n  if (isDefined(value)) {\n    if (!expandoStore) {\n      element[jqName] = expandoId = jqNextId();\n      expandoStore = jqCache[expandoId] = {};\n    }\n    expandoStore[key] = value;\n  } else {\n    return expandoStore && expandoStore[key];\n  }\n}\n\nfunction JQLiteData(element, key, value) {\n  var data = JQLiteExpandoStore(element, 'data'),\n      isSetter = isDefined(value),\n      keyDefined = !isSetter && isDefined(key),\n      isSimpleGetter = keyDefined && !isObject(key);\n\n  if (!data && !isSimpleGetter) {\n    JQLiteExpandoStore(element, 'data', data = {});\n  }\n\n  if (isSetter) {\n    data[key] = value;\n  } else {\n    if (keyDefined) {\n      if (isSimpleGetter) {\n        // don't create data in this case.\n        return data && data[key];\n      } else {\n        extend(data, key);\n      }\n    } else {\n      return data;\n    }\n  }\n}\n\nfunction JQLiteHasClass(element, selector) {\n  return ((\" \" + element.className + \" \").replace(/[\\n\\t]/g, \" \").\n      indexOf( \" \" + selector + \" \" ) > -1);\n}\n\nfunction JQLiteRemoveClass(element, cssClasses) {\n  if (cssClasses) {\n    forEach(cssClasses.split(' '), function(cssClass) {\n      element.className = trim(\n          (\" \" + element.className + \" \")\n          .replace(/[\\n\\t]/g, \" \")\n          .replace(\" \" + trim(cssClass) + \" \", \" \")\n      );\n    });\n  }\n}\n\nfunction JQLiteAddClass(element, cssClasses) {\n  if (cssClasses) {\n    forEach(cssClasses.split(' '), function(cssClass) {\n      if (!JQLiteHasClass(element, cssClass)) {\n        element.className = trim(element.className + ' ' + trim(cssClass));\n      }\n    });\n  }\n}\n\nfunction JQLiteAddNodes(root, elements) {\n  if (elements) {\n    elements = (!elements.nodeName && isDefined(elements.length) && !isWindow(elements))\n      ? elements\n      : [ elements ];\n    for(var i=0; i < elements.length; i++) {\n      root.push(elements[i]);\n    }\n  }\n}\n\nfunction JQLiteController(element, name) {\n  return JQLiteInheritedData(element, '$' + (name || 'ngController' ) + 'Controller');\n}\n\nfunction JQLiteInheritedData(element, name, value) {\n  element = jqLite(element);\n\n  // if element is the document object work with the html element instead\n  // this makes $(document).scope() possible\n  if(element[0].nodeType == 9) {\n    element = element.find('html');\n  }\n\n  while (element.length) {\n    if ((value = element.data(name)) !== undefined) return value;\n    element = element.parent();\n  }\n}\n\n//////////////////////////////////////////\n// Functions which are declared directly.\n//////////////////////////////////////////\nvar JQLitePrototype = JQLite.prototype = {\n  ready: function(fn) {\n    var fired = false;\n\n    function trigger() {\n      if (fired) return;\n      fired = true;\n      fn();\n    }\n\n    // check if document already is loaded\n    if (document.readyState === 'complete'){\n      setTimeout(trigger);\n    } else {\n      this.on('DOMContentLoaded', trigger); // works for modern browsers and IE9\n      // we can not use jqLite since we are not done loading and jQuery could be loaded later.\n      JQLite(window).on('load', trigger); // fallback to window.onload for others\n    }\n  },\n  toString: function() {\n    var value = [];\n    forEach(this, function(e){ value.push('' + e);});\n    return '[' + value.join(', ') + ']';\n  },\n\n  eq: function(index) {\n      return (index >= 0) ? jqLite(this[index]) : jqLite(this[this.length + index]);\n  },\n\n  length: 0,\n  push: push,\n  sort: [].sort,\n  splice: [].splice\n};\n\n//////////////////////////////////////////\n// Functions iterating getter/setters.\n// these functions return self on setter and\n// value on get.\n//////////////////////////////////////////\nvar BOOLEAN_ATTR = {};\nforEach('multiple,selected,checked,disabled,readOnly,required,open'.split(','), function(value) {\n  BOOLEAN_ATTR[lowercase(value)] = value;\n});\nvar BOOLEAN_ELEMENTS = {};\nforEach('input,select,option,textarea,button,form,details'.split(','), function(value) {\n  BOOLEAN_ELEMENTS[uppercase(value)] = true;\n});\n\nfunction getBooleanAttrName(element, name) {\n  // check dom last since we will most likely fail on name\n  var booleanAttr = BOOLEAN_ATTR[name.toLowerCase()];\n\n  // booleanAttr is here twice to minimize DOM access\n  return booleanAttr && BOOLEAN_ELEMENTS[element.nodeName] && booleanAttr;\n}\n\nforEach({\n  data: JQLiteData,\n  inheritedData: JQLiteInheritedData,\n\n  scope: function(element) {\n    return JQLiteInheritedData(element, '$scope');\n  },\n\n  controller: JQLiteController ,\n\n  injector: function(element) {\n    return JQLiteInheritedData(element, '$injector');\n  },\n\n  removeAttr: function(element,name) {\n    element.removeAttribute(name);\n  },\n\n  hasClass: JQLiteHasClass,\n\n  css: function(element, name, value) {\n    name = camelCase(name);\n\n    if (isDefined(value)) {\n      element.style[name] = value;\n    } else {\n      var val;\n\n      if (msie <= 8) {\n        // this is some IE specific weirdness that jQuery 1.6.4 does not sure why\n        val = element.currentStyle && element.currentStyle[name];\n        if (val === '') val = 'auto';\n      }\n\n      val = val || element.style[name];\n\n      if (msie <= 8) {\n        // jquery weirdness :-/\n        val = (val === '') ? undefined : val;\n      }\n\n      return  val;\n    }\n  },\n\n  attr: function(element, name, value){\n    var lowercasedName = lowercase(name);\n    if (BOOLEAN_ATTR[lowercasedName]) {\n      if (isDefined(value)) {\n        if (!!value) {\n          element[name] = true;\n          element.setAttribute(name, lowercasedName);\n        } else {\n          element[name] = false;\n          element.removeAttribute(lowercasedName);\n        }\n      } else {\n        return (element[name] ||\n                 (element.attributes.getNamedItem(name)|| noop).specified)\n               ? lowercasedName\n               : undefined;\n      }\n    } else if (isDefined(value)) {\n      element.setAttribute(name, value);\n    } else if (element.getAttribute) {\n      // the extra argument \"2\" is to get the right thing for a.href in IE, see jQuery code\n      // some elements (e.g. Document) don't have get attribute, so return undefined\n      var ret = element.getAttribute(name, 2);\n      // normalize non-existing attributes to undefined (as jQuery)\n      return ret === null ? undefined : ret;\n    }\n  },\n\n  prop: function(element, name, value) {\n    if (isDefined(value)) {\n      element[name] = value;\n    } else {\n      return element[name];\n    }\n  },\n\n  text: (function() {\n    var NODE_TYPE_TEXT_PROPERTY = [];\n    if (msie < 9) {\n      NODE_TYPE_TEXT_PROPERTY[1] = 'innerText';    /** Element **/\n      NODE_TYPE_TEXT_PROPERTY[3] = 'nodeValue';    /** Text **/\n    } else {\n      NODE_TYPE_TEXT_PROPERTY[1] =                 /** Element **/\n      NODE_TYPE_TEXT_PROPERTY[3] = 'textContent';  /** Text **/\n    }\n    getText.$dv = '';\n    return getText;\n\n    function getText(element, value) {\n      var textProp = NODE_TYPE_TEXT_PROPERTY[element.nodeType]\n      if (isUndefined(value)) {\n        return textProp ? element[textProp] : '';\n      }\n      element[textProp] = value;\n    }\n  })(),\n\n  val: function(element, value) {\n    if (isUndefined(value)) {\n      if (nodeName_(element) === 'SELECT' && element.multiple) {\n        var result = [];\n        forEach(element.options, function (option) {\n          if (option.selected) {\n            result.push(option.value || option.text);\n          }\n        });\n        return result.length === 0 ? null : result;\n      }\n      return element.value;\n    }\n    element.value = value;\n  },\n\n  html: function(element, value) {\n    if (isUndefined(value)) {\n      return element.innerHTML;\n    }\n    for (var i = 0, childNodes = element.childNodes; i < childNodes.length; i++) {\n      JQLiteDealoc(childNodes[i]);\n    }\n    element.innerHTML = value;\n  }\n}, function(fn, name){\n  /**\n   * Properties: writes return selection, reads return first value\n   */\n  JQLite.prototype[name] = function(arg1, arg2) {\n    var i, key;\n\n    // JQLiteHasClass has only two arguments, but is a getter-only fn, so we need to special-case it\n    // in a way that survives minification.\n    if (((fn.length == 2 && (fn !== JQLiteHasClass && fn !== JQLiteController)) ? arg1 : arg2) === undefined) {\n      if (isObject(arg1)) {\n\n        // we are a write, but the object properties are the key/values\n        for(i=0; i < this.length; i++) {\n          if (fn === JQLiteData) {\n            // data() takes the whole object in jQuery\n            fn(this[i], arg1);\n          } else {\n            for (key in arg1) {\n              fn(this[i], key, arg1[key]);\n            }\n          }\n        }\n        // return self for chaining\n        return this;\n      } else {\n        // we are a read, so read the first child.\n        var value = fn.$dv;\n        // Only if we have $dv do we iterate over all, otherwise it is just the first element.\n        var jj = value == undefined ? Math.min(this.length, 1) : this.length;\n        for (var j = 0; j < jj; j++) {\n          var nodeValue = fn(this[j], arg1, arg2);\n          value = value ? value + nodeValue : nodeValue;\n        }\n        return value;\n      }\n    } else {\n      // we are a write, so apply to all children\n      for(i=0; i < this.length; i++) {\n        fn(this[i], arg1, arg2);\n      }\n      // return self for chaining\n      return this;\n    }\n  };\n});\n\nfunction createEventHandler(element, events) {\n  var eventHandler = function (event, type) {\n    if (!event.preventDefault) {\n      event.preventDefault = function() {\n        event.returnValue = false; //ie\n      };\n    }\n\n    if (!event.stopPropagation) {\n      event.stopPropagation = function() {\n        event.cancelBubble = true; //ie\n      };\n    }\n\n    if (!event.target) {\n      event.target = event.srcElement || document;\n    }\n\n    if (isUndefined(event.defaultPrevented)) {\n      var prevent = event.preventDefault;\n      event.preventDefault = function() {\n        event.defaultPrevented = true;\n        prevent.call(event);\n      };\n      event.defaultPrevented = false;\n    }\n\n    event.isDefaultPrevented = function() {\n      return event.defaultPrevented || event.returnValue == false;\n    };\n\n    forEach(events[type || event.type], function(fn) {\n      fn.call(element, event);\n    });\n\n    // Remove monkey-patched methods (IE),\n    // as they would cause memory leaks in IE8.\n    if (msie <= 8) {\n      // IE7/8 does not allow to delete property on native object\n      event.preventDefault = null;\n      event.stopPropagation = null;\n      event.isDefaultPrevented = null;\n    } else {\n      // It shouldn't affect normal browsers (native methods are defined on prototype).\n      delete event.preventDefault;\n      delete event.stopPropagation;\n      delete event.isDefaultPrevented;\n    }\n  };\n  eventHandler.elem = element;\n  return eventHandler;\n}\n\n//////////////////////////////////////////\n// Functions iterating traversal.\n// These functions chain results into a single\n// selector.\n//////////////////////////////////////////\nforEach({\n  removeData: JQLiteRemoveData,\n\n  dealoc: JQLiteDealoc,\n\n  on: function onFn(element, type, fn, unsupported){\n    if (isDefined(unsupported)) throw jqLiteMinErr('onargs', 'jqLite#on() does not support the `selector` or `eventData` parameters');\n\n    var events = JQLiteExpandoStore(element, 'events'),\n        handle = JQLiteExpandoStore(element, 'handle');\n\n    if (!events) JQLiteExpandoStore(element, 'events', events = {});\n    if (!handle) JQLiteExpandoStore(element, 'handle', handle = createEventHandler(element, events));\n\n    forEach(type.split(' '), function(type){\n      var eventFns = events[type];\n\n      if (!eventFns) {\n        if (type == 'mouseenter' || type == 'mouseleave') {\n          var contains = document.body.contains || document.body.compareDocumentPosition ?\n          function( a, b ) {\n            var adown = a.nodeType === 9 ? a.documentElement : a,\n            bup = b && b.parentNode;\n            return a === bup || !!( bup && bup.nodeType === 1 && (\n              adown.contains ?\n              adown.contains( bup ) :\n              a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16\n              ));\n            } :\n            function( a, b ) {\n              if ( b ) {\n                while ( (b = b.parentNode) ) {\n                  if ( b === a ) {\n                    return true;\n                  }\n                }\n              }\n              return false;\n            };\n\n          events[type] = [];\n\n          // Refer to jQuery's implementation of mouseenter & mouseleave\n          // Read about mouseenter and mouseleave:\n          // http://www.quirksmode.org/js/events_mouse.html#link8\n          var eventmap = { mouseleave : \"mouseout\", mouseenter : \"mouseover\"};\n\n          onFn(element, eventmap[type], function(event) {\n            var target = this, related = event.relatedTarget;\n            // For mousenter/leave call the handler if related is outside the target.\n            // NB: No relatedTarget if the mouse left/entered the browser window\n            if ( !related || (related !== target && !contains(target, related)) ){\n              handle(event, type);\n            }\n          });\n\n        } else {\n          addEventListenerFn(element, type, handle);\n          events[type] = [];\n        }\n        eventFns = events[type]\n      }\n      eventFns.push(fn);\n    });\n  },\n\n  off: JQLiteOff,\n\n  replaceWith: function(element, replaceNode) {\n    var index, parent = element.parentNode;\n    JQLiteDealoc(element);\n    forEach(new JQLite(replaceNode), function(node){\n      if (index) {\n        parent.insertBefore(node, index.nextSibling);\n      } else {\n        parent.replaceChild(node, element);\n      }\n      index = node;\n    });\n  },\n\n  children: function(element) {\n    var children = [];\n    forEach(element.childNodes, function(element){\n      if (element.nodeType === 1)\n        children.push(element);\n    });\n    return children;\n  },\n\n  contents: function(element) {\n    return element.childNodes || [];\n  },\n\n  append: function(element, node) {\n    forEach(new JQLite(node), function(child){\n      if (element.nodeType === 1 || element.nodeType === 11) {\n        element.appendChild(child);\n      }\n    });\n  },\n\n  prepend: function(element, node) {\n    if (element.nodeType === 1) {\n      var index = element.firstChild;\n      forEach(new JQLite(node), function(child){\n        element.insertBefore(child, index);\n      });\n    }\n  },\n\n  wrap: function(element, wrapNode) {\n    wrapNode = jqLite(wrapNode)[0];\n    var parent = element.parentNode;\n    if (parent) {\n      parent.replaceChild(wrapNode, element);\n    }\n    wrapNode.appendChild(element);\n  },\n\n  remove: function(element) {\n    JQLiteDealoc(element);\n    var parent = element.parentNode;\n    if (parent) parent.removeChild(element);\n  },\n\n  after: function(element, newElement) {\n    var index = element, parent = element.parentNode;\n    forEach(new JQLite(newElement), function(node){\n      parent.insertBefore(node, index.nextSibling);\n      index = node;\n    });\n  },\n\n  addClass: JQLiteAddClass,\n  removeClass: JQLiteRemoveClass,\n\n  toggleClass: function(element, selector, condition) {\n    if (isUndefined(condition)) {\n      condition = !JQLiteHasClass(element, selector);\n    }\n    (condition ? JQLiteAddClass : JQLiteRemoveClass)(element, selector);\n  },\n\n  parent: function(element) {\n    var parent = element.parentNode;\n    return parent && parent.nodeType !== 11 ? parent : null;\n  },\n\n  next: function(element) {\n    if (element.nextElementSibling) {\n      return element.nextElementSibling;\n    }\n\n    // IE8 doesn't have nextElementSibling\n    var elm = element.nextSibling;\n    while (elm != null && elm.nodeType !== 1) {\n      elm = elm.nextSibling;\n    }\n    return elm;\n  },\n\n  find: function(element, selector) {\n    return element.getElementsByTagName(selector);\n  },\n\n  clone: JQLiteClone,\n\n  triggerHandler: function(element, eventName, eventData) {\n    var eventFns = (JQLiteExpandoStore(element, 'events') || {})[eventName];\n    eventData = eventData || {\n      preventDefault: noop,\n      stopPropagation: noop\n    };\n\n    forEach(eventFns, function(fn) {\n      fn.call(element, eventData);\n    });\n  }\n}, function(fn, name){\n  /**\n   * chaining functions\n   */\n  JQLite.prototype[name] = function(arg1, arg2, arg3) {\n    var value;\n    for(var i=0; i < this.length; i++) {\n      if (value == undefined) {\n        value = fn(this[i], arg1, arg2, arg3);\n        if (value !== undefined) {\n          // any function which returns a value needs to be wrapped\n          value = jqLite(value);\n        }\n      } else {\n        JQLiteAddNodes(value, fn(this[i], arg1, arg2, arg3));\n      }\n    }\n    return value == undefined ? this : value;\n  };\n\n  // bind legacy bind/unbind to on/off\n  JQLite.prototype.bind = JQLite.prototype.on;\n  JQLite.prototype.unbind = JQLite.prototype.off;\n});\n\n/**\n * Computes a hash of an 'obj'.\n * Hash of a:\n *  string is string\n *  number is number as string\n *  object is either result of calling $$hashKey function on the object or uniquely generated id,\n *         that is also assigned to the $$hashKey property of the object.\n *\n * @param obj\n * @returns {string} hash string such that the same input will have the same hash string.\n *         The resulting string key is in 'type:hashKey' format.\n */\nfunction hashKey(obj) {\n  var objType = typeof obj,\n      key;\n\n  if (objType == 'object' && obj !== null) {\n    if (typeof (key = obj.$$hashKey) == 'function') {\n      // must invoke on object to keep the right this\n      key = obj.$$hashKey();\n    } else if (key === undefined) {\n      key = obj.$$hashKey = nextUid();\n    }\n  } else {\n    key = obj;\n  }\n\n  return objType + ':' + key;\n}\n\n/**\n * HashMap which can use objects as keys\n */\nfunction HashMap(array){\n  forEach(array, this.put, this);\n}\nHashMap.prototype = {\n  /**\n   * Store key value pair\n   * @param key key to store can be any type\n   * @param value value to store can be any type\n   */\n  put: function(key, value) {\n    this[hashKey(key)] = value;\n  },\n\n  /**\n   * @param key\n   * @returns the value for the key\n   */\n  get: function(key) {\n    return this[hashKey(key)];\n  },\n\n  /**\n   * Remove the key/value pair\n   * @param key\n   */\n  remove: function(key) {\n    var value = this[key = hashKey(key)];\n    delete this[key];\n    return value;\n  }\n};\n\n/**\n * @ngdoc function\n * @name angular.injector\n * @function\n *\n * @description\n * Creates an injector function that can be used for retrieving services as well as for\n * dependency injection (see {@link guide/di dependency injection}).\n *\n\n * @param {Array.<string|Function>} modules A list of module functions or their aliases. See\n *        {@link angular.module}. The `ng` module must be explicitly added.\n * @returns {function()} Injector function. See {@link AUTO.$injector $injector}.\n *\n * @example\n * Typical usage\n * <pre>\n *   // create an injector\n *   var $injector = angular.injector(['ng']);\n *\n *   // use the injector to kick off your application\n *   // use the type inference to auto inject arguments, or use implicit injection\n *   $injector.invoke(function($rootScope, $compile, $document){\n *     $compile($document)($rootScope);\n *     $rootScope.$digest();\n *   });\n * </pre>\n */\n\n\n/**\n * @ngdoc overview\n * @name AUTO\n * @description\n *\n * Implicit module which gets automatically added to each {@link AUTO.$injector $injector}.\n */\n\nvar FN_ARGS = /^function\\s*[^\\(]*\\(\\s*([^\\)]*)\\)/m;\nvar FN_ARG_SPLIT = /,/;\nvar FN_ARG = /^\\s*(_?)(\\S+?)\\1\\s*$/;\nvar STRIP_COMMENTS = /((\\/\\/.*$)|(\\/\\*[\\s\\S]*?\\*\\/))/mg;\nvar $injectorMinErr = minErr('$injector');\nfunction annotate(fn) {\n  var $inject,\n      fnText,\n      argDecl,\n      last;\n\n  if (typeof fn == 'function') {\n    if (!($inject = fn.$inject)) {\n      $inject = [];\n      if (fn.length) {\n        fnText = fn.toString().replace(STRIP_COMMENTS, '');\n        argDecl = fnText.match(FN_ARGS);\n        forEach(argDecl[1].split(FN_ARG_SPLIT), function(arg){\n          arg.replace(FN_ARG, function(all, underscore, name){\n            $inject.push(name);\n          });\n        });\n      }\n      fn.$inject = $inject;\n    }\n  } else if (isArray(fn)) {\n    last = fn.length - 1;\n    assertArgFn(fn[last], 'fn');\n    $inject = fn.slice(0, last);\n  } else {\n    assertArgFn(fn, 'fn', true);\n  }\n  return $inject;\n}\n\n///////////////////////////////////////\n\n/**\n * @ngdoc object\n * @name AUTO.$injector\n * @function\n *\n * @description\n *\n * `$injector` is used to retrieve object instances as defined by\n * {@link AUTO.$provide provider}, instantiate types, invoke methods,\n * and load modules.\n *\n * The following always holds true:\n *\n * <pre>\n *   var $injector = angular.injector();\n *   expect($injector.get('$injector')).toBe($injector);\n *   expect($injector.invoke(function($injector){\n *     return $injector;\n *   }).toBe($injector);\n * </pre>\n *\n * # Injection Function Annotation\n *\n * JavaScript does not have annotations, and annotations are needed for dependency injection. The\n * following are all valid ways of annotating function with injection arguments and are equivalent.\n *\n * <pre>\n *   // inferred (only works if code not minified/obfuscated)\n *   $injector.invoke(function(serviceA){});\n *\n *   // annotated\n *   function explicit(serviceA) {};\n *   explicit.$inject = ['serviceA'];\n *   $injector.invoke(explicit);\n *\n *   // inline\n *   $injector.invoke(['serviceA', function(serviceA){}]);\n * </pre>\n *\n * ## Inference\n *\n * In JavaScript calling `toString()` on a function returns the function definition. The definition can then be\n * parsed and the function arguments can be extracted. *NOTE:* This does not work with minification, and obfuscation\n * tools since these tools change the argument names.\n *\n * ## `$inject` Annotation\n * By adding a `$inject` property onto a function the injection parameters can be specified.\n *\n * ## Inline\n * As an array of injection names, where the last item in the array is the function to call.\n */\n\n/**\n * @ngdoc method\n * @name AUTO.$injector#get\n * @methodOf AUTO.$injector\n *\n * @description\n * Return an instance of the service.\n *\n * @param {string} name The name of the instance to retrieve.\n * @return {*} The instance.\n */\n\n/**\n * @ngdoc method\n * @name AUTO.$injector#invoke\n * @methodOf AUTO.$injector\n *\n * @description\n * Invoke the method and supply the method arguments from the `$injector`.\n *\n * @param {!function} fn The function to invoke. The function arguments come form the function annotation.\n * @param {Object=} self The `this` for the invoked method.\n * @param {Object=} locals Optional object. If preset then any argument names are read from this object first, before\n *   the `$injector` is consulted.\n * @returns {*} the value returned by the invoked `fn` function.\n */\n\n/**\n * @ngdoc method\n * @name AUTO.$injector#has\n * @methodOf AUTO.$injector\n *\n * @description\n * Allows the user to query if the particular service exist.\n *\n * @param {string} Name of the service to query.\n * @returns {boolean} returns true if injector has given service.\n */\n\n/**\n * @ngdoc method\n * @name AUTO.$injector#instantiate\n * @methodOf AUTO.$injector\n * @description\n * Create a new instance of JS type. The method takes a constructor function invokes the new operator and supplies\n * all of the arguments to the constructor function as specified by the constructor annotation.\n *\n * @param {function} Type Annotated constructor function.\n * @param {Object=} locals Optional object. If preset then any argument names are read from this object first, before\n *   the `$injector` is consulted.\n * @returns {Object} new instance of `Type`.\n */\n\n/**\n * @ngdoc method\n * @name AUTO.$injector#annotate\n * @methodOf AUTO.$injector\n *\n * @description\n * Returns an array of service names which the function is requesting for injection. This API is used by the injector\n * to determine which services need to be injected into the function when the function is invoked. There are three\n * ways in which the function can be annotated with the needed dependencies.\n *\n * # Argument names\n *\n * The simplest form is to extract the dependencies from the arguments of the function. This is done by converting\n * the function into a string using `toString()` method and extracting the argument names.\n * <pre>\n *   // Given\n *   function MyController($scope, $route) {\n *     // ...\n *   }\n *\n *   // Then\n *   expect(injector.annotate(MyController)).toEqual(['$scope', '$route']);\n * </pre>\n *\n * This method does not work with code minification / obfuscation. For this reason the following annotation strategies\n * are supported.\n *\n * # The `$inject` property\n *\n * If a function has an `$inject` property and its value is an array of strings, then the strings represent names of\n * services to be injected into the function.\n * <pre>\n *   // Given\n *   var MyController = function(obfuscatedScope, obfuscatedRoute) {\n *     // ...\n *   }\n *   // Define function dependencies\n *   MyController.$inject = ['$scope', '$route'];\n *\n *   // Then\n *   expect(injector.annotate(MyController)).toEqual(['$scope', '$route']);\n * </pre>\n *\n * # The array notation\n *\n * It is often desirable to inline Injected functions and that's when setting the `$inject` property is very\n * inconvenient. In these situations using the array notation to specify the dependencies in a way that survives\n * minification is a better choice:\n *\n * <pre>\n *   // We wish to write this (not minification / obfuscation safe)\n *   injector.invoke(function($compile, $rootScope) {\n *     // ...\n *   });\n *\n *   // We are forced to write break inlining\n *   var tmpFn = function(obfuscatedCompile, obfuscatedRootScope) {\n *     // ...\n *   };\n *   tmpFn.$inject = ['$compile', '$rootScope'];\n *   injector.invoke(tmpFn);\n *\n *   // To better support inline function the inline annotation is supported\n *   injector.invoke(['$compile', '$rootScope', function(obfCompile, obfRootScope) {\n *     // ...\n *   }]);\n *\n *   // Therefore\n *   expect(injector.annotate(\n *      ['$compile', '$rootScope', function(obfus_$compile, obfus_$rootScope) {}])\n *    ).toEqual(['$compile', '$rootScope']);\n * </pre>\n *\n * @param {function|Array.<string|Function>} fn Function for which dependent service names need to be retrieved as described\n *   above.\n *\n * @returns {Array.<string>} The names of the services which the function requires.\n */\n\n\n\n\n/**\n * @ngdoc object\n * @name AUTO.$provide\n *\n * @description\n *\n * Use `$provide` to register new providers with the `$injector`. The providers are the factories for the instance.\n * The providers share the same name as the instance they create with `Provider` suffixed to them.\n *\n * A provider is an object with a `$get()` method. The injector calls the `$get` method to create a new instance of\n * a service. The Provider can have additional methods which would allow for configuration of the provider.\n *\n * <pre>\n *   function GreetProvider() {\n *     var salutation = 'Hello';\n *\n *     this.salutation = function(text) {\n *       salutation = text;\n *     };\n *\n *     this.$get = function() {\n *       return function (name) {\n *         return salutation + ' ' + name + '!';\n *       };\n *     };\n *   }\n *\n *   describe('Greeter', function(){\n *\n *     beforeEach(module(function($provide) {\n *       $provide.provider('greet', GreetProvider);\n *     }));\n *\n *     it('should greet', inject(function(greet) {\n *       expect(greet('angular')).toEqual('Hello angular!');\n *     }));\n *\n *     it('should allow configuration of salutation', function() {\n *       module(function(greetProvider) {\n *         greetProvider.salutation('Ahoj');\n *       });\n *       inject(function(greet) {\n *         expect(greet('angular')).toEqual('Ahoj angular!');\n *       });\n *     });\n * </pre>\n */\n\n/**\n * @ngdoc method\n * @name AUTO.$provide#provider\n * @methodOf AUTO.$provide\n * @description\n *\n * Register a provider for a service. The providers can be retrieved and can have additional configuration methods.\n *\n * @param {string} name The name of the instance. NOTE: the provider will be available under `name + 'Provider'` key.\n * @param {(Object|function())} provider If the provider is:\n *\n *   - `Object`: then it should have a `$get` method. The `$get` method will be invoked using\n *               {@link AUTO.$injector#invoke $injector.invoke()} when an instance needs to be created.\n *   - `Constructor`: a new instance of the provider will be created using\n *               {@link AUTO.$injector#instantiate $injector.instantiate()}, then treated as `object`.\n *\n * @returns {Object} registered provider instance\n */\n\n/**\n * @ngdoc method\n * @name AUTO.$provide#factory\n * @methodOf AUTO.$provide\n * @description\n *\n * A short hand for configuring services if only `$get` method is required.\n *\n * @param {string} name The name of the instance.\n * @param {function()} $getFn The $getFn for the instance creation. Internally this is a short hand for\n * `$provide.provider(name, {$get: $getFn})`.\n * @returns {Object} registered provider instance\n */\n\n\n/**\n * @ngdoc method\n * @name AUTO.$provide#service\n * @methodOf AUTO.$provide\n * @description\n *\n * A short hand for registering service of given class.\n *\n * @param {string} name The name of the instance.\n * @param {Function} constructor A class (constructor function) that will be instantiated.\n * @returns {Object} registered provider instance\n */\n\n\n/**\n * @ngdoc method\n * @name AUTO.$provide#value\n * @methodOf AUTO.$provide\n * @description\n *\n * A short hand for configuring services if the `$get` method is a constant.\n *\n * @param {string} name The name of the instance.\n * @param {*} value The value.\n * @returns {Object} registered provider instance\n */\n\n\n/**\n * @ngdoc method\n * @name AUTO.$provide#constant\n * @methodOf AUTO.$provide\n * @description\n *\n * A constant value, but unlike {@link AUTO.$provide#value value} it can be injected\n * into configuration function (other modules) and it is not interceptable by\n * {@link AUTO.$provide#decorator decorator}.\n *\n * @param {string} name The name of the constant.\n * @param {*} value The constant value.\n * @returns {Object} registered instance\n */\n\n\n/**\n * @ngdoc method\n * @name AUTO.$provide#decorator\n * @methodOf AUTO.$provide\n * @description\n *\n * Decoration of service, allows the decorator to intercept the service instance creation. The\n * returned instance may be the original instance, or a new instance which delegates to the\n * original instance.\n *\n * @param {string} name The name of the service to decorate.\n * @param {function()} decorator This function will be invoked when the service needs to be\n *    instantiated. The function is called using the {@link AUTO.$injector#invoke\n *    injector.invoke} method and is therefore fully injectable. Local injection arguments:\n *\n *    * `$delegate` - The original service instance, which can be monkey patched, configured,\n *      decorated or delegated to.\n */\n\n\nfunction createInjector(modulesToLoad) {\n  var INSTANTIATING = {},\n      providerSuffix = 'Provider',\n      path = [],\n      loadedModules = new HashMap(),\n      providerCache = {\n        $provide: {\n            provider: supportObject(provider),\n            factory: supportObject(factory),\n            service: supportObject(service),\n            value: supportObject(value),\n            constant: supportObject(constant),\n            decorator: decorator\n          }\n      },\n      providerInjector = (providerCache.$injector =\n          createInternalInjector(providerCache, function() {\n            throw $injectorMinErr('unpr', \"Unknown provider: {0}\", path.join(' <- '));\n          })),\n      instanceCache = {},\n      instanceInjector = (instanceCache.$injector =\n          createInternalInjector(instanceCache, function(servicename) {\n            var provider = providerInjector.get(servicename + providerSuffix);\n            return instanceInjector.invoke(provider.$get, provider);\n          }));\n\n\n  forEach(loadModules(modulesToLoad), function(fn) { instanceInjector.invoke(fn || noop); });\n\n  return instanceInjector;\n\n  ////////////////////////////////////\n  // $provider\n  ////////////////////////////////////\n\n  function supportObject(delegate) {\n    return function(key, value) {\n      if (isObject(key)) {\n        forEach(key, reverseParams(delegate));\n      } else {\n        return delegate(key, value);\n      }\n    }\n  }\n\n  function provider(name, provider_) {\n    if (isFunction(provider_) || isArray(provider_)) {\n      provider_ = providerInjector.instantiate(provider_);\n    }\n    if (!provider_.$get) {\n      throw $injectorMinErr('pget', \"Provider '{0}' must define $get factory method.\", name);\n    }\n    return providerCache[name + providerSuffix] = provider_;\n  }\n\n  function factory(name, factoryFn) { return provider(name, { $get: factoryFn }); }\n\n  function service(name, constructor) {\n    return factory(name, ['$injector', function($injector) {\n      return $injector.instantiate(constructor);\n    }]);\n  }\n\n  function value(name, value) { return factory(name, valueFn(value)); }\n\n  function constant(name, value) {\n    providerCache[name] = value;\n    instanceCache[name] = value;\n  }\n\n  function decorator(serviceName, decorFn) {\n    var origProvider = providerInjector.get(serviceName + providerSuffix),\n        orig$get = origProvider.$get;\n\n    origProvider.$get = function() {\n      var origInstance = instanceInjector.invoke(orig$get, origProvider);\n      return instanceInjector.invoke(decorFn, null, {$delegate: origInstance});\n    };\n  }\n\n  ////////////////////////////////////\n  // Module Loading\n  ////////////////////////////////////\n  function loadModules(modulesToLoad){\n    var runBlocks = [];\n    forEach(modulesToLoad, function(module) {\n      if (loadedModules.get(module)) return;\n      loadedModules.put(module, true);\n\n      try {\n        if (isString(module)) {\n          var moduleFn = angularModule(module);\n          runBlocks = runBlocks.concat(loadModules(moduleFn.requires)).concat(moduleFn._runBlocks);\n\n          for(var invokeQueue = moduleFn._invokeQueue, i = 0, ii = invokeQueue.length; i < ii; i++) {\n            var invokeArgs = invokeQueue[i],\n                provider = providerInjector.get(invokeArgs[0]);\n\n            provider[invokeArgs[1]].apply(provider, invokeArgs[2]);\n          }\n        } else if (isFunction(module)) {\n            runBlocks.push(providerInjector.invoke(module));\n        } else if (isArray(module)) {\n            runBlocks.push(providerInjector.invoke(module));\n        } else {\n          assertArgFn(module, 'module');\n        }\n      } catch (e) {\n        if (isArray(module)) {\n          module = module[module.length - 1];\n        }\n        if (e.message && e.stack && e.stack.indexOf(e.message) == -1) {\n          // Safari & FF's stack traces don't contain error.message content unlike those of Chrome and IE\n          // So if stack doesn't contain message, we create a new string that contains both.\n          // Since error.stack is read-only in Safari, I'm overriding e and not e.stack here.\n          e = e.message + '\\n' + e.stack;\n        }\n        throw $injectorMinErr('modulerr', \"Failed to instantiate module {0} due to:\\n{1}\", module, e.stack || e.message || e);\n      }\n    });\n    return runBlocks;\n  }\n\n  ////////////////////////////////////\n  // internal Injector\n  ////////////////////////////////////\n\n  function createInternalInjector(cache, factory) {\n\n    function getService(serviceName) {\n      if (cache.hasOwnProperty(serviceName)) {\n        if (cache[serviceName] === INSTANTIATING) {\n          throw $injectorMinErr('cdep', 'Circular dependency found: {0}', path.join(' <- '));\n        }\n        return cache[serviceName];\n      } else {\n        try {\n          path.unshift(serviceName);\n          cache[serviceName] = INSTANTIATING;\n          return cache[serviceName] = factory(serviceName);\n        } finally {\n          path.shift();\n        }\n      }\n    }\n\n    function invoke(fn, self, locals){\n      var args = [],\n          $inject = annotate(fn),\n          length, i,\n          key;\n\n      for(i = 0, length = $inject.length; i < length; i++) {\n        key = $inject[i];\n        if (typeof key !== 'string') {\n          throw $injectorMinErr('itkn', 'Incorrect injection token! Expected service name as string, got {0}', key);\n        }\n        args.push(\n          locals && locals.hasOwnProperty(key)\n          ? locals[key]\n          : getService(key)\n        );\n      }\n      if (!fn.$inject) {\n        // this means that we must be an array.\n        fn = fn[length];\n      }\n\n\n      // Performance optimization: http://jsperf.com/apply-vs-call-vs-invoke\n      switch (self ? -1 : args.length) {\n        case  0: return fn();\n        case  1: return fn(args[0]);\n        case  2: return fn(args[0], args[1]);\n        case  3: return fn(args[0], args[1], args[2]);\n        case  4: return fn(args[0], args[1], args[2], args[3]);\n        case  5: return fn(args[0], args[1], args[2], args[3], args[4]);\n        case  6: return fn(args[0], args[1], args[2], args[3], args[4], args[5]);\n        case  7: return fn(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);\n        case  8: return fn(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7]);\n        case  9: return fn(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8]);\n        case 10: return fn(args[0], args[1], args[2], args[3], args[4], args[5], args[6], args[7], args[8], args[9]);\n        default: return fn.apply(self, args);\n      }\n    }\n\n    function instantiate(Type, locals) {\n      var Constructor = function() {},\n          instance, returnedValue;\n\n      // Check if Type is annotated and use just the given function at n-1 as parameter\n      // e.g. someModule.factory('greeter', ['$window', function(renamed$window) {}]);\n      Constructor.prototype = (isArray(Type) ? Type[Type.length - 1] : Type).prototype;\n      instance = new Constructor();\n      returnedValue = invoke(Type, instance, locals);\n\n      return isObject(returnedValue) ? returnedValue : instance;\n    }\n\n    return {\n      invoke: invoke,\n      instantiate: instantiate,\n      get: getService,\n      annotate: annotate,\n      has: function(name) {\n        return providerCache.hasOwnProperty(name + providerSuffix) || cache.hasOwnProperty(name);\n      }\n    };\n  }\n}\n\n/**\n * @ngdoc function\n * @name ng.$anchorScroll\n * @requires $window\n * @requires $location\n * @requires $rootScope\n *\n * @description\n * When called, it checks current value of `$location.hash()` and scroll to related element,\n * according to rules specified in\n * {@link http://dev.w3.org/html5/spec/Overview.html#the-indicated-part-of-the-document Html5 spec}.\n *\n * It also watches the `$location.hash()` and scroll whenever it changes to match any anchor.\n * This can be disabled by calling `$anchorScrollProvider.disableAutoScrolling()`.\n */\nfunction $AnchorScrollProvider() {\n\n  var autoScrollingEnabled = true;\n\n  this.disableAutoScrolling = function() {\n    autoScrollingEnabled = false;\n  };\n\n  this.$get = ['$window', '$location', '$rootScope', function($window, $location, $rootScope) {\n    var document = $window.document;\n\n    // helper function to get first anchor from a NodeList\n    // can't use filter.filter, as it accepts only instances of Array\n    // and IE can't convert NodeList to an array using [].slice\n    // TODO(vojta): use filter if we change it to accept lists as well\n    function getFirstAnchor(list) {\n      var result = null;\n      forEach(list, function(element) {\n        if (!result && lowercase(element.nodeName) === 'a') result = element;\n      });\n      return result;\n    }\n\n    function scroll() {\n      var hash = $location.hash(), elm;\n\n      // empty hash, scroll to the top of the page\n      if (!hash) $window.scrollTo(0, 0);\n\n      // element with given id\n      else if ((elm = document.getElementById(hash))) elm.scrollIntoView();\n\n      // first anchor with given name :-D\n      else if ((elm = getFirstAnchor(document.getElementsByName(hash)))) elm.scrollIntoView();\n\n      // no element and hash == 'top', scroll to the top of the page\n      else if (hash === 'top') $window.scrollTo(0, 0);\n    }\n\n    // does not scroll when user clicks on anchor link that is currently on\n    // (no url change, no $location.hash() change), browser native does scroll\n    if (autoScrollingEnabled) {\n      $rootScope.$watch(function autoScrollWatch() {return $location.hash();},\n        function autoScrollWatchAction() {\n          $rootScope.$evalAsync(scroll);\n        });\n    }\n\n    return scroll;\n  }];\n}\n\nvar $animateMinErr = minErr('$animate');\n\n/**\n * @ngdoc object\n * @name ng.$animateProvider\n *\n * @description\n * Default implementation of $animate that doesn't perform any animations, instead just synchronously performs DOM\n * updates and calls done() callbacks.\n *\n * In order to enable animations the ngAnimate module has to be loaded.\n *\n * To see the functional implementation check out src/ngAnimate/animate.js\n */\nvar $AnimateProvider = ['$provide', function($provide) {\n\n  this.$$selectors = {};\n\n\n  /**\n   * @ngdoc function\n   * @name ng.$animateProvider#register\n   * @methodOf ng.$animateProvider\n   *\n   * @description\n   * Registers a new injectable animation factory function. The factory function produces the animation object which\n   * contains callback functions for each event that is expected to be animated.\n   *\n   *   * `eventFn`: `function(Element, doneFunction)` The element to animate, the `doneFunction` must be called once the\n   *   element animation is complete. If a function is returned then the animation service will use this function to\n   *   cancel the animation whenever a cancel event is triggered.\n   *\n   *\n   *<pre>\n   *   return {\n     *     eventFn : function(element, done) {\n     *       //code to run the animation\n     *       //once complete, then run done()\n     *       return function cancellationFunction() {\n     *         //code to cancel the animation\n     *       }\n     *     }\n     *   }\n   *</pre>\n   *\n   * @param {string} name The name of the animation.\n   * @param {function} factory The factory function that will be executed to return the animation object.\n   */\n  this.register = function(name, factory) {\n    var key = name + '-animation';\n    if (name && name.charAt(0) != '.') throw $animateMinErr('notcsel',\n        \"Expecting class selector starting with '.' got '{0}'.\", name);\n    this.$$selectors[name.substr(1)] = key;\n    $provide.factory(key, factory);\n  };\n\n  this.$get = ['$timeout', function($timeout) {\n\n    /**\n     * @ngdoc object\n     * @name ng.$animate\n     *\n     * @description\n     * The $animate service provides rudimentary DOM manipulation functions to insert, remove, move elements within\n     * the DOM as well as adding and removing classes. This service is the core service used by the ngAnimate $animator\n     * service which provides high-level animation hooks for CSS and JavaScript. \n     *\n     * $animate is available in the AngularJS core, however, the ngAnimate module must be included to enable full out\n     * animation support. Otherwise, $animate will only perform simple DOM manipulation operations.\n     *\n     * To learn more about enabling animation support, click here to visit the {@link ngAnimate ngAnimate module page}\n     * as well as the {@link ngAnimate.$animate ngAnimate $animate service page}.\n     */\n    return {\n\n      /**\n       * @ngdoc function\n       * @name ng.$animate#enter\n       * @methodOf ng.$animate\n       * @function\n       *\n       * @description\n       * Inserts the element into the DOM either after the `after` element or within the `parent` element. Once complete,\n       * the done() callback will be fired (if provided).\n       *\n       * @param {jQuery/jqLite element} element the element which will be inserted into the DOM\n       * @param {jQuery/jqLite element} parent the parent element which will append the element as a child (if the after element is not present)\n       * @param {jQuery/jqLite element} after the sibling element which will append the element after itself\n       * @param {function=} done callback function that will be called after the element has been inserted into the DOM\n       */\n      enter : function(element, parent, after, done) {\n        var afterNode = after && after[after.length - 1];\n        var parentNode = parent && parent[0] || afterNode && afterNode.parentNode;\n        // IE does not like undefined so we have to pass null.\n        var afterNextSibling = (afterNode && afterNode.nextSibling) || null;\n        forEach(element, function(node) {\n          parentNode.insertBefore(node, afterNextSibling);\n        });\n        done && $timeout(done, 0, false);\n      },\n\n      /**\n       * @ngdoc function\n       * @name ng.$animate#leave\n       * @methodOf ng.$animate\n       * @function\n       *\n       * @description\n       * Removes the element from the DOM. Once complete, the done() callback will be fired (if provided).\n       *\n       * @param {jQuery/jqLite element} element the element which will be removed from the DOM\n       * @param {function=} done callback function that will be called after the element has been removed from the DOM\n       */\n      leave : function(element, done) {\n        element.remove();\n        done && $timeout(done, 0, false);\n      },\n\n      /**\n       * @ngdoc function\n       * @name ng.$animate#move\n       * @methodOf ng.$animate\n       * @function\n       *\n       * @description\n       * Moves the position of the provided element within the DOM to be placed either after the `after` element or inside of the `parent` element.\n       * Once complete, the done() callback will be fired (if provided).\n       *\n       * @param {jQuery/jqLite element} element the element which will be moved around within the DOM\n       * @param {jQuery/jqLite element} parent the parent element where the element will be inserted into (if the after element is not present)\n       * @param {jQuery/jqLite element} after the sibling element where the element will be positioned next to\n       * @param {function=} done the callback function (if provided) that will be fired after the element has been moved to it's new position\n       */\n      move : function(element, parent, after, done) {\n        // Do not remove element before insert. Removing will cause data associated with the\n        // element to be dropped. Insert will implicitly do the remove.\n        this.enter(element, parent, after, done);\n      },\n\n      /**\n       * @ngdoc function\n       * @name ng.$animate#addClass\n       * @methodOf ng.$animate\n       * @function\n       *\n       * @description\n       * Adds the provided className CSS class value to the provided element. Once complete, the done() callback will be fired (if provided).\n       *\n       * @param {jQuery/jqLite element} element the element which will have the className value added to it\n       * @param {string} className the CSS class which will be added to the element\n       * @param {function=} done the callback function (if provided) that will be fired after the className value has been added to the element\n       */\n      addClass : function(element, className, done) {\n        className = isString(className) ?\n                      className :\n                      isArray(className) ? className.join(' ') : '';\n        element.addClass(className);\n        done && $timeout(done, 0, false);\n      },\n\n      /**\n       * @ngdoc function\n       * @name ng.$animate#removeClass\n       * @methodOf ng.$animate\n       * @function\n       *\n       * @description\n       * Removes the provided className CSS class value from the provided element. Once complete, the done() callback will be fired (if provided).\n       *\n       * @param {jQuery/jqLite element} element the element which will have the className value removed from it\n       * @param {string} className the CSS class which will be removed from the element\n       * @param {function=} done the callback function (if provided) that will be fired after the className value has been removed from the element\n       */\n      removeClass : function(element, className, done) {\n        className = isString(className) ?\n                      className :\n                      isArray(className) ? className.join(' ') : '';\n        element.removeClass(className);\n        done && $timeout(done, 0, false);\n      },\n\n      enabled : noop\n    };\n  }];\n}];\n\n/**\n * ! This is a private undocumented service !\n *\n * @name ng.$browser\n * @requires $log\n * @description\n * This object has two goals:\n *\n * - hide all the global state in the browser caused by the window object\n * - abstract away all the browser specific features and inconsistencies\n *\n * For tests we provide {@link ngMock.$browser mock implementation} of the `$browser`\n * service, which can be used for convenient testing of the application without the interaction with\n * the real browser apis.\n */\n/**\n * @param {object} window The global window object.\n * @param {object} document jQuery wrapped document.\n * @param {function()} XHR XMLHttpRequest constructor.\n * @param {object} $log console.log or an object with the same interface.\n * @param {object} $sniffer $sniffer service\n */\nfunction Browser(window, document, $log, $sniffer) {\n  var self = this,\n      rawDocument = document[0],\n      location = window.location,\n      history = window.history,\n      setTimeout = window.setTimeout,\n      clearTimeout = window.clearTimeout,\n      pendingDeferIds = {};\n\n  self.isMock = false;\n\n  var outstandingRequestCount = 0;\n  var outstandingRequestCallbacks = [];\n\n  // TODO(vojta): remove this temporary api\n  self.$$completeOutstandingRequest = completeOutstandingRequest;\n  self.$$incOutstandingRequestCount = function() { outstandingRequestCount++; };\n\n  /**\n   * Executes the `fn` function(supports currying) and decrements the `outstandingRequestCallbacks`\n   * counter. If the counter reaches 0, all the `outstandingRequestCallbacks` are executed.\n   */\n  function completeOutstandingRequest(fn) {\n    try {\n      fn.apply(null, sliceArgs(arguments, 1));\n    } finally {\n      outstandingRequestCount--;\n      if (outstandingRequestCount === 0) {\n        while(outstandingRequestCallbacks.length) {\n          try {\n            outstandingRequestCallbacks.pop()();\n          } catch (e) {\n            $log.error(e);\n          }\n        }\n      }\n    }\n  }\n\n  /**\n   * @private\n   * Note: this method is used only by scenario runner\n   * TODO(vojta): prefix this method with $$ ?\n   * @param {function()} callback Function that will be called when no outstanding request\n   */\n  self.notifyWhenNoOutstandingRequests = function(callback) {\n    // force browser to execute all pollFns - this is needed so that cookies and other pollers fire\n    // at some deterministic time in respect to the test runner's actions. Leaving things up to the\n    // regular poller would result in flaky tests.\n    forEach(pollFns, function(pollFn){ pollFn(); });\n\n    if (outstandingRequestCount === 0) {\n      callback();\n    } else {\n      outstandingRequestCallbacks.push(callback);\n    }\n  };\n\n  //////////////////////////////////////////////////////////////\n  // Poll Watcher API\n  //////////////////////////////////////////////////////////////\n  var pollFns = [],\n      pollTimeout;\n\n  /**\n   * @name ng.$browser#addPollFn\n   * @methodOf ng.$browser\n   *\n   * @param {function()} fn Poll function to add\n   *\n   * @description\n   * Adds a function to the list of functions that poller periodically executes,\n   * and starts polling if not started yet.\n   *\n   * @returns {function()} the added function\n   */\n  self.addPollFn = function(fn) {\n    if (isUndefined(pollTimeout)) startPoller(100, setTimeout);\n    pollFns.push(fn);\n    return fn;\n  };\n\n  /**\n   * @param {number} interval How often should browser call poll functions (ms)\n   * @param {function()} setTimeout Reference to a real or fake `setTimeout` function.\n   *\n   * @description\n   * Configures the poller to run in the specified intervals, using the specified\n   * setTimeout fn and kicks it off.\n   */\n  function startPoller(interval, setTimeout) {\n    (function check() {\n      forEach(pollFns, function(pollFn){ pollFn(); });\n      pollTimeout = setTimeout(check, interval);\n    })();\n  }\n\n  //////////////////////////////////////////////////////////////\n  // URL API\n  //////////////////////////////////////////////////////////////\n\n  var lastBrowserUrl = location.href,\n      baseElement = document.find('base'),\n      replacedUrl = null;\n\n  /**\n   * @name ng.$browser#url\n   * @methodOf ng.$browser\n   *\n   * @description\n   * GETTER:\n   * Without any argument, this method just returns current value of location.href.\n   *\n   * SETTER:\n   * With at least one argument, this method sets url to new value.\n   * If html5 history api supported, pushState/replaceState is used, otherwise\n   * location.href/location.replace is used.\n   * Returns its own instance to allow chaining\n   *\n   * NOTE: this api is intended for use only by the $location service. Please use the\n   * {@link ng.$location $location service} to change url.\n   *\n   * @param {string} url New url (when used as setter)\n   * @param {boolean=} replace Should new url replace current history record ?\n   */\n  self.url = function(url, replace) {\n    // setter\n    if (url) {\n      if (lastBrowserUrl == url) return;\n      lastBrowserUrl = url;\n      if ($sniffer.history) {\n        if (replace) history.replaceState(null, '', url);\n        else {\n          history.pushState(null, '', url);\n          // Crazy Opera Bug: http://my.opera.com/community/forums/topic.dml?id=1185462\n          baseElement.attr('href', baseElement.attr('href'));\n        }\n      } else {\n        if (replace) {\n          location.replace(url);\n          replacedUrl = url;\n        } else {\n          location.href = url;\n          replacedUrl = null;\n        }\n      }\n      return self;\n    // getter\n    } else {\n      // - the replacedUrl is a workaround for an IE8-9 issue with location.replace method that doesn't update\n      //   location.href synchronously\n      // - the replacement is a workaround for https://bugzilla.mozilla.org/show_bug.cgi?id=407172\n      return replacedUrl || location.href.replace(/%27/g,\"'\");\n    }\n  };\n\n  var urlChangeListeners = [],\n      urlChangeInit = false;\n\n  function fireUrlChange() {\n    if (lastBrowserUrl == self.url()) return;\n\n    lastBrowserUrl = self.url();\n    forEach(urlChangeListeners, function(listener) {\n      listener(self.url());\n    });\n  }\n\n  /**\n   * @name ng.$browser#onUrlChange\n   * @methodOf ng.$browser\n   * @TODO(vojta): refactor to use node's syntax for events\n   *\n   * @description\n   * Register callback function that will be called, when url changes.\n   *\n   * It's only called when the url is changed by outside of angular:\n   * - user types different url into address bar\n   * - user clicks on history (forward/back) button\n   * - user clicks on a link\n   *\n   * It's not called when url is changed by $browser.url() method\n   *\n   * The listener gets called with new url as parameter.\n   *\n   * NOTE: this api is intended for use only by the $location service. Please use the\n   * {@link ng.$location $location service} to monitor url changes in angular apps.\n   *\n   * @param {function(string)} listener Listener function to be called when url changes.\n   * @return {function(string)} Returns the registered listener fn - handy if the fn is anonymous.\n   */\n  self.onUrlChange = function(callback) {\n    if (!urlChangeInit) {\n      // We listen on both (hashchange/popstate) when available, as some browsers (e.g. Opera)\n      // don't fire popstate when user change the address bar and don't fire hashchange when url\n      // changed by push/replaceState\n\n      // html5 history api - popstate event\n      if ($sniffer.history) jqLite(window).on('popstate', fireUrlChange);\n      // hashchange event\n      if ($sniffer.hashchange) jqLite(window).on('hashchange', fireUrlChange);\n      // polling\n      else self.addPollFn(fireUrlChange);\n\n      urlChangeInit = true;\n    }\n\n    urlChangeListeners.push(callback);\n    return callback;\n  };\n\n  //////////////////////////////////////////////////////////////\n  // Misc API\n  //////////////////////////////////////////////////////////////\n\n  /**\n   * Returns current <base href>\n   * (always relative - without domain)\n   *\n   * @returns {string=}\n   */\n  self.baseHref = function() {\n    var href = baseElement.attr('href');\n    return href ? href.replace(/^https?\\:\\/\\/[^\\/]*/, '') : '';\n  };\n\n  //////////////////////////////////////////////////////////////\n  // Cookies API\n  //////////////////////////////////////////////////////////////\n  var lastCookies = {};\n  var lastCookieString = '';\n  var cookiePath = self.baseHref();\n\n  /**\n   * @name ng.$browser#cookies\n   * @methodOf ng.$browser\n   *\n   * @param {string=} name Cookie name\n   * @param {string=} value Cookie value\n   *\n   * @description\n   * The cookies method provides a 'private' low level access to browser cookies.\n   * It is not meant to be used directly, use the $cookie service instead.\n   *\n   * The return values vary depending on the arguments that the method was called with as follows:\n   * <ul>\n   *   <li>cookies() -> hash of all cookies, this is NOT a copy of the internal state, so do not modify it</li>\n   *   <li>cookies(name, value) -> set name to value, if value is undefined delete the cookie</li>\n   *   <li>cookies(name) -> the same as (name, undefined) == DELETES (no one calls it right now that way)</li>\n   * </ul>\n   *\n   * @returns {Object} Hash of all cookies (if called without any parameter)\n   */\n  self.cookies = function(name, value) {\n    var cookieLength, cookieArray, cookie, i, index;\n\n    if (name) {\n      if (value === undefined) {\n        rawDocument.cookie = escape(name) + \"=;path=\" + cookiePath + \";expires=Thu, 01 Jan 1970 00:00:00 GMT\";\n      } else {\n        if (isString(value)) {\n          cookieLength = (rawDocument.cookie = escape(name) + '=' + escape(value) + ';path=' + cookiePath).length + 1;\n\n          // per http://www.ietf.org/rfc/rfc2109.txt browser must allow at minimum:\n          // - 300 cookies\n          // - 20 cookies per unique domain\n          // - 4096 bytes per cookie\n          if (cookieLength > 4096) {\n            $log.warn(\"Cookie '\"+ name +\"' possibly not set or overflowed because it was too large (\"+\n              cookieLength + \" > 4096 bytes)!\");\n          }\n        }\n      }\n    } else {\n      if (rawDocument.cookie !== lastCookieString) {\n        lastCookieString = rawDocument.cookie;\n        cookieArray = lastCookieString.split(\"; \");\n        lastCookies = {};\n\n        for (i = 0; i < cookieArray.length; i++) {\n          cookie = cookieArray[i];\n          index = cookie.indexOf('=');\n          if (index > 0) { //ignore nameless cookies\n            var name = unescape(cookie.substring(0, index));\n            // the first value that is seen for a cookie is the most\n            // specific one.  values for the same cookie name that\n            // follow are for less specific paths.\n            if (lastCookies[name] === undefined) {\n              lastCookies[name] = unescape(cookie.substring(index + 1));\n            }\n          }\n        }\n      }\n      return lastCookies;\n    }\n  };\n\n\n  /**\n   * @name ng.$browser#defer\n   * @methodOf ng.$browser\n   * @param {function()} fn A function, who's execution should be deferred.\n   * @param {number=} [delay=0] of milliseconds to defer the function execution.\n   * @returns {*} DeferId that can be used to cancel the task via `$browser.defer.cancel()`.\n   *\n   * @description\n   * Executes a fn asynchronously via `setTimeout(fn, delay)`.\n   *\n   * Unlike when calling `setTimeout` directly, in test this function is mocked and instead of using\n   * `setTimeout` in tests, the fns are queued in an array, which can be programmatically flushed\n   * via `$browser.defer.flush()`.\n   *\n   */\n  self.defer = function(fn, delay) {\n    var timeoutId;\n    outstandingRequestCount++;\n    timeoutId = setTimeout(function() {\n      delete pendingDeferIds[timeoutId];\n      completeOutstandingRequest(fn);\n    }, delay || 0);\n    pendingDeferIds[timeoutId] = true;\n    return timeoutId;\n  };\n\n\n  /**\n   * @name ng.$browser#defer.cancel\n   * @methodOf ng.$browser.defer\n   *\n   * @description\n   * Cancels a deferred task identified with `deferId`.\n   *\n   * @param {*} deferId Token returned by the `$browser.defer` function.\n   * @returns {boolean} Returns `true` if the task hasn't executed yet and was successfully canceled.\n   */\n  self.defer.cancel = function(deferId) {\n    if (pendingDeferIds[deferId]) {\n      delete pendingDeferIds[deferId];\n      clearTimeout(deferId);\n      completeOutstandingRequest(noop);\n      return true;\n    }\n    return false;\n  };\n\n}\n\nfunction $BrowserProvider(){\n  this.$get = ['$window', '$log', '$sniffer', '$document',\n      function( $window,   $log,   $sniffer,   $document){\n        return new Browser($window, $document, $log, $sniffer);\n      }];\n}\n\n/**\n * @ngdoc object\n * @name ng.$cacheFactory\n *\n * @description\n * Factory that constructs cache objects and gives access to them.\n * \n * <pre>\n * \n *  var cache = $cacheFactory('cacheId');\n *  expect($cacheFactory.get('cacheId')).toBe(cache);\n *  expect($cacheFactory.get('noSuchCacheId')).not.toBeDefined();\n *\n *  cache.put(\"key\", \"value\");\n *  cache.put(\"another key\", \"another value\");\n * \n *  expect(cache.info()).toEqual({id: 'cacheId', size: 2}); // Since we've specified no options on creation\n * \n * </pre>\n *\n *\n * @param {string} cacheId Name or id of the newly created cache.\n * @param {object=} options Options object that specifies the cache behavior. Properties:\n *\n *   - `{number=}` `capacity` — turns the cache into LRU cache.\n *\n * @returns {object} Newly created cache object with the following set of methods:\n *\n * - `{object}` `info()` — Returns id, size, and options of cache.\n * - `{{*}}` `put({string} key, {*} value)` — Puts a new key-value pair into the cache and returns it.\n * - `{{*}}` `get({string} key)` — Returns cached value for `key` or undefined for cache miss.\n * - `{void}` `remove({string} key)` — Removes a key-value pair from the cache.\n * - `{void}` `removeAll()` — Removes all cached values.\n * - `{void}` `destroy()` — Removes references to this cache from $cacheFactory.\n *\n */\nfunction $CacheFactoryProvider() {\n\n  this.$get = function() {\n    var caches = {};\n\n    function cacheFactory(cacheId, options) {\n      if (cacheId in caches) {\n        throw minErr('$cacheFactory')('iid', \"CacheId '{0}' is already taken!\", cacheId);\n      }\n\n      var size = 0,\n          stats = extend({}, options, {id: cacheId}),\n          data = {},\n          capacity = (options && options.capacity) || Number.MAX_VALUE,\n          lruHash = {},\n          freshEnd = null,\n          staleEnd = null;\n\n      return caches[cacheId] = {\n\n        put: function(key, value) {\n          var lruEntry = lruHash[key] || (lruHash[key] = {key: key});\n\n          refresh(lruEntry);\n\n          if (isUndefined(value)) return;\n          if (!(key in data)) size++;\n          data[key] = value;\n\n          if (size > capacity) {\n            this.remove(staleEnd.key);\n          }\n\n          return value;\n        },\n\n\n        get: function(key) {\n          var lruEntry = lruHash[key];\n\n          if (!lruEntry) return;\n\n          refresh(lruEntry);\n\n          return data[key];\n        },\n\n\n        remove: function(key) {\n          var lruEntry = lruHash[key];\n\n          if (!lruEntry) return;\n\n          if (lruEntry == freshEnd) freshEnd = lruEntry.p;\n          if (lruEntry == staleEnd) staleEnd = lruEntry.n;\n          link(lruEntry.n,lruEntry.p);\n\n          delete lruHash[key];\n          delete data[key];\n          size--;\n        },\n\n\n        removeAll: function() {\n          data = {};\n          size = 0;\n          lruHash = {};\n          freshEnd = staleEnd = null;\n        },\n\n\n        destroy: function() {\n          data = null;\n          stats = null;\n          lruHash = null;\n          delete caches[cacheId];\n        },\n\n\n        info: function() {\n          return extend({}, stats, {size: size});\n        }\n      };\n\n\n      /**\n       * makes the `entry` the freshEnd of the LRU linked list\n       */\n      function refresh(entry) {\n        if (entry != freshEnd) {\n          if (!staleEnd) {\n            staleEnd = entry;\n          } else if (staleEnd == entry) {\n            staleEnd = entry.n;\n          }\n\n          link(entry.n, entry.p);\n          link(entry, freshEnd);\n          freshEnd = entry;\n          freshEnd.n = null;\n        }\n      }\n\n\n      /**\n       * bidirectionally links two entries of the LRU linked list\n       */\n      function link(nextEntry, prevEntry) {\n        if (nextEntry != prevEntry) {\n          if (nextEntry) nextEntry.p = prevEntry; //p stands for previous, 'prev' didn't minify\n          if (prevEntry) prevEntry.n = nextEntry; //n stands for next, 'next' didn't minify\n        }\n      }\n    }\n\n\n  /**\n   * @ngdoc method\n   * @name ng.$cacheFactory#info\n   * @methodOf ng.$cacheFactory\n   *\n   * @description\n   * Get information about all the of the caches that have been created\n   *\n   * @returns {Object} - key-value map of `cacheId` to the result of calling `cache#info`\n   */\n    cacheFactory.info = function() {\n      var info = {};\n      forEach(caches, function(cache, cacheId) {\n        info[cacheId] = cache.info();\n      });\n      return info;\n    };\n\n\n  /**\n   * @ngdoc method\n   * @name ng.$cacheFactory#get\n   * @methodOf ng.$cacheFactory\n   *\n   * @description\n   * Get access to a cache object by the `cacheId` used when it was created.\n   *\n   * @param {string} cacheId Name or id of a cache to access.\n   * @returns {object} Cache object identified by the cacheId or undefined if no such cache.\n   */\n    cacheFactory.get = function(cacheId) {\n      return caches[cacheId];\n    };\n\n\n    return cacheFactory;\n  };\n}\n\n/**\n * @ngdoc object\n * @name ng.$templateCache\n *\n * @description\n * The first time a template is used, it is loaded in the template cache for quick retrieval. You can\n * load templates directly into the cache in a `script` tag, or by consuming the `$templateCache`\n * service directly.\n * \n * Adding via the `script` tag:\n * <pre>\n * <html ng-app>\n * <head>\n * <script type=\"text/ng-template\" id=\"templateId.html\">\n *   This is the content of the template\n * </script>\n * </head>\n *   ...\n * </html>\n * </pre>\n * \n * **Note:** the `script` tag containing the template does not need to be included in the `head` of the document, but \n * it must be below the `ng-app` definition.\n * \n * Adding via the $templateCache service:\n * \n * <pre>\n * var myApp = angular.module('myApp', []);\n * myApp.run(function($templateCache) {\n *   $templateCache.put('templateId.html', 'This is the content of the template');\n * });\n * </pre>\n * \n * To retrieve the template later, simply use it in your HTML:\n * <pre>\n * <div ng-include=\" 'templateId.html' \"></div>\n * </pre>\n * \n * or get it via Javascript:\n * <pre>\n * $templateCache.get('templateId.html')\n * </pre>\n * \n * See {@link ng.$cacheFactory $cacheFactory}.\n *\n */\nfunction $TemplateCacheProvider() {\n  this.$get = ['$cacheFactory', function($cacheFactory) {\n    return $cacheFactory('templates');\n  }];\n}\n\n/* ! VARIABLE/FUNCTION NAMING CONVENTIONS THAT APPLY TO THIS FILE!\n *\n * DOM-related variables:\n *\n * - \"node\" - DOM Node\n * - \"element\" - DOM Element or Node\n * - \"$node\" or \"$element\" - jqLite-wrapped node or element\n *\n *\n * Compiler related stuff:\n *\n * - \"linkFn\" - linking fn of a single directive\n * - \"nodeLinkFn\" - function that aggregates all linking fns for a particular node\n * - \"childLinkFn\" -  function that aggregates all linking fns for child nodes of a particular node\n * - \"compositeLinkFn\" - function that aggregates all linking fns for a compilation root (nodeList)\n */\n\n\n/**\n * @ngdoc function\n * @name ng.$compile\n * @function\n *\n * @description\n * Compiles a piece of HTML string or DOM into a template and produces a template function, which\n * can then be used to link {@link ng.$rootScope.Scope scope} and the template together.\n *\n * The compilation is a process of walking the DOM tree and trying to match DOM elements to\n * {@link ng.$compileProvider#directive directives}. For each match it\n * executes corresponding template function and collects the\n * instance functions into a single template function which is then returned.\n *\n * The template function can then be used once to produce the view or as it is the case with\n * {@link ng.directive:ngRepeat repeater} many-times, in which\n * case each call results in a view that is a DOM clone of the original template.\n *\n <doc:example module=\"compile\">\n   <doc:source>\n    <script>\n      // declare a new module, and inject the $compileProvider\n      angular.module('compile', [], function($compileProvider) {\n        // configure new 'compile' directive by passing a directive\n        // factory function. The factory function injects the '$compile'\n        $compileProvider.directive('compile', function($compile) {\n          // directive factory creates a link function\n          return function(scope, element, attrs) {\n            scope.$watch(\n              function(scope) {\n                 // watch the 'compile' expression for changes\n                return scope.$eval(attrs.compile);\n              },\n              function(value) {\n                // when the 'compile' expression changes\n                // assign it into the current DOM\n                element.html(value);\n\n                // compile the new DOM and link it to the current\n                // scope.\n                // NOTE: we only compile .childNodes so that\n                // we don't get into infinite loop compiling ourselves\n                $compile(element.contents())(scope);\n              }\n            );\n          };\n        })\n      });\n\n      function Ctrl($scope) {\n        $scope.name = 'Angular';\n        $scope.html = 'Hello {{name}}';\n      }\n    </script>\n    <div ng-controller=\"Ctrl\">\n      <input ng-model=\"name\"> <br>\n      <textarea ng-model=\"html\"></textarea> <br>\n      <div compile=\"html\"></div>\n    </div>\n   </doc:source>\n   <doc:scenario>\n     it('should auto compile', function() {\n       expect(element('div[compile]').text()).toBe('Hello Angular');\n       input('html').enter('{{name}}!');\n       expect(element('div[compile]').text()).toBe('Angular!');\n     });\n   </doc:scenario>\n </doc:example>\n\n *\n *\n * @param {string|DOMElement} element Element or HTML string to compile into a template function.\n * @param {function(angular.Scope[, cloneAttachFn]} transclude function available to directives.\n * @param {number} maxPriority only apply directives lower then given priority (Only effects the\n *                 root element(s), not their children)\n * @returns {function(scope[, cloneAttachFn])} a link function which is used to bind template\n * (a DOM element/tree) to a scope. Where:\n *\n *  * `scope` - A {@link ng.$rootScope.Scope Scope} to bind to.\n *  * `cloneAttachFn` - If `cloneAttachFn` is provided, then the link function will clone the\n *               `template` and call the `cloneAttachFn` function allowing the caller to attach the\n *               cloned elements to the DOM document at the appropriate place. The `cloneAttachFn` is\n *               called as: <br> `cloneAttachFn(clonedElement, scope)` where:\n *\n *      * `clonedElement` - is a clone of the original `element` passed into the compiler.\n *      * `scope` - is the current scope with which the linking function is working with.\n *\n * Calling the linking function returns the element of the template. It is either the original element\n * passed in, or the clone of the element if the `cloneAttachFn` is provided.\n *\n * After linking the view is not updated until after a call to $digest which typically is done by\n * Angular automatically.\n *\n * If you need access to the bound view, there are two ways to do it:\n *\n * - If you are not asking the linking function to clone the template, create the DOM element(s)\n *   before you send them to the compiler and keep this reference around.\n *   <pre>\n *     var element = $compile('<p>{{total}}</p>')(scope);\n *   </pre>\n *\n * - if on the other hand, you need the element to be cloned, the view reference from the original\n *   example would not point to the clone, but rather to the original template that was cloned. In\n *   this case, you can access the clone via the cloneAttachFn:\n *   <pre>\n *     var templateHTML = angular.element('<p>{{total}}</p>'),\n *         scope = ....;\n *\n *     var clonedElement = $compile(templateHTML)(scope, function(clonedElement, scope) {\n *       //attach the clone to DOM document at the right place\n *     });\n *\n *     //now we have reference to the cloned DOM via `clone`\n *   </pre>\n *\n *\n * For information on how the compiler works, see the\n * {@link guide/compiler Angular HTML Compiler} section of the Developer Guide.\n */\n\nvar $compileMinErr = minErr('$compile');\n\n/**\n * @ngdoc service\n * @name ng.$compileProvider\n * @function\n *\n * @description\n */\n$CompileProvider.$inject = ['$provide'];\nfunction $CompileProvider($provide) {\n  var hasDirectives = {},\n      Suffix = 'Directive',\n      COMMENT_DIRECTIVE_REGEXP = /^\\s*directive\\:\\s*([\\d\\w\\-_]+)\\s+(.*)$/,\n      CLASS_DIRECTIVE_REGEXP = /(([\\d\\w\\-_]+)(?:\\:([^;]+))?;?)/,\n      aHrefSanitizationWhitelist = /^\\s*(https?|ftp|mailto|file):/,\n      imgSrcSanitizationWhitelist = /^\\s*(https?|ftp|file):|data:image\\//;\n\n  // Ref: http://developers.whatwg.org/webappapis.html#event-handler-idl-attributes\n  // The assumption is that future DOM event attribute names will begin with\n  // 'on' and be composed of only English letters.\n  var EVENT_HANDLER_ATTR_REGEXP = /^(on[a-z]*|formaction)$/;\n\n  /**\n   * @ngdoc function\n   * @name ng.$compileProvider#directive\n   * @methodOf ng.$compileProvider\n   * @function\n   *\n   * @description\n   * Register a new directive with the compiler.\n   *\n   * @param {string} name Name of the directive in camel-case. (ie <code>ngBind</code> which will match as\n   *                <code>ng-bind</code>).\n   * @param {function|Array} directiveFactory An injectable directive factory function. See {@link guide/directive} for more\n   *                info.\n   * @returns {ng.$compileProvider} Self for chaining.\n   */\n   this.directive = function registerDirective(name, directiveFactory) {\n    if (isString(name)) {\n      assertArg(directiveFactory, 'directiveFactory');\n      if (!hasDirectives.hasOwnProperty(name)) {\n        hasDirectives[name] = [];\n        $provide.factory(name + Suffix, ['$injector', '$exceptionHandler',\n          function($injector, $exceptionHandler) {\n            var directives = [];\n            forEach(hasDirectives[name], function(directiveFactory) {\n              try {\n                var directive = $injector.invoke(directiveFactory);\n                if (isFunction(directive)) {\n                  directive = { compile: valueFn(directive) };\n                } else if (!directive.compile && directive.link) {\n                  directive.compile = valueFn(directive.link);\n                }\n                directive.priority = directive.priority || 0;\n                directive.name = directive.name || name;\n                directive.require = directive.require || (directive.controller && directive.name);\n                directive.restrict = directive.restrict || 'A';\n                directives.push(directive);\n              } catch (e) {\n                $exceptionHandler(e);\n              }\n            });\n            return directives;\n          }]);\n      }\n      hasDirectives[name].push(directiveFactory);\n    } else {\n      forEach(name, reverseParams(registerDirective));\n    }\n    return this;\n  };\n\n\n  /**\n   * @ngdoc function\n   * @name ng.$compileProvider#aHrefSanitizationWhitelist\n   * @methodOf ng.$compileProvider\n   * @function\n   *\n   * @description\n   * Retrieves or overrides the default regular expression that is used for whitelisting of safe\n   * urls during a[href] sanitization.\n   *\n   * The sanitization is a security measure aimed at prevent XSS attacks via html links.\n   *\n   * Any url about to be assigned to a[href] via data-binding is first normalized and turned into\n   * an absolute url. Afterwards, the url is matched against the `aHrefSanitizationWhitelist`\n   * regular expression. If a match is found, the original url is written into the dom. Otherwise,\n   * the absolute url is prefixed with `'unsafe:'` string and only then is it written into the DOM.\n   *\n   * @param {RegExp=} regexp New regexp to whitelist urls with.\n   * @returns {RegExp|ng.$compileProvider} Current RegExp if called without value or self for\n   *    chaining otherwise.\n   */\n  this.aHrefSanitizationWhitelist = function(regexp) {\n    if (isDefined(regexp)) {\n      aHrefSanitizationWhitelist = regexp;\n      return this;\n    }\n    return aHrefSanitizationWhitelist;\n  };\n\n\n  /**\n   * @ngdoc function\n   * @name ng.$compileProvider#imgSrcSanitizationWhitelist\n   * @methodOf ng.$compileProvider\n   * @function\n   *\n   * @description\n   * Retrieves or overrides the default regular expression that is used for whitelisting of safe\n   * urls during img[src] sanitization.\n   *\n   * The sanitization is a security measure aimed at prevent XSS attacks via html links.\n   *\n   * Any url about to be assigned to img[src] via data-binding is first normalized and turned into an\n   * absolute url. Afterwards, the url is matched against the `imgSrcSanitizationWhitelist` regular\n   * expression. If a match is found, the original url is written into the dom. Otherwise, the\n   * absolute url is prefixed with `'unsafe:'` string and only then is it written into the DOM.\n   *\n   * @param {RegExp=} regexp New regexp to whitelist urls with.\n   * @returns {RegExp|ng.$compileProvider} Current RegExp if called without value or self for\n   *    chaining otherwise.\n   */\n  this.imgSrcSanitizationWhitelist = function(regexp) {\n    if (isDefined(regexp)) {\n      imgSrcSanitizationWhitelist = regexp;\n      return this;\n    }\n    return imgSrcSanitizationWhitelist;\n  };\n\n\n  this.$get = [\n            '$injector', '$interpolate', '$exceptionHandler', '$http', '$templateCache', '$parse',\n            '$controller', '$rootScope', '$document', '$sce', '$$urlUtils', '$animate',\n    function($injector,   $interpolate,   $exceptionHandler,   $http,   $templateCache,   $parse,\n             $controller,   $rootScope,   $document,   $sce,   $$urlUtils, $animate) {\n\n    var Attributes = function(element, attr) {\n      this.$$element = element;\n      this.$attr = attr || {};\n    };\n\n    Attributes.prototype = {\n      $normalize: directiveNormalize,\n\n\n      /**\n       * @ngdoc function\n       * @name ng.$compile.directive.Attributes#$addClass\n       * @methodOf ng.$compile.directive.Attributes\n       * @function\n       *\n       * @description\n       * Adds the CSS class value specified by the classVal parameter to the element. If animations\n       * are enabled then an animation will be triggered for the class addition.\n       *\n       * @param {string} classVal The className value that will be added to the element\n       */\n      $addClass : function(classVal) {\n        if(classVal && classVal.length > 0) {\n          $animate.addClass(this.$$element, classVal);\n        }\n      },\n\n      /**\n       * @ngdoc function\n       * @name ng.$compile.directive.Attributes#$removeClass\n       * @methodOf ng.$compile.directive.Attributes\n       * @function\n       *\n       * @description\n       * Removes the CSS class value specified by the classVal parameter from the element. If animations\n       * are enabled then an animation will be triggered for the class removal.\n       *\n       * @param {string} classVal The className value that will be removed from the element\n       */\n      $removeClass : function(classVal) {\n        if(classVal && classVal.length > 0) {\n          $animate.removeClass(this.$$element, classVal);\n        }\n      },\n\n      /**\n       * Set a normalized attribute on the element in a way such that all directives\n       * can share the attribute. This function properly handles boolean attributes.\n       * @param {string} key Normalized key. (ie ngAttribute)\n       * @param {string|boolean} value The value to set. If `null` attribute will be deleted.\n       * @param {boolean=} writeAttr If false, does not write the value to DOM element attribute.\n       *     Defaults to true.\n       * @param {string=} attrName Optional none normalized name. Defaults to key.\n       */\n      $set: function(key, value, writeAttr, attrName) {\n        //special case for class attribute addition + removal\n        //so that class changes can tap into the animation\n        //hooks provided by the $animate service\n        if(key == 'class') {\n          value = value || '';\n          var current = this.$$element.attr('class') || '';\n          this.$removeClass(tokenDifference(current, value).join(' '));\n          this.$addClass(tokenDifference(value, current).join(' '));\n        } else {\n          var booleanKey = getBooleanAttrName(this.$$element[0], key),\n              normalizedVal,\n              nodeName;\n\n          if (booleanKey) {\n            this.$$element.prop(key, value);\n            attrName = booleanKey;\n          }\n\n          this[key] = value;\n\n          // translate normalized key to actual key\n          if (attrName) {\n            this.$attr[key] = attrName;\n          } else {\n            attrName = this.$attr[key];\n            if (!attrName) {\n              this.$attr[key] = attrName = snake_case(key, '-');\n            }\n          }\n\n          nodeName = nodeName_(this.$$element);\n\n          // sanitize a[href] and img[src] values\n          if ((nodeName === 'A' && key === 'href') ||\n              (nodeName === 'IMG' && key === 'src')) {\n            // NOTE: $$urlUtils.resolve() doesn't support IE < 8 so we don't sanitize for that case.\n            if (!msie || msie >= 8 ) {\n              normalizedVal = $$urlUtils.resolve(value);\n              if (normalizedVal !== '') {\n                if ((key === 'href' && !normalizedVal.match(aHrefSanitizationWhitelist)) ||\n                    (key === 'src' && !normalizedVal.match(imgSrcSanitizationWhitelist))) {\n                  this[key] = value = 'unsafe:' + normalizedVal;\n                }\n              }\n            }\n          }\n\n          if (writeAttr !== false) {\n            if (value === null || value === undefined) {\n              this.$$element.removeAttr(attrName);\n            } else {\n              this.$$element.attr(attrName, value);\n            }\n          }\n        }\n\n        // fire observers\n        var $$observers = this.$$observers;\n        $$observers && forEach($$observers[key], function(fn) {\n          try {\n            fn(value);\n          } catch (e) {\n            $exceptionHandler(e);\n          }\n        });\n\n        function tokenDifference(str1, str2) {\n          var values = [],\n              tokens1 = str1.split(/\\s+/),\n              tokens2 = str2.split(/\\s+/);\n\n          outer:\n          for(var i=0;i<tokens1.length;i++) {\n            var token = tokens1[i];\n            for(var j=0;j<tokens2.length;j++) {\n              if(token == tokens2[j]) continue outer;\n            }\n            values.push(token);\n          }\n          return values;\n        };\n      },\n\n\n      /**\n       * Observe an interpolated attribute.\n       * The observer will never be called, if given attribute is not interpolated.\n       *\n       * @param {string} key Normalized key. (ie ngAttribute) .\n       * @param {function(*)} fn Function that will be called whenever the attribute value changes.\n       * @returns {function(*)} the `fn` Function passed in.\n       */\n      $observe: function(key, fn) {\n        var attrs = this,\n            $$observers = (attrs.$$observers || (attrs.$$observers = {})),\n            listeners = ($$observers[key] || ($$observers[key] = []));\n\n        listeners.push(fn);\n        $rootScope.$evalAsync(function() {\n          if (!listeners.$$inter) {\n            // no one registered attribute interpolation function, so lets call it manually\n            fn(attrs[key]);\n          }\n        });\n        return fn;\n      }\n    };\n\n    var urlSanitizationNode = $document[0].createElement('a'),\n        startSymbol = $interpolate.startSymbol(),\n        endSymbol = $interpolate.endSymbol(),\n        denormalizeTemplate = (startSymbol == '{{' || endSymbol  == '}}')\n            ? identity\n            : function denormalizeTemplate(template) {\n              return template.replace(/\\{\\{/g, startSymbol).replace(/}}/g, endSymbol);\n        },\n        NG_ATTR_BINDING = /^ngAttr[A-Z]/;\n\n\n    return compile;\n\n    //================================\n\n    function compile($compileNodes, transcludeFn, maxPriority, ignoreDirective) {\n      if (!($compileNodes instanceof jqLite)) {\n        // jquery always rewraps, whereas we need to preserve the original selector so that we can modify it.\n        $compileNodes = jqLite($compileNodes);\n      }\n      // We can not compile top level text elements since text nodes can be merged and we will\n      // not be able to attach scope data to them, so we will wrap them in <span>\n      forEach($compileNodes, function(node, index){\n        if (node.nodeType == 3 /* text node */ && node.nodeValue.match(/\\S+/) /* non-empty */ ) {\n          $compileNodes[index] = node = jqLite(node).wrap('<span></span>').parent()[0];\n        }\n      });\n      var compositeLinkFn = compileNodes($compileNodes, transcludeFn, $compileNodes, maxPriority, ignoreDirective);\n      return function publicLinkFn(scope, cloneConnectFn){\n        assertArg(scope, 'scope');\n        // important!!: we must call our jqLite.clone() since the jQuery one is trying to be smart\n        // and sometimes changes the structure of the DOM.\n        var $linkNode = cloneConnectFn\n          ? JQLitePrototype.clone.call($compileNodes) // IMPORTANT!!!\n          : $compileNodes;\n\n        // Attach scope only to non-text nodes.\n        for(var i = 0, ii = $linkNode.length; i<ii; i++) {\n          var node = $linkNode[i];\n          if (node.nodeType == 1 /* element */ || node.nodeType == 9 /* document */) {\n            $linkNode.eq(i).data('$scope', scope);\n          }\n        }\n        safeAddClass($linkNode, 'ng-scope');\n        if (cloneConnectFn) cloneConnectFn($linkNode, scope);\n        if (compositeLinkFn) compositeLinkFn(scope, $linkNode, $linkNode);\n        return $linkNode;\n      };\n    }\n\n    function safeAddClass($element, className) {\n      try {\n        $element.addClass(className);\n      } catch(e) {\n        // ignore, since it means that we are trying to set class on\n        // SVG element, where class name is read-only.\n      }\n    }\n\n    /**\n     * Compile function matches each node in nodeList against the directives. Once all directives\n     * for a particular node are collected their compile functions are executed. The compile\n     * functions return values - the linking functions - are combined into a composite linking\n     * function, which is the a linking function for the node.\n     *\n     * @param {NodeList} nodeList an array of nodes or NodeList to compile\n     * @param {function(angular.Scope[, cloneAttachFn]} transcludeFn A linking function, where the\n     *        scope argument is auto-generated to the new child of the transcluded parent scope.\n     * @param {DOMElement=} $rootElement If the nodeList is the root of the compilation tree then the\n     *        rootElement must be set the jqLite collection of the compile root. This is\n     *        needed so that the jqLite collection items can be replaced with widgets.\n     * @param {number=} max directive priority\n     * @returns {?function} A composite linking function of all of the matched directives or null.\n     */\n    function compileNodes(nodeList, transcludeFn, $rootElement, maxPriority, ignoreDirective) {\n      var linkFns = [],\n          nodeLinkFn, childLinkFn, directives, attrs, linkFnFound;\n\n      for(var i = 0; i < nodeList.length; i++) {\n        attrs = new Attributes();\n\n        // we must always refer to nodeList[i] since the nodes can be replaced underneath us.\n        directives = collectDirectives(nodeList[i], [], attrs, i == 0 ? maxPriority : undefined, ignoreDirective);\n\n        nodeLinkFn = (directives.length)\n            ? applyDirectivesToNode(directives, nodeList[i], attrs, transcludeFn, $rootElement)\n            : null;\n\n        childLinkFn = (nodeLinkFn && nodeLinkFn.terminal || !nodeList[i].childNodes || !nodeList[i].childNodes.length)\n            ? null\n            : compileNodes(nodeList[i].childNodes,\n                 nodeLinkFn ? nodeLinkFn.transclude : transcludeFn);\n\n        linkFns.push(nodeLinkFn);\n        linkFns.push(childLinkFn);\n        linkFnFound = (linkFnFound || nodeLinkFn || childLinkFn);\n      }\n\n      // return a linking function if we have found anything, null otherwise\n      return linkFnFound ? compositeLinkFn : null;\n\n      function compositeLinkFn(scope, nodeList, $rootElement, boundTranscludeFn) {\n        var nodeLinkFn, childLinkFn, node, childScope, childTranscludeFn, i, ii, n;\n\n        // copy nodeList so that linking doesn't break due to live list updates.\n        var stableNodeList = [];\n        for (i = 0, ii = nodeList.length; i < ii; i++) {\n          stableNodeList.push(nodeList[i]);\n        }\n\n        for(i = 0, n = 0, ii = linkFns.length; i < ii; n++) {\n          node = stableNodeList[n];\n          nodeLinkFn = linkFns[i++];\n          childLinkFn = linkFns[i++];\n\n          if (nodeLinkFn) {\n            if (nodeLinkFn.scope) {\n              childScope = scope.$new(isObject(nodeLinkFn.scope));\n              jqLite(node).data('$scope', childScope);\n            } else {\n              childScope = scope;\n            }\n            childTranscludeFn = nodeLinkFn.transclude;\n            if (childTranscludeFn || (!boundTranscludeFn && transcludeFn)) {\n              nodeLinkFn(childLinkFn, childScope, node, $rootElement,\n                  (function(transcludeFn) {\n                    return function(cloneFn) {\n                      var transcludeScope = scope.$new();\n                      transcludeScope.$$transcluded = true;\n\n                      return transcludeFn(transcludeScope, cloneFn).\n                          on('$destroy', bind(transcludeScope, transcludeScope.$destroy));\n                    };\n                  })(childTranscludeFn || transcludeFn)\n              );\n            } else {\n              nodeLinkFn(childLinkFn, childScope, node, undefined, boundTranscludeFn);\n            }\n          } else if (childLinkFn) {\n            childLinkFn(scope, node.childNodes, undefined, boundTranscludeFn);\n          }\n        }\n      }\n    }\n\n\n    /**\n     * Looks for directives on the given node and adds them to the directive collection which is\n     * sorted.\n     *\n     * @param node Node to search.\n     * @param directives An array to which the directives are added to. This array is sorted before\n     *        the function returns.\n     * @param attrs The shared attrs object which is used to populate the normalized attributes.\n     * @param {number=} maxPriority Max directive priority.\n     */\n    function collectDirectives(node, directives, attrs, maxPriority, ignoreDirective) {\n      var nodeType = node.nodeType,\n          attrsMap = attrs.$attr,\n          match,\n          className;\n\n      switch(nodeType) {\n        case 1: /* Element */\n          // use the node name: <directive>\n          addDirective(directives,\n              directiveNormalize(nodeName_(node).toLowerCase()), 'E', maxPriority, ignoreDirective);\n\n          // iterate over the attributes\n          for (var attr, name, nName, ngAttrName, value, nAttrs = node.attributes,\n                   j = 0, jj = nAttrs && nAttrs.length; j < jj; j++) {\n            var attrStartName;\n            var attrEndName;\n            var index;\n\n            attr = nAttrs[j];\n            if (!msie || msie >= 8 || attr.specified) {\n              name = attr.name;\n              // support ngAttr attribute binding\n              ngAttrName = directiveNormalize(name);\n              if (NG_ATTR_BINDING.test(ngAttrName)) {\n                name = ngAttrName.substr(6).toLowerCase();\n              }\n              if ((index = ngAttrName.lastIndexOf('Start')) != -1 && index == ngAttrName.length - 5) {\n                attrStartName = name;\n                attrEndName = name.substr(0, name.length - 5) + 'end';\n                name = name.substr(0, name.length - 6);\n              }\n              nName = directiveNormalize(name.toLowerCase());\n              attrsMap[nName] = name;\n              attrs[nName] = value = trim((msie && name == 'href')\n                ? decodeURIComponent(node.getAttribute(name, 2))\n                : attr.value);\n              if (getBooleanAttrName(node, nName)) {\n                attrs[nName] = true; // presence means true\n              }\n              addAttrInterpolateDirective(node, directives, value, nName);\n              addDirective(directives, nName, 'A', maxPriority, ignoreDirective, attrStartName, attrEndName);\n            }\n          }\n\n          // use class as directive\n          className = node.className;\n          if (isString(className) && className !== '') {\n            while (match = CLASS_DIRECTIVE_REGEXP.exec(className)) {\n              nName = directiveNormalize(match[2]);\n              if (addDirective(directives, nName, 'C', maxPriority, ignoreDirective)) {\n                attrs[nName] = trim(match[3]);\n              }\n              className = className.substr(match.index + match[0].length);\n            }\n          }\n          break;\n        case 3: /* Text Node */\n          addTextInterpolateDirective(directives, node.nodeValue);\n          break;\n        case 8: /* Comment */\n          try {\n            match = COMMENT_DIRECTIVE_REGEXP.exec(node.nodeValue);\n            if (match) {\n              nName = directiveNormalize(match[1]);\n              if (addDirective(directives, nName, 'M', maxPriority, ignoreDirective)) {\n                attrs[nName] = trim(match[2]);\n              }\n            }\n          } catch (e) {\n            // turns out that under some circumstances IE9 throws errors when one attempts to read comment's node value.\n            // Just ignore it and continue. (Can't seem to reproduce in test case.)\n          }\n          break;\n      }\n\n      directives.sort(byPriority);\n      return directives;\n    }\n\n    /**\n     * Given a node with an directive-start it collects all of the siblings until it find directive-end.\n     * @param node\n     * @param attrStart\n     * @param attrEnd\n     * @returns {*}\n     */\n    function groupScan(node, attrStart, attrEnd) {\n      var nodes = [];\n      var depth = 0;\n      if (attrStart && node.hasAttribute && node.hasAttribute(attrStart)) {\n        var startNode = node;\n        do {\n          if (!node) {\n            throw $compileMinErr('uterdir', \"Unterminated attribute, found '{0}' but no matching '{1}' found.\", attrStart, attrEnd);\n          }\n          if (node.nodeType == 1 /** Element **/) {\n            if (node.hasAttribute(attrStart)) depth++;\n            if (node.hasAttribute(attrEnd)) depth--;\n          }\n          nodes.push(node);\n          node = node.nextSibling;\n        } while (depth > 0);\n      } else {\n        nodes.push(node);\n      }\n      return jqLite(nodes);\n    }\n\n    /**\n     * Wrapper for linking function which converts normal linking function into a grouped\n     * linking function.\n     * @param linkFn\n     * @param attrStart\n     * @param attrEnd\n     * @returns {Function}\n     */\n    function groupElementsLinkFnWrapper(linkFn, attrStart, attrEnd) {\n      return function(scope, element, attrs, controllers) {\n        element = groupScan(element[0], attrStart, attrEnd);\n        return linkFn(scope, element, attrs, controllers);\n      }\n    }\n\n    /**\n     * Once the directives have been collected, their compile functions are executed. This method\n     * is responsible for inlining directive templates as well as terminating the application\n     * of the directives if the terminal directive has been reached.\n     *\n     * @param {Array} directives Array of collected directives to execute their compile function.\n     *        this needs to be pre-sorted by priority order.\n     * @param {Node} compileNode The raw DOM node to apply the compile functions to\n     * @param {Object} templateAttrs The shared attribute function\n     * @param {function(angular.Scope[, cloneAttachFn]} transcludeFn A linking function, where the\n     *        scope argument is auto-generated to the new child of the transcluded parent scope.\n     * @param {JQLite} jqCollection If we are working on the root of the compile tree then this\n     *        argument has the root jqLite array so that we can replace nodes on it.\n     * @returns linkFn\n     */\n    function applyDirectivesToNode(directives, compileNode, templateAttrs, transcludeFn, jqCollection, originalReplaceDirective) {\n      var terminalPriority = -Number.MAX_VALUE,\n          preLinkFns = [],\n          postLinkFns = [],\n          newScopeDirective = null,\n          newIsolateScopeDirective = null,\n          templateDirective = null,\n          $compileNode = templateAttrs.$$element = jqLite(compileNode),\n          directive,\n          directiveName,\n          $template,\n          transcludeDirective,\n          replaceDirective = originalReplaceDirective,\n          childTranscludeFn = transcludeFn,\n          controllerDirectives,\n          linkFn,\n          directiveValue;\n\n      // executes all directives on the current element\n      for(var i = 0, ii = directives.length; i < ii; i++) {\n        directive = directives[i];\n        var attrStart = directive.$$start;\n        var attrEnd = directive.$$end;\n\n        // collect multiblock sections\n        if (attrStart) {\n          $compileNode = groupScan(compileNode, attrStart, attrEnd)\n        }\n        $template = undefined;\n\n        if (terminalPriority > directive.priority) {\n          break; // prevent further processing of directives\n        }\n\n        if (directiveValue = directive.scope) {\n          assertNoDuplicate('isolated scope', newIsolateScopeDirective, directive, $compileNode);\n          if (isObject(directiveValue)) {\n            safeAddClass($compileNode, 'ng-isolate-scope');\n            newIsolateScopeDirective = directive;\n          }\n          safeAddClass($compileNode, 'ng-scope');\n          newScopeDirective = newScopeDirective || directive;\n        }\n\n        directiveName = directive.name;\n\n        if (directiveValue = directive.controller) {\n          controllerDirectives = controllerDirectives || {};\n          assertNoDuplicate(\"'\" + directiveName + \"' controller\",\n              controllerDirectives[directiveName], directive, $compileNode);\n          controllerDirectives[directiveName] = directive;\n        }\n\n        if (directiveValue = directive.transclude) {\n          assertNoDuplicate('transclusion', transcludeDirective, directive, $compileNode);\n          transcludeDirective = directive;\n          terminalPriority = directive.priority;\n          if (directiveValue == 'element') {\n            $template = groupScan(compileNode, attrStart, attrEnd)\n            $compileNode = templateAttrs.$$element =\n                jqLite(document.createComment(' ' + directiveName + ': ' + templateAttrs[directiveName] + ' '));\n            compileNode = $compileNode[0];\n            replaceWith(jqCollection, jqLite(sliceArgs($template)), compileNode);\n\n            childTranscludeFn = compile($template, transcludeFn, terminalPriority,\n                                        replaceDirective && replaceDirective.name);\n          } else {\n            $template = jqLite(JQLiteClone(compileNode)).contents();\n            $compileNode.html(''); // clear contents\n            childTranscludeFn = compile($template, transcludeFn);\n          }\n        }\n\n        if (directive.template) {\n          assertNoDuplicate('template', templateDirective, directive, $compileNode);\n          templateDirective = directive;\n\n          directiveValue = (isFunction(directive.template))\n              ? directive.template($compileNode, templateAttrs)\n              : directive.template;\n\n          directiveValue = denormalizeTemplate(directiveValue);\n\n          if (directive.replace) {\n            replaceDirective = directive;\n            $template = jqLite('<div>' +\n                                 trim(directiveValue) +\n                               '</div>').contents();\n            compileNode = $template[0];\n\n            if ($template.length != 1 || compileNode.nodeType !== 1) {\n              throw $compileMinErr('tplrt', \"Template for directive '{0}' must have exactly one root element. {1}\", directiveName, '');\n            }\n\n            replaceWith(jqCollection, $compileNode, compileNode);\n\n            var newTemplateAttrs = {$attr: {}};\n\n            // combine directives from the original node and from the template:\n            // - take the array of directives for this element\n            // - split it into two parts, those that were already applied and those that weren't\n            // - collect directives from the template, add them to the second group and sort them\n            // - append the second group with new directives to the first group\n            directives = directives.concat(\n                collectDirectives(\n                    compileNode,\n                    directives.splice(i + 1, directives.length - (i + 1)),\n                    newTemplateAttrs\n                )\n            );\n            mergeTemplateAttributes(templateAttrs, newTemplateAttrs);\n\n            ii = directives.length;\n          } else {\n            $compileNode.html(directiveValue);\n          }\n        }\n\n        if (directive.templateUrl) {\n          assertNoDuplicate('template', templateDirective, directive, $compileNode);\n          templateDirective = directive;\n\n          if (directive.replace) {\n            replaceDirective = directive;\n          }\n          nodeLinkFn = compileTemplateUrl(directives.splice(i, directives.length - i),\n              nodeLinkFn, $compileNode, templateAttrs, jqCollection, childTranscludeFn);\n          ii = directives.length;\n        } else if (directive.compile) {\n          try {\n            linkFn = directive.compile($compileNode, templateAttrs, childTranscludeFn);\n            if (isFunction(linkFn)) {\n              addLinkFns(null, linkFn, attrStart, attrEnd);\n            } else if (linkFn) {\n              addLinkFns(linkFn.pre, linkFn.post, attrStart, attrEnd);\n            }\n          } catch (e) {\n            $exceptionHandler(e, startingTag($compileNode));\n          }\n        }\n\n        if (directive.terminal) {\n          nodeLinkFn.terminal = true;\n          terminalPriority = Math.max(terminalPriority, directive.priority);\n        }\n\n      }\n\n      nodeLinkFn.scope = newScopeDirective && newScopeDirective.scope;\n      nodeLinkFn.transclude = transcludeDirective && childTranscludeFn;\n\n      // might be normal or delayed nodeLinkFn depending on if templateUrl is present\n      return nodeLinkFn;\n\n      ////////////////////\n\n      function addLinkFns(pre, post, attrStart, attrEnd) {\n        if (pre) {\n          if (attrStart) pre = groupElementsLinkFnWrapper(pre, attrStart, attrEnd);\n          pre.require = directive.require;\n          preLinkFns.push(pre);\n        }\n        if (post) {\n          if (attrStart) post = groupElementsLinkFnWrapper(post, attrStart, attrEnd);\n          post.require = directive.require;\n          postLinkFns.push(post);\n        }\n      }\n\n\n      function getControllers(require, $element) {\n        var value, retrievalMethod = 'data', optional = false;\n        if (isString(require)) {\n          while((value = require.charAt(0)) == '^' || value == '?') {\n            require = require.substr(1);\n            if (value == '^') {\n              retrievalMethod = 'inheritedData';\n            }\n            optional = optional || value == '?';\n          }\n          value = $element[retrievalMethod]('$' + require + 'Controller');\n          if (!value && !optional) {\n            throw $compileMinErr('ctreq', \"Controller '{0}', required by directive '{1}', can't be found!\", require, directiveName);\n          }\n          return value;\n        } else if (isArray(require)) {\n          value = [];\n          forEach(require, function(require) {\n            value.push(getControllers(require, $element));\n          });\n        }\n        return value;\n      }\n\n\n      function nodeLinkFn(childLinkFn, scope, linkNode, $rootElement, boundTranscludeFn) {\n        var attrs, $element, i, ii, linkFn, controller;\n\n        if (compileNode === linkNode) {\n          attrs = templateAttrs;\n        } else {\n          attrs = shallowCopy(templateAttrs, new Attributes(jqLite(linkNode), templateAttrs.$attr));\n        }\n        $element = attrs.$$element;\n\n        if (newIsolateScopeDirective) {\n          var LOCAL_REGEXP = /^\\s*([@=&])(\\??)\\s*(\\w*)\\s*$/;\n\n          var parentScope = scope.$parent || scope;\n\n          forEach(newIsolateScopeDirective.scope, function(definition, scopeName) {\n            var match = definition.match(LOCAL_REGEXP) || [],\n                attrName = match[3] || scopeName,\n                optional = (match[2] == '?'),\n                mode = match[1], // @, =, or &\n                lastValue,\n                parentGet, parentSet;\n\n            scope.$$isolateBindings[scopeName] = mode + attrName;\n\n            switch (mode) {\n\n              case '@': {\n                attrs.$observe(attrName, function(value) {\n                  scope[scopeName] = value;\n                });\n                attrs.$$observers[attrName].$$scope = parentScope;\n                if( attrs[attrName] ) {\n                  // If the attribute has been provided then we trigger an interpolation to ensure the value is there for use in the link fn\n                  scope[scopeName] = $interpolate(attrs[attrName])(parentScope);\n                }\n                break;\n              }\n\n              case '=': {\n                if (optional && !attrs[attrName]) {\n                  return;\n                }\n                parentGet = $parse(attrs[attrName]);\n                parentSet = parentGet.assign || function() {\n                  // reset the change, or we will throw this exception on every $digest\n                  lastValue = scope[scopeName] = parentGet(parentScope);\n                  throw $compileMinErr('nonassign', \"Expression '{0}' used with directive '{1}' is non-assignable!\",\n                      attrs[attrName], newIsolateScopeDirective.name);\n                };\n                lastValue = scope[scopeName] = parentGet(parentScope);\n                scope.$watch(function parentValueWatch() {\n                  var parentValue = parentGet(parentScope);\n\n                  if (parentValue !== scope[scopeName]) {\n                    // we are out of sync and need to copy\n                    if (parentValue !== lastValue) {\n                      // parent changed and it has precedence\n                      lastValue = scope[scopeName] = parentValue;\n                    } else {\n                      // if the parent can be assigned then do so\n                      parentSet(parentScope, parentValue = lastValue = scope[scopeName]);\n                    }\n                  }\n                  return parentValue;\n                });\n                break;\n              }\n\n              case '&': {\n                parentGet = $parse(attrs[attrName]);\n                scope[scopeName] = function(locals) {\n                  return parentGet(parentScope, locals);\n                };\n                break;\n              }\n\n              default: {\n                throw $compileMinErr('iscp', \"Invalid isolate scope definition for directive '{0}'. Definition: {... {1}: '{2}' ...}\",\n                    newIsolateScopeDirective.name, scopeName, definition);\n              }\n            }\n          });\n        }\n\n        if (controllerDirectives) {\n          forEach(controllerDirectives, function(directive) {\n            var locals = {\n              $scope: scope,\n              $element: $element,\n              $attrs: attrs,\n              $transclude: boundTranscludeFn\n            }, controllerInstance;\n\n            controller = directive.controller;\n            if (controller == '@') {\n              controller = attrs[directive.name];\n            }\n\n            controllerInstance = $controller(controller, locals);\n            $element.data(\n                '$' + directive.name + 'Controller',\n                controllerInstance);\n            if (directive.controllerAs) {\n              locals.$scope[directive.controllerAs] = controllerInstance;\n            }\n          });\n        }\n\n        // PRELINKING\n        for(i = 0, ii = preLinkFns.length; i < ii; i++) {\n          try {\n            linkFn = preLinkFns[i];\n            linkFn(scope, $element, attrs,\n                linkFn.require && getControllers(linkFn.require, $element));\n          } catch (e) {\n            $exceptionHandler(e, startingTag($element));\n          }\n        }\n\n        // RECURSION\n        childLinkFn && childLinkFn(scope, linkNode.childNodes, undefined, boundTranscludeFn);\n\n        // POSTLINKING\n        for(i = 0, ii = postLinkFns.length; i < ii; i++) {\n          try {\n            linkFn = postLinkFns[i];\n            linkFn(scope, $element, attrs,\n                linkFn.require && getControllers(linkFn.require, $element));\n          } catch (e) {\n            $exceptionHandler(e, startingTag($element));\n          }\n        }\n      }\n    }\n\n\n    /**\n     * looks up the directive and decorates it with exception handling and proper parameters. We\n     * call this the boundDirective.\n     *\n     * @param {string} name name of the directive to look up.\n     * @param {string} location The directive must be found in specific format.\n     *   String containing any of theses characters:\n     *\n     *   * `E`: element name\n     *   * `A': attribute\n     *   * `C`: class\n     *   * `M`: comment\n     * @returns true if directive was added.\n     */\n    function addDirective(tDirectives, name, location, maxPriority, ignoreDirective, startAttrName, endAttrName) {\n      if (name === ignoreDirective) return null;\n      var match = null;\n      if (hasDirectives.hasOwnProperty(name)) {\n        for(var directive, directives = $injector.get(name + Suffix),\n            i = 0, ii = directives.length; i<ii; i++) {\n          try {\n            directive = directives[i];\n            if ( (maxPriority === undefined || maxPriority > directive.priority) &&\n                 directive.restrict.indexOf(location) != -1) {\n              if (startAttrName) {\n                directive = inherit(directive, {$$start: startAttrName, $$end: endAttrName});\n              }\n              tDirectives.push(directive);\n              match = directive;\n            }\n          } catch(e) { $exceptionHandler(e); }\n        }\n      }\n      return match;\n    }\n\n\n    /**\n     * When the element is replaced with HTML template then the new attributes\n     * on the template need to be merged with the existing attributes in the DOM.\n     * The desired effect is to have both of the attributes present.\n     *\n     * @param {object} dst destination attributes (original DOM)\n     * @param {object} src source attributes (from the directive template)\n     */\n    function mergeTemplateAttributes(dst, src) {\n      var srcAttr = src.$attr,\n          dstAttr = dst.$attr,\n          $element = dst.$$element;\n\n      // reapply the old attributes to the new element\n      forEach(dst, function(value, key) {\n        if (key.charAt(0) != '$') {\n          if (src[key]) {\n            value += (key === 'style' ? ';' : ' ') + src[key];\n          }\n          dst.$set(key, value, true, srcAttr[key]);\n        }\n      });\n\n      // copy the new attributes on the old attrs object\n      forEach(src, function(value, key) {\n        if (key == 'class') {\n          safeAddClass($element, value);\n          dst['class'] = (dst['class'] ? dst['class'] + ' ' : '') + value;\n        } else if (key == 'style') {\n          $element.attr('style', $element.attr('style') + ';' + value);\n        } else if (key.charAt(0) != '$' && !dst.hasOwnProperty(key)) {\n          dst[key] = value;\n          dstAttr[key] = srcAttr[key];\n        }\n      });\n    }\n\n\n    function compileTemplateUrl(directives, beforeTemplateNodeLinkFn, $compileNode, tAttrs,\n        $rootElement, childTranscludeFn) {\n      var linkQueue = [],\n          afterTemplateNodeLinkFn,\n          afterTemplateChildLinkFn,\n          beforeTemplateCompileNode = $compileNode[0],\n          origAsyncDirective = directives.shift(),\n          // The fact that we have to copy and patch the directive seems wrong!\n          derivedSyncDirective = extend({}, origAsyncDirective, {\n            controller: null, templateUrl: null, transclude: null, scope: null, replace: null\n          }),\n          templateUrl = (isFunction(origAsyncDirective.templateUrl))\n              ? origAsyncDirective.templateUrl($compileNode, tAttrs)\n              : origAsyncDirective.templateUrl;\n\n      $compileNode.html('');\n\n      $http.get($sce.getTrustedResourceUrl(templateUrl), {cache: $templateCache}).\n        success(function(content) {\n          var compileNode, tempTemplateAttrs, $template;\n\n          content = denormalizeTemplate(content);\n\n          if (origAsyncDirective.replace) {\n            $template = jqLite('<div>' + trim(content) + '</div>').contents();\n            compileNode = $template[0];\n\n            if ($template.length != 1 || compileNode.nodeType !== 1) {\n              throw $compileMinErr('tplrt', \"Template for directive '{0}' must have exactly one root element. {1}\",\n                  origAsyncDirective.name, templateUrl);\n            }\n\n            tempTemplateAttrs = {$attr: {}};\n            replaceWith($rootElement, $compileNode, compileNode);\n            collectDirectives(compileNode, directives, tempTemplateAttrs);\n            mergeTemplateAttributes(tAttrs, tempTemplateAttrs);\n          } else {\n            compileNode = beforeTemplateCompileNode;\n            $compileNode.html(content);\n          }\n\n          directives.unshift(derivedSyncDirective);\n\n          afterTemplateNodeLinkFn = applyDirectivesToNode(directives, compileNode, tAttrs, childTranscludeFn, $compileNode, origAsyncDirective);\n          forEach($rootElement, function(node, i) {\n            if (node == compileNode) {\n              $rootElement[i] = $compileNode[0];\n            }\n          });\n          afterTemplateChildLinkFn = compileNodes($compileNode[0].childNodes, childTranscludeFn);\n\n\n          while(linkQueue.length) {\n            var scope = linkQueue.shift(),\n                beforeTemplateLinkNode = linkQueue.shift(),\n                linkRootElement = linkQueue.shift(),\n                controller = linkQueue.shift(),\n                linkNode = $compileNode[0];\n\n            if (beforeTemplateLinkNode !== beforeTemplateCompileNode) {\n              // it was cloned therefore we have to clone as well.\n              linkNode = JQLiteClone(compileNode);\n              replaceWith(linkRootElement, jqLite(beforeTemplateLinkNode), linkNode);\n            }\n\n            afterTemplateNodeLinkFn(\n              beforeTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, linkNode, $rootElement, controller),\n              scope, linkNode, $rootElement, controller\n            );\n          }\n          linkQueue = null;\n        }).\n        error(function(response, code, headers, config) {\n          throw $compileMinErr('tpload', 'Failed to load template: {0}', config.url);\n        });\n\n      return function delayedNodeLinkFn(ignoreChildLinkFn, scope, node, rootElement, controller) {\n        if (linkQueue) {\n          linkQueue.push(scope);\n          linkQueue.push(node);\n          linkQueue.push(rootElement);\n          linkQueue.push(controller);\n        } else {\n          afterTemplateNodeLinkFn(function() {\n            beforeTemplateNodeLinkFn(afterTemplateChildLinkFn, scope, node, rootElement, controller);\n          }, scope, node, rootElement, controller);\n        }\n      };\n    }\n\n\n    /**\n     * Sorting function for bound directives.\n     */\n    function byPriority(a, b) {\n      return b.priority - a.priority;\n    }\n\n\n    function assertNoDuplicate(what, previousDirective, directive, element) {\n      if (previousDirective) {\n        throw $compileMinErr('multidir', 'Multiple directives [{0}, {1}] asking for {2} on: {3}',\n            previousDirective.name, directive.name, what, startingTag(element));\n      }\n    }\n\n\n    function addTextInterpolateDirective(directives, text) {\n      var interpolateFn = $interpolate(text, true);\n      if (interpolateFn) {\n        directives.push({\n          priority: 0,\n          compile: valueFn(function textInterpolateLinkFn(scope, node) {\n            var parent = node.parent(),\n                bindings = parent.data('$binding') || [];\n            bindings.push(interpolateFn);\n            safeAddClass(parent.data('$binding', bindings), 'ng-binding');\n            scope.$watch(interpolateFn, function interpolateFnWatchAction(value) {\n              node[0].nodeValue = value;\n            });\n          })\n        });\n      }\n    }\n\n\n    function getTrustedContext(node, attrNormalizedName) {\n      // maction[xlink:href] can source SVG.  It's not limited to <maction>.\n      if (attrNormalizedName == \"xlinkHref\" ||\n          (nodeName_(node) != \"IMG\" && (attrNormalizedName == \"src\" ||\n                                        attrNormalizedName == \"ngSrc\"))) {\n        return $sce.RESOURCE_URL;\n      }\n    }\n\n\n    function addAttrInterpolateDirective(node, directives, value, name) {\n      var interpolateFn = $interpolate(value, true);\n\n      // no interpolation found -> ignore\n      if (!interpolateFn) return;\n\n\n      if (name === \"multiple\" && nodeName_(node) === \"SELECT\") {\n        throw $compileMinErr(\"selmulti\", \"Binding to the 'multiple' attribute is not supported. Element: {0}\",\n            startingTag(node));\n      }\n\n      directives.push({\n        priority: 100,\n        compile: valueFn(function attrInterpolateLinkFn(scope, element, attr) {\n          var $$observers = (attr.$$observers || (attr.$$observers = {}));\n\n          if (EVENT_HANDLER_ATTR_REGEXP.test(name)) {\n            throw $compileMinErr('nodomevents',\n                \"Interpolations for HTML DOM event attributes are disallowed.  Please use the ng- \" +\n                \"versions (such as ng-click instead of onclick) instead.\");\n          }\n\n          // we need to interpolate again, in case the attribute value has been updated\n          // (e.g. by another directive's compile function)\n          interpolateFn = $interpolate(attr[name], true, getTrustedContext(node, name));\n\n          // if attribute was updated so that there is no interpolation going on we don't want to\n          // register any observers\n          if (!interpolateFn) return;\n\n          attr[name] = interpolateFn(scope);\n          ($$observers[name] || ($$observers[name] = [])).$$inter = true;\n          (attr.$$observers && attr.$$observers[name].$$scope || scope).\n            $watch(interpolateFn, function interpolateFnWatchAction(value) {\n              attr.$set(name, value);\n            });\n        })\n      });\n    }\n\n\n    /**\n     * This is a special jqLite.replaceWith, which can replace items which\n     * have no parents, provided that the containing jqLite collection is provided.\n     *\n     * @param {JqLite=} $rootElement The root of the compile tree. Used so that we can replace nodes\n     *    in the root of the tree.\n     * @param {JqLite} elementsToRemove The jqLite element which we are going to replace. We keep the shell,\n     *    but replace its DOM node reference.\n     * @param {Node} newNode The new DOM node.\n     */\n    function replaceWith($rootElement, elementsToRemove, newNode) {\n      var firstElementToRemove = elementsToRemove[0],\n          removeCount = elementsToRemove.length,\n          parent = firstElementToRemove.parentNode,\n          i, ii;\n\n      if ($rootElement) {\n        for(i = 0, ii = $rootElement.length; i < ii; i++) {\n          if ($rootElement[i] == firstElementToRemove) {\n            $rootElement[i++] = newNode;\n            for (var j = i, j2 = j + removeCount - 1,\n                     jj = $rootElement.length;\n                 j < jj; j++, j2++) {\n              if (j2 < jj) {\n                $rootElement[j] = $rootElement[j2];\n              } else {\n                delete $rootElement[j];\n              }\n            }\n            $rootElement.length -= removeCount - 1;\n            break;\n          }\n        }\n      }\n\n      if (parent) {\n        parent.replaceChild(newNode, firstElementToRemove);\n      }\n      var fragment = document.createDocumentFragment();\n      fragment.appendChild(firstElementToRemove);\n      newNode[jqLite.expando] = firstElementToRemove[jqLite.expando];\n      for (var k = 1, kk = elementsToRemove.length; k < kk; k++) {\n        var element = elementsToRemove[k];\n        jqLite(element).remove(); // must do this way to clean up expando\n        fragment.appendChild(element);\n        delete elementsToRemove[k];\n      }\n\n      elementsToRemove[0] = newNode;\n      elementsToRemove.length = 1\n    }\n  }];\n}\n\nvar PREFIX_REGEXP = /^(x[\\:\\-_]|data[\\:\\-_])/i;\n/**\n * Converts all accepted directives format into proper directive name.\n * All of these will become 'myDirective':\n *   my:Directive\n *   my-directive\n *   x-my-directive\n *   data-my:directive\n *\n * Also there is special case for Moz prefix starting with upper case letter.\n * @param name Name to normalize\n */\nfunction directiveNormalize(name) {\n  return camelCase(name.replace(PREFIX_REGEXP, ''));\n}\n\n/**\n * @ngdoc object\n * @name ng.$compile.directive.Attributes\n * @description\n *\n * A shared object between directive compile / linking functions which contains normalized DOM element\n * attributes. The the values reflect current binding state `{{ }}`. The normalization is needed\n * since all of these are treated as equivalent in Angular:\n *\n *          <span ng:bind=\"a\" ng-bind=\"a\" data-ng-bind=\"a\" x-ng-bind=\"a\">\n */\n\n/**\n * @ngdoc property\n * @name ng.$compile.directive.Attributes#$attr\n * @propertyOf ng.$compile.directive.Attributes\n * @returns {object} A map of DOM element attribute names to the normalized name. This is\n *          needed to do reverse lookup from normalized name back to actual name.\n */\n\n\n/**\n * @ngdoc function\n * @name ng.$compile.directive.Attributes#$set\n * @methodOf ng.$compile.directive.Attributes\n * @function\n *\n * @description\n * Set DOM element attribute value.\n *\n *\n * @param {string} name Normalized element attribute name of the property to modify. The name is\n *          revers translated using the {@link ng.$compile.directive.Attributes#$attr $attr}\n *          property to the original name.\n * @param {string} value Value to set the attribute to. The value can be an interpolated string.\n */\n\n\n\n/**\n * Closure compiler type information\n */\n\nfunction nodesetLinkingFn(\n  /* angular.Scope */ scope,\n  /* NodeList */ nodeList,\n  /* Element */ rootElement,\n  /* function(Function) */ boundTranscludeFn\n){}\n\nfunction directiveLinkingFn(\n  /* nodesetLinkingFn */ nodesetLinkingFn,\n  /* angular.Scope */ scope,\n  /* Node */ node,\n  /* Element */ rootElement,\n  /* function(Function) */ boundTranscludeFn\n){}\n\n/**\n * @ngdoc object\n * @name ng.$controllerProvider\n * @description\n * The {@link ng.$controller $controller service} is used by Angular to create new\n * controllers.\n *\n * This provider allows controller registration via the\n * {@link ng.$controllerProvider#register register} method.\n */\nfunction $ControllerProvider() {\n  var controllers = {},\n      CNTRL_REG = /^(\\S+)(\\s+as\\s+(\\w+))?$/;\n\n\n  /**\n   * @ngdoc function\n   * @name ng.$controllerProvider#register\n   * @methodOf ng.$controllerProvider\n   * @param {string} name Controller name\n   * @param {Function|Array} constructor Controller constructor fn (optionally decorated with DI\n   *    annotations in the array notation).\n   */\n  this.register = function(name, constructor) {\n    if (isObject(name)) {\n      extend(controllers, name)\n    } else {\n      controllers[name] = constructor;\n    }\n  };\n\n\n  this.$get = ['$injector', '$window', function($injector, $window) {\n\n    /**\n     * @ngdoc function\n     * @name ng.$controller\n     * @requires $injector\n     *\n     * @param {Function|string} constructor If called with a function then it's considered to be the\n     *    controller constructor function. Otherwise it's considered to be a string which is used\n     *    to retrieve the controller constructor using the following steps:\n     *\n     *    * check if a controller with given name is registered via `$controllerProvider`\n     *    * check if evaluating the string on the current scope returns a constructor\n     *    * check `window[constructor]` on the global `window` object\n     *\n     * @param {Object} locals Injection locals for Controller.\n     * @return {Object} Instance of given controller.\n     *\n     * @description\n     * `$controller` service is responsible for instantiating controllers.\n     *\n     * It's just a simple call to {@link AUTO.$injector $injector}, but extracted into\n     * a service, so that one can override this service with {@link https://gist.github.com/1649788\n     * BC version}.\n     */\n    return function(expression, locals) {\n      var instance, match, constructor, identifier;\n\n      if(isString(expression)) {\n        match = expression.match(CNTRL_REG),\n        constructor = match[1],\n        identifier = match[3];\n        expression = controllers.hasOwnProperty(constructor)\n            ? controllers[constructor]\n            : getter(locals.$scope, constructor, true) || getter($window, constructor, true);\n\n        assertArgFn(expression, constructor, true);\n      }\n\n      instance = $injector.instantiate(expression, locals);\n\n      if (identifier) {\n        if (!(locals && typeof locals.$scope == 'object')) {\n          throw minErr('$controller')('noscp', \"Cannot export controller '{0}' as '{1}'! No $scope object provided via `locals`.\", constructor || expression.name, identifier);\n        }\n\n        locals.$scope[identifier] = instance;\n      }\n\n      return instance;\n    };\n  }];\n}\n\n/**\n * @ngdoc object\n * @name ng.$document\n * @requires $window\n *\n * @description\n * A {@link angular.element jQuery (lite)}-wrapped reference to the browser's `window.document`\n * element.\n */\nfunction $DocumentProvider(){\n  this.$get = ['$window', function(window){\n    return jqLite(window.document);\n  }];\n}\n\n/**\n * @ngdoc function\n * @name ng.$exceptionHandler\n * @requires $log\n *\n * @description\n * Any uncaught exception in angular expressions is delegated to this service.\n * The default implementation simply delegates to `$log.error` which logs it into\n * the browser console.\n *\n * In unit tests, if `angular-mocks.js` is loaded, this service is overridden by\n * {@link ngMock.$exceptionHandler mock $exceptionHandler} which aids in testing.\n *\n * @param {Error} exception Exception associated with the error.\n * @param {string=} cause optional information about the context in which\n *       the error was thrown.\n *\n */\nfunction $ExceptionHandlerProvider() {\n  this.$get = ['$log', function($log) {\n    return function(exception, cause) {\n      $log.error.apply($log, arguments);\n    };\n  }];\n}\n\n/**\n * Parse headers into key value object\n *\n * @param {string} headers Raw headers as a string\n * @returns {Object} Parsed headers as key value object\n */\nfunction parseHeaders(headers) {\n  var parsed = {}, key, val, i;\n\n  if (!headers) return parsed;\n\n  forEach(headers.split('\\n'), function(line) {\n    i = line.indexOf(':');\n    key = lowercase(trim(line.substr(0, i)));\n    val = trim(line.substr(i + 1));\n\n    if (key) {\n      if (parsed[key]) {\n        parsed[key] += ', ' + val;\n      } else {\n        parsed[key] = val;\n      }\n    }\n  });\n\n  return parsed;\n}\n\n\n/**\n * Returns a function that provides access to parsed headers.\n *\n * Headers are lazy parsed when first requested.\n * @see parseHeaders\n *\n * @param {(string|Object)} headers Headers to provide access to.\n * @returns {function(string=)} Returns a getter function which if called with:\n *\n *   - if called with single an argument returns a single header value or null\n *   - if called with no arguments returns an object containing all headers.\n */\nfunction headersGetter(headers) {\n  var headersObj = isObject(headers) ? headers : undefined;\n\n  return function(name) {\n    if (!headersObj) headersObj =  parseHeaders(headers);\n\n    if (name) {\n      return headersObj[lowercase(name)] || null;\n    }\n\n    return headersObj;\n  };\n}\n\n\n/**\n * Chain all given functions\n *\n * This function is used for both request and response transforming\n *\n * @param {*} data Data to transform.\n * @param {function(string=)} headers Http headers getter fn.\n * @param {(function|Array.<function>)} fns Function or an array of functions.\n * @returns {*} Transformed data.\n */\nfunction transformData(data, headers, fns) {\n  if (isFunction(fns))\n    return fns(data, headers);\n\n  forEach(fns, function(fn) {\n    data = fn(data, headers);\n  });\n\n  return data;\n}\n\n\nfunction isSuccess(status) {\n  return 200 <= status && status < 300;\n}\n\n\nfunction $HttpProvider() {\n  var JSON_START = /^\\s*(\\[|\\{[^\\{])/,\n      JSON_END = /[\\}\\]]\\s*$/,\n      PROTECTION_PREFIX = /^\\)\\]\\}',?\\n/,\n      CONTENT_TYPE_APPLICATION_JSON = {'Content-Type': 'application/json;charset=utf-8'};\n\n  var defaults = this.defaults = {\n    // transform incoming response data\n    transformResponse: [function(data) {\n      if (isString(data)) {\n        // strip json vulnerability protection prefix\n        data = data.replace(PROTECTION_PREFIX, '');\n        if (JSON_START.test(data) && JSON_END.test(data))\n          data = fromJson(data);\n      }\n      return data;\n    }],\n\n    // transform outgoing request data\n    transformRequest: [function(d) {\n      return isObject(d) && !isFile(d) ? toJson(d) : d;\n    }],\n\n    // default headers\n    headers: {\n      common: {\n        'Accept': 'application/json, text/plain, */*'\n      },\n      post:   CONTENT_TYPE_APPLICATION_JSON,\n      put:    CONTENT_TYPE_APPLICATION_JSON,\n      patch:  CONTENT_TYPE_APPLICATION_JSON\n    },\n\n    xsrfCookieName: 'XSRF-TOKEN',\n    xsrfHeaderName: 'X-XSRF-TOKEN'\n  };\n\n  /**\n   * Are order by request. I.E. they are applied in the same order as\n   * array on request, but revers order on response.\n   */\n  var interceptorFactories = this.interceptors = [];\n  /**\n   * For historical reasons, response interceptors ordered by the order in which\n   * they are applied to response. (This is in revers to interceptorFactories)\n   */\n  var responseInterceptorFactories = this.responseInterceptors = [];\n\n  this.$get = ['$httpBackend', '$browser', '$cacheFactory', '$rootScope', '$q', '$injector', '$$urlUtils',\n      function($httpBackend, $browser, $cacheFactory, $rootScope, $q, $injector, $$urlUtils) {\n\n    var defaultCache = $cacheFactory('$http');\n\n    /**\n     * Interceptors stored in reverse order. Inner interceptors before outer interceptors.\n     * The reversal is needed so that we can build up the interception chain around the\n     * server request.\n     */\n    var reversedInterceptors = [];\n\n    forEach(interceptorFactories, function(interceptorFactory) {\n      reversedInterceptors.unshift(isString(interceptorFactory)\n          ? $injector.get(interceptorFactory) : $injector.invoke(interceptorFactory));\n    });\n\n    forEach(responseInterceptorFactories, function(interceptorFactory, index) {\n      var responseFn = isString(interceptorFactory)\n          ? $injector.get(interceptorFactory)\n          : $injector.invoke(interceptorFactory);\n\n      /**\n       * Response interceptors go before \"around\" interceptors (no real reason, just\n       * had to pick one.) But they are already reversed, so we can't use unshift, hence\n       * the splice.\n       */\n      reversedInterceptors.splice(index, 0, {\n        response: function(response) {\n          return responseFn($q.when(response));\n        },\n        responseError: function(response) {\n          return responseFn($q.reject(response));\n        }\n      });\n    });\n\n\n    /**\n     * @ngdoc function\n     * @name ng.$http\n     * @requires $httpBackend\n     * @requires $browser\n     * @requires $cacheFactory\n     * @requires $rootScope\n     * @requires $q\n     * @requires $injector\n     *\n     * @description\n     * The `$http` service is a core Angular service that facilitates communication with the remote\n     * HTTP servers via the browser's {@link https://developer.mozilla.org/en/xmlhttprequest\n     * XMLHttpRequest} object or via {@link http://en.wikipedia.org/wiki/JSONP JSONP}.\n     *\n     * For unit testing applications that use `$http` service, see\n     * {@link ngMock.$httpBackend $httpBackend mock}.\n     *\n     * For a higher level of abstraction, please check out the {@link ngResource.$resource\n     * $resource} service.\n     *\n     * The $http API is based on the {@link ng.$q deferred/promise APIs} exposed by\n     * the $q service. While for simple usage patterns this doesn't matter much, for advanced usage\n     * it is important to familiarize yourself with these APIs and the guarantees they provide.\n     *\n     *\n     * # General usage\n     * The `$http` service is a function which takes a single argument — a configuration object —\n     * that is used to generate an HTTP request and returns  a {@link ng.$q promise}\n     * with two $http specific methods: `success` and `error`.\n     *\n     * <pre>\n     *   $http({method: 'GET', url: '/someUrl'}).\n     *     success(function(data, status, headers, config) {\n     *       // this callback will be called asynchronously\n     *       // when the response is available\n     *     }).\n     *     error(function(data, status, headers, config) {\n     *       // called asynchronously if an error occurs\n     *       // or server returns response with an error status.\n     *     });\n     * </pre>\n     *\n     * Since the returned value of calling the $http function is a `promise`, you can also use\n     * the `then` method to register callbacks, and these callbacks will receive a single argument –\n     * an object representing the response. See the API signature and type info below for more\n     * details.\n     *\n     * A response status code between 200 and 299 is considered a success status and\n     * will result in the success callback being called. Note that if the response is a redirect,\n     * XMLHttpRequest will transparently follow it, meaning that the error callback will not be\n     * called for such responses.\n     *\n     * # Shortcut methods\n     *\n     * Since all invocations of the $http service require passing in an HTTP method and URL, and\n     * POST/PUT requests require request data to be provided as well, shortcut methods\n     * were created:\n     *\n     * <pre>\n     *   $http.get('/someUrl').success(successCallback);\n     *   $http.post('/someUrl', data).success(successCallback);\n     * </pre>\n     *\n     * Complete list of shortcut methods:\n     *\n     * - {@link ng.$http#get $http.get}\n     * - {@link ng.$http#head $http.head}\n     * - {@link ng.$http#post $http.post}\n     * - {@link ng.$http#put $http.put}\n     * - {@link ng.$http#delete $http.delete}\n     * - {@link ng.$http#jsonp $http.jsonp}\n     *\n     *\n     * # Setting HTTP Headers\n     *\n     * The $http service will automatically add certain HTTP headers to all requests. These defaults\n     * can be fully configured by accessing the `$httpProvider.defaults.headers` configuration\n     * object, which currently contains this default configuration:\n     *\n     * - `$httpProvider.defaults.headers.common` (headers that are common for all requests):\n     *   - `Accept: application/json, text/plain, * / *`\n     * - `$httpProvider.defaults.headers.post`: (header defaults for POST requests)\n     *   - `Content-Type: application/json`\n     * - `$httpProvider.defaults.headers.put` (header defaults for PUT requests)\n     *   - `Content-Type: application/json`\n     *\n     * To add or overwrite these defaults, simply add or remove a property from these configuration\n     * objects. To add headers for an HTTP method other than POST or PUT, simply add a new object\n     * with the lowercased HTTP method name as the key, e.g.\n     * `$httpProvider.defaults.headers.get['My-Header']='value'`.\n     *\n     * Additionally, the defaults can be set at runtime via the `$http.defaults` object in the same\n     * fashion.\n     *\n     *\n     * # Transforming Requests and Responses\n     *\n     * Both requests and responses can be transformed using transform functions. By default, Angular\n     * applies these transformations:\n     *\n     * Request transformations:\n     *\n     * - If the `data` property of the request configuration object contains an object, serialize it into\n     *   JSON format.\n     *\n     * Response transformations:\n     *\n     *  - If XSRF prefix is detected, strip it (see Security Considerations section below).\n     *  - If JSON response is detected, deserialize it using a JSON parser.\n     *\n     * To globally augment or override the default transforms, modify the `$httpProvider.defaults.transformRequest` and\n     * `$httpProvider.defaults.transformResponse` properties. These properties are by default an\n     * array of transform functions, which allows you to `push` or `unshift` a new transformation function into the\n     * transformation chain. You can also decide to completely override any default transformations by assigning your\n     * transformation functions to these properties directly without the array wrapper.\n     *\n     * Similarly, to locally override the request/response transforms, augment the `transformRequest` and/or\n     * `transformResponse` properties of the configuration object passed into `$http`.\n     *\n     *\n     * # Caching\n     *\n     * To enable caching, set the configuration property `cache` to `true`. When the cache is\n     * enabled, `$http` stores the response from the server in local cache. Next time the\n     * response is served from the cache without sending a request to the server.\n     *\n     * Note that even if the response is served from cache, delivery of the data is asynchronous in\n     * the same way that real requests are.\n     *\n     * If there are multiple GET requests for the same URL that should be cached using the same\n     * cache, but the cache is not populated yet, only one request to the server will be made and\n     * the remaining requests will be fulfilled using the response from the first request.\n     *\n     * A custom default cache built with $cacheFactory can be provided in $http.defaults.cache.\n     * To skip it, set configuration property `cache` to `false`.\n     *\n     *\n     * # Interceptors\n     *\n     * Before you start creating interceptors, be sure to understand the\n     * {@link ng.$q $q and deferred/promise APIs}.\n     *\n     * For purposes of global error handling, authentication, or any kind of synchronous or\n     * asynchronous pre-processing of request or postprocessing of responses, it is desirable to be\n     * able to intercept requests before they are handed to the server and\n     * responses before they are handed over to the application code that\n     * initiated these requests. The interceptors leverage the {@link ng.$q\n     * promise APIs} to fulfill this need for both synchronous and asynchronous pre-processing.\n     *\n     * The interceptors are service factories that are registered with the `$httpProvider` by\n     * adding them to the `$httpProvider.interceptors` array. The factory is called and\n     * injected with dependencies (if specified) and returns the interceptor.\n     *\n     * There are two kinds of interceptors (and two kinds of rejection interceptors):\n     *\n     *   * `request`: interceptors get called with http `config` object. The function is free to modify\n     *     the `config` or create a new one. The function needs to return the `config` directly or as a\n     *     promise.\n     *   * `requestError`: interceptor gets called when a previous interceptor threw an error or resolved\n     *      with a rejection.\n     *   * `response`: interceptors get called with http `response` object. The function is free to modify\n     *     the `response` or create a new one. The function needs to return the `response` directly or as a\n     *     promise.\n     *   * `responseError`: interceptor gets called when a previous interceptor threw an error or resolved\n     *      with a rejection.\n     *\n     *\n     * <pre>\n     *   // register the interceptor as a service\n     *   $provide.factory('myHttpInterceptor', function($q, dependency1, dependency2) {\n     *     return {\n     *       // optional method\n     *       'request': function(config) {\n     *         // do something on success\n     *         return config || $q.when(config);\n     *       },\n     *\n     *       // optional method\n     *      'requestError': function(rejection) {\n     *         // do something on error\n     *         if (canRecover(rejection)) {\n     *           return responseOrNewPromise\n     *         }\n     *         return $q.reject(rejection);\n     *       },\n     *\n     *\n     *\n     *       // optional method\n     *       'response': function(response) {\n     *         // do something on success\n     *         return response || $q.when(response);\n     *       },\n     *\n     *       // optional method\n     *      'responseError': function(rejection) {\n     *         // do something on error\n     *         if (canRecover(rejection)) {\n     *           return responseOrNewPromise\n     *         }\n     *         return $q.reject(rejection);\n     *       };\n     *     }\n     *   });\n     *\n     *   $httpProvider.interceptors.push('myHttpInterceptor');\n     *\n     *\n     *   // register the interceptor via an anonymous factory\n     *   $httpProvider.interceptors.push(function($q, dependency1, dependency2) {\n     *     return {\n     *      'request': function(config) {\n     *          // same as above\n     *       },\n     *       'response': function(response) {\n     *          // same as above\n     *       }\n     *   });\n     * </pre>\n     *\n     * # Response interceptors (DEPRECATED)\n     *\n     * Before you start creating interceptors, be sure to understand the\n     * {@link ng.$q $q and deferred/promise APIs}.\n     *\n     * For purposes of global error handling, authentication or any kind of synchronous or\n     * asynchronous preprocessing of received responses, it is desirable to be able to intercept\n     * responses for http requests before they are handed over to the application code that\n     * initiated these requests. The response interceptors leverage the {@link ng.$q\n     * promise apis} to fulfil this need for both synchronous and asynchronous preprocessing.\n     *\n     * The interceptors are service factories that are registered with the $httpProvider by\n     * adding them to the `$httpProvider.responseInterceptors` array. The factory is called and\n     * injected with dependencies (if specified) and returns the interceptor  — a function that\n     * takes a {@link ng.$q promise} and returns the original or a new promise.\n     *\n     * <pre>\n     *   // register the interceptor as a service\n     *   $provide.factory('myHttpInterceptor', function($q, dependency1, dependency2) {\n     *     return function(promise) {\n     *       return promise.then(function(response) {\n     *         // do something on success\n     *         return response;\n     *       }, function(response) {\n     *         // do something on error\n     *         if (canRecover(response)) {\n     *           return responseOrNewPromise\n     *         }\n     *         return $q.reject(response);\n     *       });\n     *     }\n     *   });\n     *\n     *   $httpProvider.responseInterceptors.push('myHttpInterceptor');\n     *\n     *\n     *   // register the interceptor via an anonymous factory\n     *   $httpProvider.responseInterceptors.push(function($q, dependency1, dependency2) {\n     *     return function(promise) {\n     *       // same as above\n     *     }\n     *   });\n     * </pre>\n     *\n     *\n     * # Security Considerations\n     *\n     * When designing web applications, consider security threats from:\n     *\n     * - {@link http://haacked.com/archive/2008/11/20/anatomy-of-a-subtle-json-vulnerability.aspx\n     *   JSON vulnerability}\n     * - {@link http://en.wikipedia.org/wiki/Cross-site_request_forgery XSRF}\n     *\n     * Both server and the client must cooperate in order to eliminate these threats. Angular comes\n     * pre-configured with strategies that address these issues, but for this to work backend server\n     * cooperation is required.\n     *\n     * ## JSON Vulnerability Protection\n     *\n     * A {@link http://haacked.com/archive/2008/11/20/anatomy-of-a-subtle-json-vulnerability.aspx\n     * JSON vulnerability} allows third party website to turn your JSON resource URL into\n     * {@link http://en.wikipedia.org/wiki/JSONP JSONP} request under some conditions. To\n     * counter this your server can prefix all JSON requests with following string `\")]}',\\n\"`.\n     * Angular will automatically strip the prefix before processing it as JSON.\n     *\n     * For example if your server needs to return:\n     * <pre>\n     * ['one','two']\n     * </pre>\n     *\n     * which is vulnerable to attack, your server can return:\n     * <pre>\n     * )]}',\n     * ['one','two']\n     * </pre>\n     *\n     * Angular will strip the prefix, before processing the JSON.\n     *\n     *\n     * ## Cross Site Request Forgery (XSRF) Protection\n     *\n     * {@link http://en.wikipedia.org/wiki/Cross-site_request_forgery XSRF} is a technique by which\n     * an unauthorized site can gain your user's private data. Angular provides a mechanism\n     * to counter XSRF. When performing XHR requests, the $http service reads a token from a cookie\n     * (by default, `XSRF-TOKEN`) and sets it as an HTTP header (`X-XSRF-TOKEN`). Since only\n     * JavaScript that runs on your domain could read the cookie, your server can be assured that\n     * the XHR came from JavaScript running on your domain. The header will not be set for\n     * cross-domain requests.\n     *\n     * To take advantage of this, your server needs to set a token in a JavaScript readable session\n     * cookie called `XSRF-TOKEN` on the first HTTP GET request. On subsequent XHR requests the\n     * server can verify that the cookie matches `X-XSRF-TOKEN` HTTP header, and therefore be sure\n     * that only JavaScript running on your domain could have sent the request. The token must be\n     * unique for each user and must be verifiable by the server (to prevent the JavaScript from making\n     * up its own tokens). We recommend that the token is a digest of your site's authentication\n     * cookie with a {@link https://en.wikipedia.org/wiki/Salt_(cryptography) salt} for added security.\n     *\n     * The name of the headers can be specified using the xsrfHeaderName and xsrfCookieName\n     * properties of either $httpProvider.defaults, or the per-request config object.\n     *\n     *\n     * @param {object} config Object describing the request to be made and how it should be\n     *    processed. The object has following properties:\n     *\n     *    - **method** – `{string}` – HTTP method (e.g. 'GET', 'POST', etc)\n     *    - **url** – `{string}` – Absolute or relative URL of the resource that is being requested.\n     *    - **params** – `{Object.<string|Object>}` – Map of strings or objects which will be turned to\n     *      `?key1=value1&key2=value2` after the url. If the value is not a string, it will be JSONified.\n     *    - **data** – `{string|Object}` – Data to be sent as the request message data.\n     *    - **headers** – `{Object}` – Map of strings or functions which return strings representing\n     *      HTTP headers to send to the server. If the return value of a function is null, the header will\n     *      not be sent.\n     *    - **xsrfHeaderName** – `{string}` – Name of HTTP header to populate with the XSRF token.\n     *    - **xsrfCookieName** – `{string}` – Name of cookie containing the XSRF token.\n     *    - **transformRequest** – `{function(data, headersGetter)|Array.<function(data, headersGetter)>}` –\n     *      transform function or an array of such functions. The transform function takes the http\n     *      request body and headers and returns its transformed (typically serialized) version.\n     *    - **transformResponse** – `{function(data, headersGetter)|Array.<function(data, headersGetter)>}` –\n     *      transform function or an array of such functions. The transform function takes the http\n     *      response body and headers and returns its transformed (typically deserialized) version.\n     *    - **cache** – `{boolean|Cache}` – If true, a default $http cache will be used to cache the\n     *      GET request, otherwise if a cache instance built with\n     *      {@link ng.$cacheFactory $cacheFactory}, this cache will be used for\n     *      caching.\n     *    - **timeout** – `{number|Promise}` – timeout in milliseconds, or {@link ng.$q promise}\n     *      that should abort the request when resolved.\n     *    - **withCredentials** - `{boolean}` - whether to to set the `withCredentials` flag on the\n     *      XHR object. See {@link https://developer.mozilla.org/en/http_access_control#section_5\n     *      requests with credentials} for more information.\n     *    - **responseType** - `{string}` - see {@link\n     *      https://developer.mozilla.org/en-US/docs/DOM/XMLHttpRequest#responseType requestType}.\n     *\n     * @returns {HttpPromise} Returns a {@link ng.$q promise} object with the\n     *   standard `then` method and two http specific methods: `success` and `error`. The `then`\n     *   method takes two arguments a success and an error callback which will be called with a\n     *   response object. The `success` and `error` methods take a single argument - a function that\n     *   will be called when the request succeeds or fails respectively. The arguments passed into\n     *   these functions are destructured representation of the response object passed into the\n     *   `then` method. The response object has these properties:\n     *\n     *   - **data** – `{string|Object}` – The response body transformed with the transform functions.\n     *   - **status** – `{number}` – HTTP status code of the response.\n     *   - **headers** – `{function([headerName])}` – Header getter function.\n     *   - **config** – `{Object}` – The configuration object that was used to generate the request.\n     *\n     * @property {Array.<Object>} pendingRequests Array of config objects for currently pending\n     *   requests. This is primarily meant to be used for debugging purposes.\n     *\n     *\n     * @example\n      <example>\n        <file name=\"index.html\">\n          <div ng-controller=\"FetchCtrl\">\n            <select ng-model=\"method\">\n              <option>GET</option>\n              <option>JSONP</option>\n            </select>\n            <input type=\"text\" ng-model=\"url\" size=\"80\"/>\n            <button ng-click=\"fetch()\">fetch</button><br>\n            <button ng-click=\"updateModel('GET', 'http-hello.html')\">Sample GET</button>\n            <button ng-click=\"updateModel('JSONP', 'http://angularjs.org/greet.php?callback=JSON_CALLBACK&name=Super%20Hero')\">Sample JSONP</button>\n            <button ng-click=\"updateModel('JSONP', 'http://angularjs.org/doesntexist&callback=JSON_CALLBACK')\">Invalid JSONP</button>\n            <pre>http status code: {{status}}</pre>\n            <pre>http response data: {{data}}</pre>\n          </div>\n        </file>\n        <file name=\"script.js\">\n          function FetchCtrl($scope, $http, $templateCache) {\n            $scope.method = 'GET';\n            $scope.url = 'http-hello.html';\n\n            $scope.fetch = function() {\n              $scope.code = null;\n              $scope.response = null;\n\n              $http({method: $scope.method, url: $scope.url, cache: $templateCache}).\n                success(function(data, status) {\n                  $scope.status = status;\n                  $scope.data = data;\n                }).\n                error(function(data, status) {\n                  $scope.data = data || \"Request failed\";\n                  $scope.status = status;\n              });\n            };\n\n            $scope.updateModel = function(method, url) {\n              $scope.method = method;\n              $scope.url = url;\n            };\n          }\n        </file>\n        <file name=\"http-hello.html\">\n          Hello, $http!\n        </file>\n        <file name=\"scenario.js\">\n          it('should make an xhr GET request', function() {\n            element(':button:contains(\"Sample GET\")').click();\n            element(':button:contains(\"fetch\")').click();\n            expect(binding('status')).toBe('200');\n            expect(binding('data')).toMatch(/Hello, \\$http!/);\n          });\n\n          it('should make a JSONP request to angularjs.org', function() {\n            element(':button:contains(\"Sample JSONP\")').click();\n            element(':button:contains(\"fetch\")').click();\n            expect(binding('status')).toBe('200');\n            expect(binding('data')).toMatch(/Super Hero!/);\n          });\n\n          it('should make JSONP request to invalid URL and invoke the error handler',\n              function() {\n            element(':button:contains(\"Invalid JSONP\")').click();\n            element(':button:contains(\"fetch\")').click();\n            expect(binding('status')).toBe('0');\n            expect(binding('data')).toBe('Request failed');\n          });\n        </file>\n      </example>\n     */\n    function $http(requestConfig) {\n      var config = {\n        transformRequest: defaults.transformRequest,\n        transformResponse: defaults.transformResponse\n      };\n      var headers = mergeHeaders(requestConfig);\n\n      extend(config, requestConfig);\n      config.headers = headers;\n      config.method = uppercase(config.method);\n\n      var xsrfValue = $$urlUtils.isSameOrigin(config.url)\n          ? $browser.cookies()[config.xsrfCookieName || defaults.xsrfCookieName]\n          : undefined;\n      if (xsrfValue) {\n        headers[(config.xsrfHeaderName || defaults.xsrfHeaderName)] = xsrfValue;\n      }\n\n\n      var serverRequest = function(config) {\n        headers = config.headers;\n        var reqData = transformData(config.data, headersGetter(headers), config.transformRequest);\n\n        // strip content-type if data is undefined\n        if (isUndefined(config.data)) {\n          forEach(headers, function(value, header) {\n            if (lowercase(header) === 'content-type') {\n                delete headers[header];\n            }\n          });\n        }\n\n        if (isUndefined(config.withCredentials) && !isUndefined(defaults.withCredentials)) {\n          config.withCredentials = defaults.withCredentials;\n        }\n\n        // send request\n        return sendReq(config, reqData, headers).then(transformResponse, transformResponse);\n      };\n\n      var chain = [serverRequest, undefined];\n      var promise = $q.when(config);\n\n      // apply interceptors\n      forEach(reversedInterceptors, function(interceptor) {\n        if (interceptor.request || interceptor.requestError) {\n          chain.unshift(interceptor.request, interceptor.requestError);\n        }\n        if (interceptor.response || interceptor.responseError) {\n          chain.push(interceptor.response, interceptor.responseError);\n        }\n      });\n\n      while(chain.length) {\n        var thenFn = chain.shift();\n        var rejectFn = chain.shift();\n\n        promise = promise.then(thenFn, rejectFn);\n      }\n\n      promise.success = function(fn) {\n        promise.then(function(response) {\n          fn(response.data, response.status, response.headers, config);\n        });\n        return promise;\n      };\n\n      promise.error = function(fn) {\n        promise.then(null, function(response) {\n          fn(response.data, response.status, response.headers, config);\n        });\n        return promise;\n      };\n\n      return promise;\n\n      function transformResponse(response) {\n        // make a copy since the response must be cacheable\n        var resp = extend({}, response, {\n          data: transformData(response.data, response.headers, config.transformResponse)\n        });\n        return (isSuccess(response.status))\n          ? resp\n          : $q.reject(resp);\n      }\n\n      function mergeHeaders(config) {\n        var defHeaders = defaults.headers,\n            reqHeaders = extend({}, config.headers),\n            defHeaderName, lowercaseDefHeaderName, reqHeaderName;\n\n        defHeaders = extend({}, defHeaders.common, defHeaders[lowercase(config.method)]);\n\n        // execute if header value is function\n        execHeaders(defHeaders);\n        execHeaders(reqHeaders);\n\n        // using for-in instead of forEach to avoid unecessary iteration after header has been found\n        defaultHeadersIteration:\n        for (defHeaderName in defHeaders) {\n          lowercaseDefHeaderName = lowercase(defHeaderName);\n\n          for (reqHeaderName in reqHeaders) {\n            if (lowercase(reqHeaderName) === lowercaseDefHeaderName) {\n              continue defaultHeadersIteration;\n            }\n          }\n\n          reqHeaders[defHeaderName] = defHeaders[defHeaderName];\n        }\n\n        return reqHeaders;\n\n        function execHeaders(headers) {\n          var headerContent;\n\n          forEach(headers, function(headerFn, header) {\n            if (isFunction(headerFn)) {\n              headerContent = headerFn();\n              if (headerContent != null) {\n                headers[header] = headerContent;\n              } else {\n                delete headers[header];\n              }\n            }\n          });\n        }\n      }\n    }\n\n    $http.pendingRequests = [];\n\n    /**\n     * @ngdoc method\n     * @name ng.$http#get\n     * @methodOf ng.$http\n     *\n     * @description\n     * Shortcut method to perform `GET` request.\n     *\n     * @param {string} url Relative or absolute URL specifying the destination of the request\n     * @param {Object=} config Optional configuration object\n     * @returns {HttpPromise} Future object\n     */\n\n    /**\n     * @ngdoc method\n     * @name ng.$http#delete\n     * @methodOf ng.$http\n     *\n     * @description\n     * Shortcut method to perform `DELETE` request.\n     *\n     * @param {string} url Relative or absolute URL specifying the destination of the request\n     * @param {Object=} config Optional configuration object\n     * @returns {HttpPromise} Future object\n     */\n\n    /**\n     * @ngdoc method\n     * @name ng.$http#head\n     * @methodOf ng.$http\n     *\n     * @description\n     * Shortcut method to perform `HEAD` request.\n     *\n     * @param {string} url Relative or absolute URL specifying the destination of the request\n     * @param {Object=} config Optional configuration object\n     * @returns {HttpPromise} Future object\n     */\n\n    /**\n     * @ngdoc method\n     * @name ng.$http#jsonp\n     * @methodOf ng.$http\n     *\n     * @description\n     * Shortcut method to perform `JSONP` request.\n     *\n     * @param {string} url Relative or absolute URL specifying the destination of the request.\n     *                     Should contain `JSON_CALLBACK` string.\n     * @param {Object=} config Optional configuration object\n     * @returns {HttpPromise} Future object\n     */\n    createShortMethods('get', 'delete', 'head', 'jsonp');\n\n    /**\n     * @ngdoc method\n     * @name ng.$http#post\n     * @methodOf ng.$http\n     *\n     * @description\n     * Shortcut method to perform `POST` request.\n     *\n     * @param {string} url Relative or absolute URL specifying the destination of the request\n     * @param {*} data Request content\n     * @param {Object=} config Optional configuration object\n     * @returns {HttpPromise} Future object\n     */\n\n    /**\n     * @ngdoc method\n     * @name ng.$http#put\n     * @methodOf ng.$http\n     *\n     * @description\n     * Shortcut method to perform `PUT` request.\n     *\n     * @param {string} url Relative or absolute URL specifying the destination of the request\n     * @param {*} data Request content\n     * @param {Object=} config Optional configuration object\n     * @returns {HttpPromise} Future object\n     */\n    createShortMethodsWithData('post', 'put');\n\n        /**\n         * @ngdoc property\n         * @name ng.$http#defaults\n         * @propertyOf ng.$http\n         *\n         * @description\n         * Runtime equivalent of the `$httpProvider.defaults` property. Allows configuration of\n         * default headers, withCredentials as well as request and response transformations.\n         *\n         * See \"Setting HTTP Headers\" and \"Transforming Requests and Responses\" sections above.\n         */\n    $http.defaults = defaults;\n\n\n    return $http;\n\n\n    function createShortMethods(names) {\n      forEach(arguments, function(name) {\n        $http[name] = function(url, config) {\n          return $http(extend(config || {}, {\n            method: name,\n            url: url\n          }));\n        };\n      });\n    }\n\n\n    function createShortMethodsWithData(name) {\n      forEach(arguments, function(name) {\n        $http[name] = function(url, data, config) {\n          return $http(extend(config || {}, {\n            method: name,\n            url: url,\n            data: data\n          }));\n        };\n      });\n    }\n\n\n    /**\n     * Makes the request.\n     *\n     * !!! ACCESSES CLOSURE VARS:\n     * $httpBackend, defaults, $log, $rootScope, defaultCache, $http.pendingRequests\n     */\n    function sendReq(config, reqData, reqHeaders) {\n      var deferred = $q.defer(),\n          promise = deferred.promise,\n          cache,\n          cachedResp,\n          url = buildUrl(config.url, config.params);\n\n      $http.pendingRequests.push(config);\n      promise.then(removePendingReq, removePendingReq);\n\n\n      if ((config.cache || defaults.cache) && config.cache !== false && config.method == 'GET') {\n        cache = isObject(config.cache) ? config.cache\n              : isObject(defaults.cache) ? defaults.cache\n              : defaultCache;\n      }\n\n      if (cache) {\n        cachedResp = cache.get(url);\n        if (isDefined(cachedResp)) {\n          if (cachedResp.then) {\n            // cached request has already been sent, but there is no response yet\n            cachedResp.then(removePendingReq, removePendingReq);\n            return cachedResp;\n          } else {\n            // serving from cache\n            if (isArray(cachedResp)) {\n              resolvePromise(cachedResp[1], cachedResp[0], copy(cachedResp[2]));\n            } else {\n              resolvePromise(cachedResp, 200, {});\n            }\n          }\n        } else {\n          // put the promise for the non-transformed response into cache as a placeholder\n          cache.put(url, promise);\n        }\n      }\n\n      // if we won't have the response in cache, send the request to the backend\n      if (isUndefined(cachedResp)) {\n        $httpBackend(config.method, url, reqData, done, reqHeaders, config.timeout,\n            config.withCredentials, config.responseType);\n      }\n\n      return promise;\n\n\n      /**\n       * Callback registered to $httpBackend():\n       *  - caches the response if desired\n       *  - resolves the raw $http promise\n       *  - calls $apply\n       */\n      function done(status, response, headersString) {\n        if (cache) {\n          if (isSuccess(status)) {\n            cache.put(url, [status, response, parseHeaders(headersString)]);\n          } else {\n            // remove promise from the cache\n            cache.remove(url);\n          }\n        }\n\n        resolvePromise(response, status, headersString);\n        if (!$rootScope.$$phase) $rootScope.$apply();\n      }\n\n\n      /**\n       * Resolves the raw $http promise.\n       */\n      function resolvePromise(response, status, headers) {\n        // normalize internal statuses to 0\n        status = Math.max(status, 0);\n\n        (isSuccess(status) ? deferred.resolve : deferred.reject)({\n          data: response,\n          status: status,\n          headers: headersGetter(headers),\n          config: config\n        });\n      }\n\n\n      function removePendingReq() {\n        var idx = indexOf($http.pendingRequests, config);\n        if (idx !== -1) $http.pendingRequests.splice(idx, 1);\n      }\n    }\n\n\n    function buildUrl(url, params) {\n          if (!params) return url;\n          var parts = [];\n          forEachSorted(params, function(value, key) {\n            if (value == null || value == undefined) return;\n            if (!isArray(value)) value = [value];\n\n            forEach(value, function(v) {\n              if (isObject(v)) {\n                v = toJson(v);\n              }\n              parts.push(encodeUriQuery(key) + '=' +\n                         encodeUriQuery(v));\n            });\n          });\n          return url + ((url.indexOf('?') == -1) ? '?' : '&') + parts.join('&');\n        }\n\n\n  }];\n}\n\nvar XHR = window.XMLHttpRequest || function() {\n  try { return new ActiveXObject(\"Msxml2.XMLHTTP.6.0\"); } catch (e1) {}\n  try { return new ActiveXObject(\"Msxml2.XMLHTTP.3.0\"); } catch (e2) {}\n  try { return new ActiveXObject(\"Msxml2.XMLHTTP\"); } catch (e3) {}\n  throw minErr('$httpBackend')('noxhr', \"This browser does not support XMLHttpRequest.\");\n};\n\n\n/**\n * @ngdoc object\n * @name ng.$httpBackend\n * @requires $browser\n * @requires $window\n * @requires $document\n *\n * @description\n * HTTP backend used by the {@link ng.$http service} that delegates to\n * XMLHttpRequest object or JSONP and deals with browser incompatibilities.\n *\n * You should never need to use this service directly, instead use the higher-level abstractions:\n * {@link ng.$http $http} or {@link ngResource.$resource $resource}.\n *\n * During testing this implementation is swapped with {@link ngMock.$httpBackend mock\n * $httpBackend} which can be trained with responses.\n */\nfunction $HttpBackendProvider() {\n  this.$get = ['$browser', '$window', '$document', function($browser, $window, $document) {\n    return createHttpBackend($browser, XHR, $browser.defer, $window.angular.callbacks,\n        $document[0], $window.location.protocol.replace(':', ''));\n  }];\n}\n\nfunction createHttpBackend($browser, XHR, $browserDefer, callbacks, rawDocument, locationProtocol) {\n  // TODO(vojta): fix the signature\n  return function(method, url, post, callback, headers, timeout, withCredentials, responseType) {\n    var status;\n    $browser.$$incOutstandingRequestCount();\n    url = url || $browser.url();\n\n    if (lowercase(method) == 'jsonp') {\n      var callbackId = '_' + (callbacks.counter++).toString(36);\n      callbacks[callbackId] = function(data) {\n        callbacks[callbackId].data = data;\n      };\n\n      var jsonpDone = jsonpReq(url.replace('JSON_CALLBACK', 'angular.callbacks.' + callbackId),\n          function() {\n        if (callbacks[callbackId].data) {\n          completeRequest(callback, 200, callbacks[callbackId].data);\n        } else {\n          completeRequest(callback, status || -2);\n        }\n        delete callbacks[callbackId];\n      });\n    } else {\n      var xhr = new XHR();\n      xhr.open(method, url, true);\n      forEach(headers, function(value, key) {\n        if (value) xhr.setRequestHeader(key, value);\n      });\n\n      // In IE6 and 7, this might be called synchronously when xhr.send below is called and the\n      // response is in the cache. the promise api will ensure that to the app code the api is\n      // always async\n      xhr.onreadystatechange = function() {\n        if (xhr.readyState == 4) {\n          var responseHeaders = xhr.getAllResponseHeaders();\n\n          // TODO(vojta): remove once Firefox 21 gets released.\n          // begin: workaround to overcome Firefox CORS http response headers bug\n          // https://bugzilla.mozilla.org/show_bug.cgi?id=608735\n          // Firefox already patched in nightly. Should land in Firefox 21.\n\n          // CORS \"simple response headers\" http://www.w3.org/TR/cors/\n          var value,\n              simpleHeaders = [\"Cache-Control\", \"Content-Language\", \"Content-Type\",\n                                  \"Expires\", \"Last-Modified\", \"Pragma\"];\n          if (!responseHeaders) {\n            responseHeaders = \"\";\n            forEach(simpleHeaders, function (header) {\n              var value = xhr.getResponseHeader(header);\n              if (value) {\n                  responseHeaders += header + \": \" + value + \"\\n\";\n              }\n            });\n          }\n          // end of the workaround.\n\n          // responseText is the old-school way of retrieving response (supported by IE8 & 9)\n          // response and responseType properties were introduced in XHR Level2 spec (supported by IE10)\n          completeRequest(callback,\n              status || xhr.status,\n              (xhr.responseType ? xhr.response : xhr.responseText),\n              responseHeaders);\n        }\n      };\n\n      if (withCredentials) {\n        xhr.withCredentials = true;\n      }\n\n      if (responseType) {\n        xhr.responseType = responseType;\n      }\n\n      xhr.send(post || '');\n    }\n\n    if (timeout > 0) {\n      var timeoutId = $browserDefer(timeoutRequest, timeout);\n    } else if (timeout && timeout.then) {\n      timeout.then(timeoutRequest);\n    }\n\n\n    function timeoutRequest() {\n      status = -1;\n      jsonpDone && jsonpDone();\n      xhr && xhr.abort();\n    }\n\n    function completeRequest(callback, status, response, headersString) {\n      // URL_MATCH is defined in src/service/location.js\n      var protocol = (url.match(SERVER_MATCH) || ['', locationProtocol])[1];\n\n      // cancel timeout and subsequent timeout promise resolution\n      timeoutId && $browserDefer.cancel(timeoutId);\n      jsonpDone = xhr = null;\n\n      // fix status code for file protocol (it's always 0)\n      status = (protocol == 'file') ? (response ? 200 : 404) : status;\n\n      // normalize IE bug (http://bugs.jquery.com/ticket/1450)\n      status = status == 1223 ? 204 : status;\n\n      callback(status, response, headersString);\n      $browser.$$completeOutstandingRequest(noop);\n    }\n  };\n\n  function jsonpReq(url, done) {\n    // we can't use jQuery/jqLite here because jQuery does crazy shit with script elements, e.g.:\n    // - fetches local scripts via XHR and evals them\n    // - adds and immediately removes script elements from the document\n    var script = rawDocument.createElement('script'),\n        doneWrapper = function() {\n          rawDocument.body.removeChild(script);\n          if (done) done();\n        };\n\n    script.type = 'text/javascript';\n    script.src = url;\n\n    if (msie) {\n      script.onreadystatechange = function() {\n        if (/loaded|complete/.test(script.readyState)) doneWrapper();\n      };\n    } else {\n      script.onload = script.onerror = doneWrapper;\n    }\n\n    rawDocument.body.appendChild(script);\n    return doneWrapper;\n  }\n}\n\nvar $interpolateMinErr = minErr('$interpolate');\n\n/**\n * @ngdoc object\n * @name ng.$interpolateProvider\n * @function\n *\n * @description\n *\n * Used for configuring the interpolation markup. Defaults to `{{` and `}}`.\n *\n * @example\n   <doc:example module=\"customInterpolationApp\">\n     <doc:source>\n      <script>\n        var customInterpolationApp = angular.module('customInterpolationApp', []);\n\n        customInterpolationApp.config(function($interpolateProvider) {\n          $interpolateProvider.startSymbol('//');\n          $interpolateProvider.endSymbol('//');\n        });\n\n\n        customInterpolationApp.controller('DemoController', function DemoController() {\n            this.label = \"This bindings is brought you you by // interpolation symbols.\";\n        });\n      </script>\n      <div ng-app=\"App\" ng-controller=\"DemoController as demo\">\n          //demo.label//\n      </div>\n     </doc:source>\n     <doc:scenario>\n       it('should interpolate binding with custom symbols', function() {\n         expect(binding('demo.label')).toBe('This bindings is brought you you by // interpolation symbols.');\n       });\n </doc:scenario>\n   </doc:example>\n */\nfunction $InterpolateProvider() {\n  var startSymbol = '{{';\n  var endSymbol = '}}';\n\n  /**\n   * @ngdoc method\n   * @name ng.$interpolateProvider#startSymbol\n   * @methodOf ng.$interpolateProvider\n   * @description\n   * Symbol to denote start of expression in the interpolated string. Defaults to `{{`.\n   *\n   * @param {string=} value new value to set the starting symbol to.\n   * @returns {string|self} Returns the symbol when used as getter and self if used as setter.\n   */\n  this.startSymbol = function(value){\n    if (value) {\n      startSymbol = value;\n      return this;\n    } else {\n      return startSymbol;\n    }\n  };\n\n  /**\n   * @ngdoc method\n   * @name ng.$interpolateProvider#endSymbol\n   * @methodOf ng.$interpolateProvider\n   * @description\n   * Symbol to denote the end of expression in the interpolated string. Defaults to `}}`.\n   *\n   * @param {string=} value new value to set the ending symbol to.\n   * @returns {string|self} Returns the symbol when used as getter and self if used as setter.\n   */\n  this.endSymbol = function(value){\n    if (value) {\n      endSymbol = value;\n      return this;\n    } else {\n      return endSymbol;\n    }\n  };\n\n\n  this.$get = ['$parse', '$exceptionHandler', '$sce', function($parse, $exceptionHandler, $sce) {\n    var startSymbolLength = startSymbol.length,\n        endSymbolLength = endSymbol.length;\n\n    /**\n     * @ngdoc function\n     * @name ng.$interpolate\n     * @function\n     *\n     * @requires $parse\n     * @requires $sce\n     *\n     * @description\n     *\n     * Compiles a string with markup into an interpolation function. This service is used by the\n     * HTML {@link ng.$compile $compile} service for data binding. See\n     * {@link ng.$interpolateProvider $interpolateProvider} for configuring the\n     * interpolation markup.\n     *\n     *\n       <pre>\n         var $interpolate = ...; // injected\n         var exp = $interpolate('Hello {{name}}!');\n         expect(exp({name:'Angular'}).toEqual('Hello Angular!');\n       </pre>\n     *\n     *\n     * @param {string} text The text with markup to interpolate.\n     * @param {boolean=} mustHaveExpression if set to true then the interpolation string must have\n     *    embedded expression in order to return an interpolation function. Strings with no\n     *    embedded expression will return null for the interpolation function.\n     * @param {string=} trustedContext when provided, the returned function passes the interpolated\n     *    result through {@link ng.$sce#getTrusted $sce.getTrusted(interpolatedResult,\n     *    trustedContext)} before returning it.  Refer to the {@link ng.$sce $sce} service that\n     *    provides Strict Contextual Escaping for details.\n     * @returns {function(context)} an interpolation function which is used to compute the interpolated\n     *    string. The function has these parameters:\n     *\n     *    * `context`: an object against which any expressions embedded in the strings are evaluated\n     *      against.\n     *\n     */\n    function $interpolate(text, mustHaveExpression, trustedContext) {\n      var startIndex,\n          endIndex,\n          index = 0,\n          parts = [],\n          length = text.length,\n          hasInterpolation = false,\n          fn,\n          exp,\n          concat = [];\n\n      while(index < length) {\n        if ( ((startIndex = text.indexOf(startSymbol, index)) != -1) &&\n             ((endIndex = text.indexOf(endSymbol, startIndex + startSymbolLength)) != -1) ) {\n          (index != startIndex) && parts.push(text.substring(index, startIndex));\n          parts.push(fn = $parse(exp = text.substring(startIndex + startSymbolLength, endIndex)));\n          fn.exp = exp;\n          index = endIndex + endSymbolLength;\n          hasInterpolation = true;\n        } else {\n          // we did not find anything, so we have to add the remainder to the parts array\n          (index != length) && parts.push(text.substring(index));\n          index = length;\n        }\n      }\n\n      if (!(length = parts.length)) {\n        // we added, nothing, must have been an empty string.\n        parts.push('');\n        length = 1;\n      }\n\n      // Concatenating expressions makes it hard to reason about whether some combination of concatenated\n      // values are unsafe to use and could easily lead to XSS.  By requiring that a single\n      // expression be used for iframe[src], object[src], etc., we ensure that the value that's used\n      // is assigned or constructed by some JS code somewhere that is more testable or make it\n      // obvious that you bound the value to some user controlled value.  This helps reduce the load\n      // when auditing for XSS issues.\n      if (trustedContext && parts.length > 1) {\n          throw $interpolateMinErr('noconcat',\n              \"Error while interpolating: {0}\\nStrict Contextual Escaping disallows \" +\n              \"interpolations that concatenate multiple expressions when a trusted value is \" +\n              \"required.  See http://docs.angularjs.org/api/ng.$sce\", text);\n      }\n\n      if (!mustHaveExpression  || hasInterpolation) {\n        concat.length = length;\n        fn = function(context) {\n          try {\n            for(var i = 0, ii = length, part; i<ii; i++) {\n              if (typeof (part = parts[i]) == 'function') {\n                part = part(context);\n                if (trustedContext) {\n                  part = $sce.getTrusted(trustedContext, part);\n                } else {\n                  part = $sce.valueOf(part);\n                }\n                if (part == null || part == undefined) {\n                  part = '';\n                } else if (typeof part != 'string') {\n                  part = toJson(part);\n                }\n              }\n              concat[i] = part;\n            }\n            return concat.join('');\n          }\n          catch(err) {\n            var newErr = $interpolateMinErr('interr', \"Can't interpolate: {0}\\n{1}\", text, err.toString());\n            $exceptionHandler(newErr);\n          }\n        };\n        fn.exp = text;\n        fn.parts = parts;\n        return fn;\n      }\n    }\n\n\n    /**\n     * @ngdoc method\n     * @name ng.$interpolate#startSymbol\n     * @methodOf ng.$interpolate\n     * @description\n     * Symbol to denote the start of expression in the interpolated string. Defaults to `{{`.\n     *\n     * Use {@link ng.$interpolateProvider#startSymbol $interpolateProvider#startSymbol} to change\n     * the symbol.\n     *\n     * @returns {string} start symbol.\n     */\n    $interpolate.startSymbol = function() {\n      return startSymbol;\n    }\n\n\n    /**\n     * @ngdoc method\n     * @name ng.$interpolate#endSymbol\n     * @methodOf ng.$interpolate\n     * @description\n     * Symbol to denote the end of expression in the interpolated string. Defaults to `}}`.\n     *\n     * Use {@link ng.$interpolateProvider#endSymbol $interpolateProvider#endSymbol} to change\n     * the symbol.\n     *\n     * @returns {string} start symbol.\n     */\n    $interpolate.endSymbol = function() {\n      return endSymbol;\n    }\n\n    return $interpolate;\n  }];\n}\n\n/**\n * @ngdoc object\n * @name ng.$locale\n *\n * @description\n * $locale service provides localization rules for various Angular components. As of right now the\n * only public api is:\n *\n * * `id` – `{string}` – locale id formatted as `languageId-countryId` (e.g. `en-us`)\n */\nfunction $LocaleProvider(){\n  this.$get = function() {\n    return {\n      id: 'en-us',\n\n      NUMBER_FORMATS: {\n        DECIMAL_SEP: '.',\n        GROUP_SEP: ',',\n        PATTERNS: [\n          { // Decimal Pattern\n            minInt: 1,\n            minFrac: 0,\n            maxFrac: 3,\n            posPre: '',\n            posSuf: '',\n            negPre: '-',\n            negSuf: '',\n            gSize: 3,\n            lgSize: 3\n          },{ //Currency Pattern\n            minInt: 1,\n            minFrac: 2,\n            maxFrac: 2,\n            posPre: '\\u00A4',\n            posSuf: '',\n            negPre: '(\\u00A4',\n            negSuf: ')',\n            gSize: 3,\n            lgSize: 3\n          }\n        ],\n        CURRENCY_SYM: '$'\n      },\n\n      DATETIME_FORMATS: {\n        MONTH: 'January,February,March,April,May,June,July,August,September,October,November,December'\n                .split(','),\n        SHORTMONTH:  'Jan,Feb,Mar,Apr,May,Jun,Jul,Aug,Sep,Oct,Nov,Dec'.split(','),\n        DAY: 'Sunday,Monday,Tuesday,Wednesday,Thursday,Friday,Saturday'.split(','),\n        SHORTDAY: 'Sun,Mon,Tue,Wed,Thu,Fri,Sat'.split(','),\n        AMPMS: ['AM','PM'],\n        medium: 'MMM d, y h:mm:ss a',\n        short: 'M/d/yy h:mm a',\n        fullDate: 'EEEE, MMMM d, y',\n        longDate: 'MMMM d, y',\n        mediumDate: 'MMM d, y',\n        shortDate: 'M/d/yy',\n        mediumTime: 'h:mm:ss a',\n        shortTime: 'h:mm a'\n      },\n\n      pluralCat: function(num) {\n        if (num === 1) {\n          return 'one';\n        }\n        return 'other';\n      }\n    };\n  };\n}\n\nvar SERVER_MATCH = /^([^:]+):\\/\\/(\\w+:{0,1}\\w*@)?(\\{?[\\w\\.-]*\\}?)(:([0-9]+))?(\\/[^\\?#]*)?(\\?([^#]*))?(#(.*))?$/,\n    PATH_MATCH = /^([^\\?#]*)(\\?([^#]*))?(#(.*))?$/,\n    DEFAULT_PORTS = {'http': 80, 'https': 443, 'ftp': 21};\nvar $locationMinErr = minErr('$location');\n\n\n/**\n * Encode path using encodeUriSegment, ignoring forward slashes\n *\n * @param {string} path Path to encode\n * @returns {string}\n */\nfunction encodePath(path) {\n  var segments = path.split('/'),\n      i = segments.length;\n\n  while (i--) {\n    segments[i] = encodeUriSegment(segments[i]);\n  }\n\n  return segments.join('/');\n}\n\nfunction matchUrl(url, obj) {\n  var match = SERVER_MATCH.exec(url);\n\n  obj.$$protocol = match[1];\n  obj.$$host = match[3];\n  obj.$$port = int(match[5]) || DEFAULT_PORTS[match[1]] || null;\n}\n\nfunction matchAppUrl(url, obj) {\n  var match = PATH_MATCH.exec(url);\n\n  obj.$$path = decodeURIComponent(match[1]);\n  obj.$$search = parseKeyValue(match[3]);\n  obj.$$hash = decodeURIComponent(match[5] || '');\n\n  // make sure path starts with '/';\n  if (obj.$$path && obj.$$path.charAt(0) != '/') obj.$$path = '/' + obj.$$path;\n}\n\n\nfunction composeProtocolHostPort(protocol, host, port) {\n  return protocol + '://' + host + (port == DEFAULT_PORTS[protocol] ? '' : ':' + port);\n}\n\n/**\n *\n * @param {string} begin\n * @param {string} whole\n * @param {string} otherwise\n * @returns {string} returns text from whole after begin or otherwise if it does not begin with expected string.\n */\nfunction beginsWith(begin, whole, otherwise) {\n  return whole.indexOf(begin) == 0 ? whole.substr(begin.length) : otherwise;\n}\n\n\nfunction stripHash(url) {\n  var index = url.indexOf('#');\n  return index == -1 ? url : url.substr(0, index);\n}\n\n\nfunction stripFile(url) {\n  return url.substr(0, stripHash(url).lastIndexOf('/') + 1);\n}\n\n/* return the server only (scheme://host:port) */\nfunction serverBase(url) {\n  return url.substring(0, url.indexOf('/', url.indexOf('//') + 2));\n}\n\n\n/**\n * LocationHtml5Url represents an url\n * This object is exposed as $location service when HTML5 mode is enabled and supported\n *\n * @constructor\n * @param {string} appBase application base URL\n * @param {string} basePrefix url path prefix\n */\nfunction LocationHtml5Url(appBase, basePrefix) {\n  this.$$html5 = true;\n  basePrefix = basePrefix || '';\n  var appBaseNoFile = stripFile(appBase);\n  /**\n   * Parse given html5 (regular) url string into properties\n   * @param {string} newAbsoluteUrl HTML5 url\n   * @private\n   */\n  this.$$parse = function(url) {\n    var parsed = {}\n    matchUrl(url, parsed);\n    var pathUrl = beginsWith(appBaseNoFile, url);\n    if (!isString(pathUrl)) {\n      throw $locationMinErr('ipthprfx', 'Invalid url \"{0}\", missing path prefix \"{1}\".', url, appBaseNoFile);\n    }\n    matchAppUrl(pathUrl, parsed);\n    extend(this, parsed);\n    if (!this.$$path) {\n      this.$$path = '/';\n    }\n\n    this.$$compose();\n  };\n\n  /**\n   * Compose url and update `absUrl` property\n   * @private\n   */\n  this.$$compose = function() {\n    var search = toKeyValue(this.$$search),\n        hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';\n\n    this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;\n    this.$$absUrl = appBaseNoFile + this.$$url.substr(1); // first char is always '/'\n  };\n\n  this.$$rewrite = function(url) {\n    var appUrl, prevAppUrl;\n\n    if ( (appUrl = beginsWith(appBase, url)) !== undefined ) {\n      prevAppUrl = appUrl;\n      if ( (appUrl = beginsWith(basePrefix, appUrl)) !== undefined ) {\n        return appBaseNoFile + (beginsWith('/', appUrl) || appUrl);\n      } else {\n        return appBase + prevAppUrl;\n      }\n    } else if ( (appUrl = beginsWith(appBaseNoFile, url)) !== undefined ) {\n      return appBaseNoFile + appUrl;\n    } else if (appBaseNoFile == url + '/') {\n      return appBaseNoFile;\n    }\n  }\n}\n\n\n/**\n * LocationHashbangUrl represents url\n * This object is exposed as $location service when developer doesn't opt into html5 mode.\n * It also serves as the base class for html5 mode fallback on legacy browsers.\n *\n * @constructor\n * @param {string} appBase application base URL\n * @param {string} hashPrefix hashbang prefix\n */\nfunction LocationHashbangUrl(appBase, hashPrefix) {\n  var appBaseNoFile = stripFile(appBase);\n\n  matchUrl(appBase, this);\n\n\n  /**\n   * Parse given hashbang url into properties\n   * @param {string} url Hashbang url\n   * @private\n   */\n  this.$$parse = function(url) {\n    var withoutBaseUrl = beginsWith(appBase, url) || beginsWith(appBaseNoFile, url);\n    var withoutHashUrl = withoutBaseUrl.charAt(0) == '#'\n        ? beginsWith(hashPrefix, withoutBaseUrl)\n        : (this.$$html5)\n          ? withoutBaseUrl\n          : '';\n\n    if (!isString(withoutHashUrl)) {\n      throw $locationMinErr('ihshprfx', 'Invalid url \"{0}\", missing hash prefix \"{1}\".', url, hashPrefix);\n    }\n    matchAppUrl(withoutHashUrl, this);\n    this.$$compose();\n  };\n\n  /**\n   * Compose hashbang url and update `absUrl` property\n   * @private\n   */\n  this.$$compose = function() {\n    var search = toKeyValue(this.$$search),\n        hash = this.$$hash ? '#' + encodeUriSegment(this.$$hash) : '';\n\n    this.$$url = encodePath(this.$$path) + (search ? '?' + search : '') + hash;\n    this.$$absUrl = appBase + (this.$$url ? hashPrefix + this.$$url : '');\n  };\n\n  this.$$rewrite = function(url) {\n    if(stripHash(appBase) == stripHash(url)) {\n      return url;\n    }\n  }\n}\n\n\n/**\n * LocationHashbangUrl represents url\n * This object is exposed as $location service when html5 history api is enabled but the browser\n * does not support it.\n *\n * @constructor\n * @param {string} appBase application base URL\n * @param {string} hashPrefix hashbang prefix\n */\nfunction LocationHashbangInHtml5Url(appBase, hashPrefix) {\n  this.$$html5 = true;\n  LocationHashbangUrl.apply(this, arguments);\n\n  var appBaseNoFile = stripFile(appBase);\n\n  this.$$rewrite = function(url) {\n    var appUrl;\n\n    if ( appBase == stripHash(url) ) {\n      return url;\n    } else if ( (appUrl = beginsWith(appBaseNoFile, url)) ) {\n      return appBase + hashPrefix + appUrl;\n    } else if ( appBaseNoFile === url + '/') {\n      return appBaseNoFile;\n    }\n  }\n}\n\n\nLocationHashbangInHtml5Url.prototype =\n  LocationHashbangUrl.prototype =\n  LocationHtml5Url.prototype = {\n\n  /**\n   * Are we in html5 mode?\n   * @private\n   */\n  $$html5: false,\n\n  /**\n   * Has any change been replacing ?\n   * @private\n   */\n  $$replace: false,\n\n  /**\n   * @ngdoc method\n   * @name ng.$location#absUrl\n   * @methodOf ng.$location\n   *\n   * @description\n   * This method is getter only.\n   *\n   * Return full url representation with all segments encoded according to rules specified in\n   * {@link http://www.ietf.org/rfc/rfc3986.txt RFC 3986}.\n   *\n   * @return {string} full url\n   */\n  absUrl: locationGetter('$$absUrl'),\n\n  /**\n   * @ngdoc method\n   * @name ng.$location#url\n   * @methodOf ng.$location\n   *\n   * @description\n   * This method is getter / setter.\n   *\n   * Return url (e.g. `/path?a=b#hash`) when called without any parameter.\n   *\n   * Change path, search and hash, when called with parameter and return `$location`.\n   *\n   * @param {string=} url New url without base prefix (e.g. `/path?a=b#hash`)\n   * @param {string=} replace The path that will be changed\n   * @return {string} url\n   */\n  url: function(url, replace) {\n    if (isUndefined(url))\n      return this.$$url;\n\n    var match = PATH_MATCH.exec(url);\n    if (match[1]) this.path(decodeURIComponent(match[1]));\n    if (match[2] || match[1]) this.search(match[3] || '');\n    this.hash(match[5] || '', replace);\n\n    return this;\n  },\n\n  /**\n   * @ngdoc method\n   * @name ng.$location#protocol\n   * @methodOf ng.$location\n   *\n   * @description\n   * This method is getter only.\n   *\n   * Return protocol of current url.\n   *\n   * @return {string} protocol of current url\n   */\n  protocol: locationGetter('$$protocol'),\n\n  /**\n   * @ngdoc method\n   * @name ng.$location#host\n   * @methodOf ng.$location\n   *\n   * @description\n   * This method is getter only.\n   *\n   * Return host of current url.\n   *\n   * @return {string} host of current url.\n   */\n  host: locationGetter('$$host'),\n\n  /**\n   * @ngdoc method\n   * @name ng.$location#port\n   * @methodOf ng.$location\n   *\n   * @description\n   * This method is getter only.\n   *\n   * Return port of current url.\n   *\n   * @return {Number} port\n   */\n  port: locationGetter('$$port'),\n\n  /**\n   * @ngdoc method\n   * @name ng.$location#path\n   * @methodOf ng.$location\n   *\n   * @description\n   * This method is getter / setter.\n   *\n   * Return path of current url when called without any parameter.\n   *\n   * Change path when called with parameter and return `$location`.\n   *\n   * Note: Path should always begin with forward slash (/), this method will add the forward slash\n   * if it is missing.\n   *\n   * @param {string=} path New path\n   * @return {string} path\n   */\n  path: locationGetterSetter('$$path', function(path) {\n    return path.charAt(0) == '/' ? path : '/' + path;\n  }),\n\n  /**\n   * @ngdoc method\n   * @name ng.$location#search\n   * @methodOf ng.$location\n   *\n   * @description\n   * This method is getter / setter.\n   *\n   * Return search part (as object) of current url when called without any parameter.\n   *\n   * Change search part when called with parameter and return `$location`.\n   *\n   * @param {string|Object.<string>|Object.<Array.<string>>} search New search params - string or hash object. Hash object\n   *    may contain an array of values, which will be decoded as duplicates in the url.\n   * @param {string=} paramValue If `search` is a string, then `paramValue` will override only a\n   *    single search parameter. If the value is `null`, the parameter will be deleted.\n   *\n   * @return {string} search\n   */\n  search: function(search, paramValue) {\n    switch (arguments.length) {\n      case 0:\n        return this.$$search;\n      case 1:\n        if (isString(search)) {\n          this.$$search = parseKeyValue(search);\n        } else if (isObject(search)) {\n          this.$$search = search;\n        } else {\n          throw $locationMinErr('isrcharg', 'The first argument of the `$location#search()` call must be a string or an object.');\n        }\n        break;\n      default:\n        if (paramValue == undefined || paramValue == null) {\n          delete this.$$search[search];\n        } else {\n          this.$$search[search] = paramValue;\n        }\n    }\n\n    this.$$compose();\n    return this;\n  },\n\n  /**\n   * @ngdoc method\n   * @name ng.$location#hash\n   * @methodOf ng.$location\n   *\n   * @description\n   * This method is getter / setter.\n   *\n   * Return hash fragment when called without any parameter.\n   *\n   * Change hash fragment when called with parameter and return `$location`.\n   *\n   * @param {string=} hash New hash fragment\n   * @return {string} hash\n   */\n  hash: locationGetterSetter('$$hash', identity),\n\n  /**\n   * @ngdoc method\n   * @name ng.$location#replace\n   * @methodOf ng.$location\n   *\n   * @description\n   * If called, all changes to $location during current `$digest` will be replacing current history\n   * record, instead of adding new one.\n   */\n  replace: function() {\n    this.$$replace = true;\n    return this;\n  }\n};\n\nfunction locationGetter(property) {\n  return function() {\n    return this[property];\n  };\n}\n\n\nfunction locationGetterSetter(property, preprocess) {\n  return function(value) {\n    if (isUndefined(value))\n      return this[property];\n\n    this[property] = preprocess(value);\n    this.$$compose();\n\n    return this;\n  };\n}\n\n\n/**\n * @ngdoc object\n * @name ng.$location\n *\n * @requires $browser\n * @requires $sniffer\n * @requires $rootElement\n *\n * @description\n * The $location service parses the URL in the browser address bar (based on the\n * {@link https://developer.mozilla.org/en/window.location window.location}) and makes the URL\n * available to your application. Changes to the URL in the address bar are reflected into\n * $location service and changes to $location are reflected into the browser address bar.\n *\n * **The $location service:**\n *\n * - Exposes the current URL in the browser address bar, so you can\n *   - Watch and observe the URL.\n *   - Change the URL.\n * - Synchronizes the URL with the browser when the user\n *   - Changes the address bar.\n *   - Clicks the back or forward button (or clicks a History link).\n *   - Clicks on a link.\n * - Represents the URL object as a set of methods (protocol, host, port, path, search, hash).\n *\n * For more information see {@link guide/dev_guide.services.$location Developer Guide: Angular\n * Services: Using $location}\n */\n\n/**\n * @ngdoc object\n * @name ng.$locationProvider\n * @description\n * Use the `$locationProvider` to configure how the application deep linking paths are stored.\n */\nfunction $LocationProvider(){\n  var hashPrefix = '',\n      html5Mode = false;\n\n  /**\n   * @ngdoc property\n   * @name ng.$locationProvider#hashPrefix\n   * @methodOf ng.$locationProvider\n   * @description\n   * @param {string=} prefix Prefix for hash part (containing path and search)\n   * @returns {*} current value if used as getter or itself (chaining) if used as setter\n   */\n  this.hashPrefix = function(prefix) {\n    if (isDefined(prefix)) {\n      hashPrefix = prefix;\n      return this;\n    } else {\n      return hashPrefix;\n    }\n  };\n\n  /**\n   * @ngdoc property\n   * @name ng.$locationProvider#html5Mode\n   * @methodOf ng.$locationProvider\n   * @description\n   * @param {string=} mode Use HTML5 strategy if available.\n   * @returns {*} current value if used as getter or itself (chaining) if used as setter\n   */\n  this.html5Mode = function(mode) {\n    if (isDefined(mode)) {\n      html5Mode = mode;\n      return this;\n    } else {\n      return html5Mode;\n    }\n  };\n\n  this.$get = ['$rootScope', '$browser', '$sniffer', '$rootElement',\n      function( $rootScope,   $browser,   $sniffer,   $rootElement) {\n    var $location,\n        LocationMode,\n        baseHref = $browser.baseHref(), // if base[href] is undefined, it defaults to ''\n        initialUrl = $browser.url(),\n        appBase;\n\n    if (html5Mode) {\n      appBase = serverBase(initialUrl) + (baseHref || '/');\n      LocationMode = $sniffer.history ? LocationHtml5Url : LocationHashbangInHtml5Url;\n    } else {\n      appBase = stripHash(initialUrl);\n      LocationMode = LocationHashbangUrl;\n    }\n    $location = new LocationMode(appBase, '#' + hashPrefix);\n    $location.$$parse($location.$$rewrite(initialUrl));\n\n    $rootElement.on('click', function(event) {\n      // TODO(vojta): rewrite link when opening in new tab/window (in legacy browser)\n      // currently we open nice url link and redirect then\n\n      if (event.ctrlKey || event.metaKey || event.which == 2) return;\n\n      var elm = jqLite(event.target);\n\n      // traverse the DOM up to find first A tag\n      while (lowercase(elm[0].nodeName) !== 'a') {\n        // ignore rewriting if no A tag (reached root element, or no parent - removed from document)\n        if (elm[0] === $rootElement[0] || !(elm = elm.parent())[0]) return;\n      }\n\n      var absHref = elm.prop('href');\n      var rewrittenUrl = $location.$$rewrite(absHref);\n\n      if (absHref && !elm.attr('target') && rewrittenUrl && !event.isDefaultPrevented()) {\n        event.preventDefault();\n        if (rewrittenUrl != $browser.url()) {\n          // update location manually\n          $location.$$parse(rewrittenUrl);\n          $rootScope.$apply();\n          // hack to work around FF6 bug 684208 when scenario runner clicks on links\n          window.angular['ff-684208-preventDefault'] = true;\n        }\n      }\n    });\n\n\n    // rewrite hashbang url <> html5 url\n    if ($location.absUrl() != initialUrl) {\n      $browser.url($location.absUrl(), true);\n    }\n\n    // update $location when $browser url changes\n    $browser.onUrlChange(function(newUrl) {\n      if ($location.absUrl() != newUrl) {\n        if ($rootScope.$broadcast('$locationChangeStart', newUrl, $location.absUrl()).defaultPrevented) {\n          $browser.url($location.absUrl());\n          return;\n        }\n        $rootScope.$evalAsync(function() {\n          var oldUrl = $location.absUrl();\n\n          $location.$$parse(newUrl);\n          afterLocationChange(oldUrl);\n        });\n        if (!$rootScope.$$phase) $rootScope.$digest();\n      }\n    });\n\n    // update browser\n    var changeCounter = 0;\n    $rootScope.$watch(function $locationWatch() {\n      var oldUrl = $browser.url();\n      var currentReplace = $location.$$replace;\n\n      if (!changeCounter || oldUrl != $location.absUrl()) {\n        changeCounter++;\n        $rootScope.$evalAsync(function() {\n          if ($rootScope.$broadcast('$locationChangeStart', $location.absUrl(), oldUrl).\n              defaultPrevented) {\n            $location.$$parse(oldUrl);\n          } else {\n            $browser.url($location.absUrl(), currentReplace);\n            afterLocationChange(oldUrl);\n          }\n        });\n      }\n      $location.$$replace = false;\n\n      return changeCounter;\n    });\n\n    return $location;\n\n    function afterLocationChange(oldUrl) {\n      $rootScope.$broadcast('$locationChangeSuccess', $location.absUrl(), oldUrl);\n    }\n}];\n}\n\n/**\n * @ngdoc object\n * @name ng.$log\n * @requires $window\n *\n * @description\n * Simple service for logging. Default implementation writes the message\n * into the browser's console (if present).\n *\n * The main purpose of this service is to simplify debugging and troubleshooting.\n *\n * @example\n   <example>\n     <file name=\"script.js\">\n       function LogCtrl($scope, $log) {\n         $scope.$log = $log;\n         $scope.message = 'Hello World!';\n       }\n     </file>\n     <file name=\"index.html\">\n       <div ng-controller=\"LogCtrl\">\n         <p>Reload this page with open console, enter text and hit the log button...</p>\n         Message:\n         <input type=\"text\" ng-model=\"message\"/>\n         <button ng-click=\"$log.log(message)\">log</button>\n         <button ng-click=\"$log.warn(message)\">warn</button>\n         <button ng-click=\"$log.info(message)\">info</button>\n         <button ng-click=\"$log.error(message)\">error</button>\n       </div>\n     </file>\n   </example>\n */\n\n/**\n * @ngdoc object\n * @name ng.$logProvider\n * @description\n * Use the `$logProvider` to configure how the application logs messages\n */\nfunction $LogProvider(){\n  var debug = true,\n      self = this;\n  \n  /**\n   * @ngdoc property\n   * @name ng.$logProvider#debugEnabled\n   * @methodOf ng.$logProvider\n   * @description\n   * @param {string=} flag enable or disable debug level messages\n   * @returns {*} current value if used as getter or itself (chaining) if used as setter\n   */\n  this.debugEnabled = function(flag) {\n\t  if (isDefined(flag)) {\n\t\t  debug = flag;\n\t\t  return this;\n\t  } else {\n\t\t  return debug;\n\t  }\n  };\n  \n  this.$get = ['$window', function($window){\n    return {\n      /**\n       * @ngdoc method\n       * @name ng.$log#log\n       * @methodOf ng.$log\n       *\n       * @description\n       * Write a log message\n       */\n      log: consoleLog('log'),\n\n      /**\n       * @ngdoc method\n       * @name ng.$log#info\n       * @methodOf ng.$log\n       *\n       * @description\n       * Write an information message\n       */\n      info: consoleLog('info'),\n\n      /**\n       * @ngdoc method\n       * @name ng.$log#warn\n       * @methodOf ng.$log\n       *\n       * @description\n       * Write a warning message\n       */\n      warn: consoleLog('warn'),\n\n      /**\n       * @ngdoc method\n       * @name ng.$log#error\n       * @methodOf ng.$log\n       *\n       * @description\n       * Write an error message\n       */\n      error: consoleLog('error'),\n      \n      /**\n       * @ngdoc method\n       * @name ng.$log#debug\n       * @methodOf ng.$log\n       * \n       * @description\n       * Write a debug message\n       */\n      debug: (function () {\n    \tvar fn = consoleLog('debug');\n    \t\n    \treturn function() {\n    \t\tif (debug) {\n    \t\t\tfn.apply(self, arguments);\n    \t\t}\n    \t}\n      }())\n    };\n\n    function formatError(arg) {\n      if (arg instanceof Error) {\n        if (arg.stack) {\n          arg = (arg.message && arg.stack.indexOf(arg.message) === -1)\n              ? 'Error: ' + arg.message + '\\n' + arg.stack\n              : arg.stack;\n        } else if (arg.sourceURL) {\n          arg = arg.message + '\\n' + arg.sourceURL + ':' + arg.line;\n        }\n      }\n      return arg;\n    }\n\n    function consoleLog(type) {\n      var console = $window.console || {},\n          logFn = console[type] || console.log || noop;\n\n      if (logFn.apply) {\n        return function() {\n          var args = [];\n          forEach(arguments, function(arg) {\n            args.push(formatError(arg));\n          });\n          return logFn.apply(console, args);\n        };\n      }\n\n      // we are IE which either doesn't have window.console => this is noop and we do nothing,\n      // or we are IE where console.log doesn't have apply so we log at least first 2 args\n      return function(arg1, arg2) {\n        logFn(arg1, arg2);\n      }\n    }\n  }];\n}\n\nvar $parseMinErr = minErr('$parse');\n\n// Sandboxing Angular Expressions\n// ------------------------------\n// Angular expressions are generally considered safe because these expressions only have direct access to $scope and\n// locals. However, one can obtain the ability to execute arbitrary JS code by obtaining a reference to native JS\n// functions such as the Function constructor.\n//\n// As an example, consider the following Angular expression:\n//\n//   {}.toString.constructor(alert(\"evil JS code\"))\n//\n// We want to prevent this type of access. For the sake of performance, during the lexing phase we disallow any \"dotted\"\n// access to any member named \"constructor\".\n//\n// For reflective calls (a[b]) we check that the value of the lookup is not the Function constructor while evaluating\n// the expression, which is a stronger but more expensive test. Since reflective calls are expensive anyway, this is not\n// such a big deal compared to static dereferencing.\n//\n// This sandboxing technique is not perfect and doesn't aim to be. The goal is to prevent exploits against the\n// expression language, but not to prevent exploits that were enabled by exposing sensitive JavaScript or browser apis\n// on Scope. Exposing such objects on a Scope is never a good practice and therefore we are not even trying to protect\n// against interaction with an object explicitly exposed in this way.\n//\n// A developer could foil the name check by aliasing the Function constructor under a different name on the scope.\n//\n// In general, it is not possible to access a Window object from an angular expression unless a window or some DOM\n// object that has a reference to window is published onto a Scope.\n\nfunction ensureSafeMemberName(name, fullExpression) {\n  if (name === \"constructor\") {\n    throw $parseMinErr('isecfld',\n        'Referencing \"constructor\" field in Angular expressions is disallowed! Expression: {0}', fullExpression);\n  }\n  return name;\n};\n\nfunction ensureSafeObject(obj, fullExpression) {\n  // nifty check if obj is Function that is fast and works across iframes and other contexts\n  if (obj && obj.constructor === obj) {\n    throw $parseMinErr('isecfn',\n        'Referencing Function in Angular expressions is disallowed! Expression: {0}', fullExpression);\n  } else {\n    return obj;\n  }\n}\n\n\nvar OPERATORS = {\n    'null':function(){return null;},\n    'true':function(){return true;},\n    'false':function(){return false;},\n    undefined:noop,\n    '+':function(self, locals, a,b){\n      a=a(self, locals); b=b(self, locals);\n      if (isDefined(a)) {\n        if (isDefined(b)) {\n          return a + b;\n        }\n        return a;\n      }\n      return isDefined(b)?b:undefined;},\n    '-':function(self, locals, a,b){a=a(self, locals); b=b(self, locals); return (isDefined(a)?a:0)-(isDefined(b)?b:0);},\n    '*':function(self, locals, a,b){return a(self, locals)*b(self, locals);},\n    '/':function(self, locals, a,b){return a(self, locals)/b(self, locals);},\n    '%':function(self, locals, a,b){return a(self, locals)%b(self, locals);},\n    '^':function(self, locals, a,b){return a(self, locals)^b(self, locals);},\n    '=':noop,\n    '===':function(self, locals, a, b){return a(self, locals)===b(self, locals);},\n    '!==':function(self, locals, a, b){return a(self, locals)!==b(self, locals);},\n    '==':function(self, locals, a,b){return a(self, locals)==b(self, locals);},\n    '!=':function(self, locals, a,b){return a(self, locals)!=b(self, locals);},\n    '<':function(self, locals, a,b){return a(self, locals)<b(self, locals);},\n    '>':function(self, locals, a,b){return a(self, locals)>b(self, locals);},\n    '<=':function(self, locals, a,b){return a(self, locals)<=b(self, locals);},\n    '>=':function(self, locals, a,b){return a(self, locals)>=b(self, locals);},\n    '&&':function(self, locals, a,b){return a(self, locals)&&b(self, locals);},\n    '||':function(self, locals, a,b){return a(self, locals)||b(self, locals);},\n    '&':function(self, locals, a,b){return a(self, locals)&b(self, locals);},\n//    '|':function(self, locals, a,b){return a|b;},\n    '|':function(self, locals, a,b){return b(self, locals)(self, locals, a(self, locals));},\n    '!':function(self, locals, a){return !a(self, locals);}\n};\nvar ESCAPE = {\"n\":\"\\n\", \"f\":\"\\f\", \"r\":\"\\r\", \"t\":\"\\t\", \"v\":\"\\v\", \"'\":\"'\", '\"':'\"'};\n\nfunction lex(text, csp){\n  var tokens = [],\n      token,\n      index = 0,\n      json = [],\n      ch,\n      lastCh = ':'; // can start regexp\n\n  while (index < text.length) {\n    ch = text.charAt(index);\n    if (is('\"\\'')) {\n      readString(ch);\n    } else if (isNumber(ch) || is('.') && isNumber(peek())) {\n      readNumber();\n    } else if (isIdent(ch)) {\n      readIdent();\n      // identifiers can only be if the preceding char was a { or ,\n      if (was('{,') && json[0]=='{' &&\n         (token=tokens[tokens.length-1])) {\n        token.json = token.text.indexOf('.') == -1;\n      }\n    } else if (is('(){}[].,;:?')) {\n      tokens.push({\n        index:index,\n        text:ch,\n        json:(was(':[,') && is('{[')) || is('}]:,')\n      });\n      if (is('{[')) json.unshift(ch);\n      if (is('}]')) json.shift();\n      index++;\n    } else if (isWhitespace(ch)) {\n      index++;\n      continue;\n    } else {\n      var ch2 = ch + peek(),\n          ch3 = ch2 + peek(2),\n          fn = OPERATORS[ch],\n          fn2 = OPERATORS[ch2],\n          fn3 = OPERATORS[ch3];\n      if (fn3) {\n        tokens.push({index:index, text:ch3, fn:fn3});\n        index += 3;\n      } else if (fn2) {\n        tokens.push({index:index, text:ch2, fn:fn2});\n        index += 2;\n      } else if (fn) {\n        tokens.push({index:index, text:ch, fn:fn, json: was('[,:') && is('+-')});\n        index += 1;\n      } else {\n        throwError(\"Unexpected next character \", index, index+1);\n      }\n    }\n    lastCh = ch;\n  }\n  return tokens;\n\n  function is(chars) {\n    return chars.indexOf(ch) != -1;\n  }\n\n  function was(chars) {\n    return chars.indexOf(lastCh) != -1;\n  }\n\n  function peek(i) {\n    var num = i || 1;\n    return index + num < text.length ? text.charAt(index + num) : false;\n  }\n  function isNumber(ch) {\n    return '0' <= ch && ch <= '9';\n  }\n  function isWhitespace(ch) {\n    return ch == ' ' || ch == '\\r' || ch == '\\t' ||\n           ch == '\\n' || ch == '\\v' || ch == '\\u00A0'; // IE treats non-breaking space as \\u00A0\n  }\n  function isIdent(ch) {\n    return 'a' <= ch && ch <= 'z' ||\n           'A' <= ch && ch <= 'Z' ||\n           '_' == ch || ch == '$';\n  }\n  function isExpOperator(ch) {\n    return ch == '-' || ch == '+' || isNumber(ch);\n  }\n\n  function throwError(error, start, end) {\n    end = end || index;\n    var colStr = (isDefined(start) ?\n        \"s \" + start +  \"-\" + index + \" [\" + text.substring(start, end) + \"]\"\n        : \" \" + end);\n    throw $parseMinErr('lexerr', \"Lexer Error: {0} at column{1} in expression [{2}].\",\n        error, colStr, text);\n  }\n\n  function readNumber() {\n    var number = \"\";\n    var start = index;\n    while (index < text.length) {\n      var ch = lowercase(text.charAt(index));\n      if (ch == '.' || isNumber(ch)) {\n        number += ch;\n      } else {\n        var peekCh = peek();\n        if (ch == 'e' && isExpOperator(peekCh)) {\n          number += ch;\n        } else if (isExpOperator(ch) &&\n            peekCh && isNumber(peekCh) &&\n            number.charAt(number.length - 1) == 'e') {\n          number += ch;\n        } else if (isExpOperator(ch) &&\n            (!peekCh || !isNumber(peekCh)) &&\n            number.charAt(number.length - 1) == 'e') {\n          throwError('Invalid exponent');\n        } else {\n          break;\n        }\n      }\n      index++;\n    }\n    number = 1 * number;\n    tokens.push({index:start, text:number, json:true,\n      fn:function() {return number;}});\n  }\n  function readIdent() {\n    var ident = \"\",\n        start = index,\n        lastDot, peekIndex, methodName, ch;\n\n    while (index < text.length) {\n      ch = text.charAt(index);\n      if (ch == '.' || isIdent(ch) || isNumber(ch)) {\n        if (ch == '.') lastDot = index;\n        ident += ch;\n      } else {\n        break;\n      }\n      index++;\n    }\n\n    //check if this is not a method invocation and if it is back out to last dot\n    if (lastDot) {\n      peekIndex = index;\n      while(peekIndex < text.length) {\n        ch = text.charAt(peekIndex);\n        if (ch == '(') {\n          methodName = ident.substr(lastDot - start + 1);\n          ident = ident.substr(0, lastDot - start);\n          index = peekIndex;\n          break;\n        }\n        if(isWhitespace(ch)) {\n          peekIndex++;\n        } else {\n          break;\n        }\n      }\n    }\n\n\n    var token = {\n      index:start,\n      text:ident\n    };\n\n    if (OPERATORS.hasOwnProperty(ident)) {\n      token.fn = token.json = OPERATORS[ident];\n    } else {\n      var getter = getterFn(ident, csp, text);\n      token.fn = extend(function(self, locals) {\n        return (getter(self, locals));\n      }, {\n        assign: function(self, value) {\n          return setter(self, ident, value, text);\n        }\n      });\n    }\n\n    tokens.push(token);\n\n    if (methodName) {\n      tokens.push({\n        index:lastDot,\n        text: '.',\n        json: false\n      });\n      tokens.push({\n        index: lastDot + 1,\n        text: methodName,\n        json: false\n      });\n    }\n  }\n\n  function readString(quote) {\n    var start = index;\n    index++;\n    var string = \"\";\n    var rawString = quote;\n    var escape = false;\n    while (index < text.length) {\n      var ch = text.charAt(index);\n      rawString += ch;\n      if (escape) {\n        if (ch == 'u') {\n          var hex = text.substring(index + 1, index + 5);\n          if (!hex.match(/[\\da-f]{4}/i))\n            throwError( \"Invalid unicode escape [\\\\u\" + hex + \"]\");\n          index += 4;\n          string += String.fromCharCode(parseInt(hex, 16));\n        } else {\n          var rep = ESCAPE[ch];\n          if (rep) {\n            string += rep;\n          } else {\n            string += ch;\n          }\n        }\n        escape = false;\n      } else if (ch == '\\\\') {\n        escape = true;\n      } else if (ch == quote) {\n        index++;\n        tokens.push({\n          index:start,\n          text:rawString,\n          string:string,\n          json:true,\n          fn:function() { return string; }\n        });\n        return;\n      } else {\n        string += ch;\n      }\n      index++;\n    }\n    throwError(\"Unterminated quote\", start);\n  }\n}\n\n/////////////////////////////////////////\n\nfunction parser(text, json, $filter, csp){\n  var ZERO = valueFn(0),\n      value,\n      tokens = lex(text, csp),\n      assignment = _assignment,\n      functionCall = _functionCall,\n      fieldAccess = _fieldAccess,\n      objectIndex = _objectIndex,\n      filterChain = _filterChain;\n\n  if(json){\n    // The extra level of aliasing is here, just in case the lexer misses something, so that\n    // we prevent any accidental execution in JSON.\n    assignment = logicalOR;\n    functionCall =\n      fieldAccess =\n      objectIndex =\n      filterChain =\n        function() { throwError(\"is not valid json\", {text:text, index:0}); };\n    value = primary();\n  } else {\n    value = statements();\n  }\n  if (tokens.length !== 0) {\n    throwError(\"is an unexpected token\", tokens[0]);\n  }\n  value.literal = !!value.literal;\n  value.constant = !!value.constant;\n  return value;\n\n  ///////////////////////////////////\n  function throwError(msg, token) {\n    throw $parseMinErr('syntax',\n        \"Syntax Error: Token '{0}' {1} at column {2} of the expression [{3}] starting at [{4}].\",\n        token.text, msg, (token.index + 1), text, text.substring(token.index));\n  }\n\n  function peekToken() {\n    if (tokens.length === 0)\n      throw $parseMinErr('ueoe', \"Unexpected end of expression: {0}\", text);\n    return tokens[0];\n  }\n\n  function peek(e1, e2, e3, e4) {\n    if (tokens.length > 0) {\n      var token = tokens[0];\n      var t = token.text;\n      if (t==e1 || t==e2 || t==e3 || t==e4 ||\n          (!e1 && !e2 && !e3 && !e4)) {\n        return token;\n      }\n    }\n    return false;\n  }\n\n  function expect(e1, e2, e3, e4){\n    var token = peek(e1, e2, e3, e4);\n    if (token) {\n      if (json && !token.json) {\n        throwError(\"is not valid json\", token);\n      }\n      tokens.shift();\n      return token;\n    }\n    return false;\n  }\n\n  function consume(e1){\n    if (!expect(e1)) {\n      throwError(\"is unexpected, expecting [\" + e1 + \"]\", peek());\n    }\n  }\n\n  function unaryFn(fn, right) {\n    return extend(function(self, locals) {\n      return fn(self, locals, right);\n    }, {\n      constant:right.constant\n    });\n  }\n\n  function ternaryFn(left, middle, right){\n    return extend(function(self, locals){\n      return left(self, locals) ? middle(self, locals) : right(self, locals);\n    }, {\n      constant: left.constant && middle.constant && right.constant\n    });\n  }\n\n  function binaryFn(left, fn, right) {\n    return extend(function(self, locals) {\n      return fn(self, locals, left, right);\n    }, {\n      constant:left.constant && right.constant\n    });\n  }\n\n  function statements() {\n    var statements = [];\n    while(true) {\n      if (tokens.length > 0 && !peek('}', ')', ';', ']'))\n        statements.push(filterChain());\n      if (!expect(';')) {\n        // optimize for the common case where there is only one statement.\n        // TODO(size): maybe we should not support multiple statements?\n        return statements.length == 1\n          ? statements[0]\n          : function(self, locals){\n            var value;\n            for ( var i = 0; i < statements.length; i++) {\n              var statement = statements[i];\n              if (statement)\n                value = statement(self, locals);\n            }\n            return value;\n          };\n      }\n    }\n  }\n\n  function _filterChain() {\n    var left = expression();\n    var token;\n    while(true) {\n      if ((token = expect('|'))) {\n        left = binaryFn(left, token.fn, filter());\n      } else {\n        return left;\n      }\n    }\n  }\n\n  function filter() {\n    var token = expect();\n    var fn = $filter(token.text);\n    var argsFn = [];\n    while(true) {\n      if ((token = expect(':'))) {\n        argsFn.push(expression());\n      } else {\n        var fnInvoke = function(self, locals, input){\n          var args = [input];\n          for ( var i = 0; i < argsFn.length; i++) {\n            args.push(argsFn[i](self, locals));\n          }\n          return fn.apply(self, args);\n        };\n        return function() {\n          return fnInvoke;\n        };\n      }\n    }\n  }\n\n  function expression() {\n    return assignment();\n  }\n\n  function _assignment() {\n    var left = ternary();\n    var right;\n    var token;\n    if ((token = expect('='))) {\n      if (!left.assign) {\n        throwError(\"implies assignment but [\" +\n          text.substring(0, token.index) + \"] can not be assigned to\", token);\n      }\n      right = ternary();\n      return function(scope, locals){\n        return left.assign(scope, right(scope, locals), locals);\n      };\n    } else {\n      return left;\n    }\n  }\n\n  function ternary() {\n    var left = logicalOR();\n    var middle;\n    var token;\n    if((token = expect('?'))){\n      middle = ternary();\n      if((token = expect(':'))){\n        return ternaryFn(left, middle, ternary());\n      }\n      else {\n        throwError('expected :', token);\n      }\n    }\n    else {\n      return left;\n    }\n  }\n\n  function logicalOR() {\n    var left = logicalAND();\n    var token;\n    while(true) {\n      if ((token = expect('||'))) {\n        left = binaryFn(left, token.fn, logicalAND());\n      } else {\n        return left;\n      }\n    }\n  }\n\n  function logicalAND() {\n    var left = equality();\n    var token;\n    if ((token = expect('&&'))) {\n      left = binaryFn(left, token.fn, logicalAND());\n    }\n    return left;\n  }\n\n  function equality() {\n    var left = relational();\n    var token;\n    if ((token = expect('==','!=','===','!=='))) {\n      left = binaryFn(left, token.fn, equality());\n    }\n    return left;\n  }\n\n  function relational() {\n    var left = additive();\n    var token;\n    if ((token = expect('<', '>', '<=', '>='))) {\n      left = binaryFn(left, token.fn, relational());\n    }\n    return left;\n  }\n\n  function additive() {\n    var left = multiplicative();\n    var token;\n    while ((token = expect('+','-'))) {\n      left = binaryFn(left, token.fn, multiplicative());\n    }\n    return left;\n  }\n\n  function multiplicative() {\n    var left = unary();\n    var token;\n    while ((token = expect('*','/','%'))) {\n      left = binaryFn(left, token.fn, unary());\n    }\n    return left;\n  }\n\n  function unary() {\n    var token;\n    if (expect('+')) {\n      return primary();\n    } else if ((token = expect('-'))) {\n      return binaryFn(ZERO, token.fn, unary());\n    } else if ((token = expect('!'))) {\n      return unaryFn(token.fn, unary());\n    } else {\n      return primary();\n    }\n  }\n\n\n  function primary() {\n    var primary;\n    if (expect('(')) {\n      primary = filterChain();\n      consume(')');\n    } else if (expect('[')) {\n      primary = arrayDeclaration();\n    } else if (expect('{')) {\n      primary = object();\n    } else {\n      var token = expect();\n      primary = token.fn;\n      if (!primary) {\n        throwError(\"not a primary expression\", token);\n      }\n      if (token.json) {\n        primary.constant = primary.literal = true;\n      }\n    }\n\n    var next, context;\n    while ((next = expect('(', '[', '.'))) {\n      if (next.text === '(') {\n        primary = functionCall(primary, context);\n        context = null;\n      } else if (next.text === '[') {\n        context = primary;\n        primary = objectIndex(primary);\n      } else if (next.text === '.') {\n        context = primary;\n        primary = fieldAccess(primary);\n      } else {\n        throwError(\"IMPOSSIBLE\");\n      }\n    }\n    return primary;\n  }\n\n  function _fieldAccess(object) {\n    var field = expect().text;\n    var getter = getterFn(field, csp, text);\n    return extend(\n        function(scope, locals, self) {\n          return getter(self || object(scope, locals), locals);\n        },\n        {\n          assign:function(scope, value, locals) {\n            return setter(object(scope, locals), field, value, text);\n          }\n        }\n    );\n  }\n\n  function _objectIndex(obj) {\n    var indexFn = expression();\n    consume(']');\n    return extend(\n      function(self, locals){\n        var o = obj(self, locals),\n            i = indexFn(self, locals),\n            v, p;\n\n        if (!o) return undefined;\n        v = ensureSafeObject(o[i], text);\n        if (v && v.then) {\n          p = v;\n          if (!('$$v' in v)) {\n            p.$$v = undefined;\n            p.then(function(val) { p.$$v = val; });\n          }\n          v = v.$$v;\n        }\n        return v;\n      }, {\n        assign:function(self, value, locals){\n          var key = indexFn(self, locals);\n          // prevent overwriting of Function.constructor which would break ensureSafeObject check\n          return ensureSafeObject(obj(self, locals), text)[key] = value;\n        }\n      });\n  }\n\n  function _functionCall(fn, contextGetter) {\n    var argsFn = [];\n    if (peekToken().text != ')') {\n      do {\n        argsFn.push(expression());\n      } while (expect(','));\n    }\n    consume(')');\n    return function(scope, locals){\n      var args = [],\n          context = contextGetter ? contextGetter(scope, locals) : scope;\n\n      for ( var i = 0; i < argsFn.length; i++) {\n        args.push(argsFn[i](scope, locals));\n      }\n      var fnPtr = fn(scope, locals, context) || noop;\n      // IE stupidity!\n      var v = fnPtr.apply\n          ? fnPtr.apply(context, args)\n          : fnPtr(args[0], args[1], args[2], args[3], args[4]);\n\n      // Check for promise\n      if (v && v.then) {\n        var p = v;\n        if (!('$$v' in v)) {\n          p.$$v = undefined;\n          p.then(function(val) { p.$$v = val; });\n        }\n        v = v.$$v;\n      }\n\n      return v;\n    };\n  }\n\n  // This is used with json array declaration\n  function arrayDeclaration () {\n    var elementFns = [];\n    var allConstant = true;\n    if (peekToken().text != ']') {\n      do {\n        var elementFn = expression();\n        elementFns.push(elementFn);\n        if (!elementFn.constant) {\n          allConstant = false;\n        }\n      } while (expect(','));\n    }\n    consume(']');\n    return extend(function(self, locals){\n      var array = [];\n      for ( var i = 0; i < elementFns.length; i++) {\n        array.push(elementFns[i](self, locals));\n      }\n      return array;\n    }, {\n      literal:true,\n      constant:allConstant\n    });\n  }\n\n  function object () {\n    var keyValues = [];\n    var allConstant = true;\n    if (peekToken().text != '}') {\n      do {\n        var token = expect(),\n        key = token.string || token.text;\n        consume(\":\");\n        var value = expression();\n        keyValues.push({key:key, value:value});\n        if (!value.constant) {\n          allConstant = false;\n        }\n      } while (expect(','));\n    }\n    consume('}');\n    return extend(function(self, locals){\n      var object = {};\n      for ( var i = 0; i < keyValues.length; i++) {\n        var keyValue = keyValues[i];\n        object[keyValue.key] = keyValue.value(self, locals);\n      }\n      return object;\n    }, {\n      literal:true,\n      constant:allConstant\n    });\n  }\n}\n\n//////////////////////////////////////////////////\n// Parser helper functions\n//////////////////////////////////////////////////\n\nfunction setter(obj, path, setValue, fullExp) {\n  var element = path.split('.'), key;\n  for (var i = 0; element.length > 1; i++) {\n    key = ensureSafeMemberName(element.shift(), fullExp);\n    var propertyObj = obj[key];\n    if (!propertyObj) {\n      propertyObj = {};\n      obj[key] = propertyObj;\n    }\n    obj = propertyObj;\n    if (obj.then) {\n      if (!(\"$$v\" in obj)) {\n        (function(promise) {\n          promise.then(function(val) { promise.$$v = val; }); }\n        )(obj);\n      }\n      if (obj.$$v === undefined) {\n        obj.$$v = {};\n      }\n      obj = obj.$$v;\n    }\n  }\n  key = ensureSafeMemberName(element.shift(), fullExp);\n  obj[key] = setValue;\n  return setValue;\n}\n\nvar getterFnCache = {};\n\n/**\n * Implementation of the \"Black Hole\" variant from:\n * - http://jsperf.com/angularjs-parse-getter/4\n * - http://jsperf.com/path-evaluation-simplified/7\n */\nfunction cspSafeGetterFn(key0, key1, key2, key3, key4, fullExp) {\n  ensureSafeMemberName(key0, fullExp);\n  ensureSafeMemberName(key1, fullExp);\n  ensureSafeMemberName(key2, fullExp);\n  ensureSafeMemberName(key3, fullExp);\n  ensureSafeMemberName(key4, fullExp);\n  return function(scope, locals) {\n    var pathVal = (locals && locals.hasOwnProperty(key0)) ? locals : scope,\n        promise;\n\n    if (pathVal === null || pathVal === undefined) return pathVal;\n\n    pathVal = pathVal[key0];\n    if (pathVal && pathVal.then) {\n      if (!(\"$$v\" in pathVal)) {\n        promise = pathVal;\n        promise.$$v = undefined;\n        promise.then(function(val) { promise.$$v = val; });\n      }\n      pathVal = pathVal.$$v;\n    }\n    if (!key1 || pathVal === null || pathVal === undefined) return pathVal;\n\n    pathVal = pathVal[key1];\n    if (pathVal && pathVal.then) {\n      if (!(\"$$v\" in pathVal)) {\n        promise = pathVal;\n        promise.$$v = undefined;\n        promise.then(function(val) { promise.$$v = val; });\n      }\n      pathVal = pathVal.$$v;\n    }\n    if (!key2 || pathVal === null || pathVal === undefined) return pathVal;\n\n    pathVal = pathVal[key2];\n    if (pathVal && pathVal.then) {\n      if (!(\"$$v\" in pathVal)) {\n        promise = pathVal;\n        promise.$$v = undefined;\n        promise.then(function(val) { promise.$$v = val; });\n      }\n      pathVal = pathVal.$$v;\n    }\n    if (!key3 || pathVal === null || pathVal === undefined) return pathVal;\n\n    pathVal = pathVal[key3];\n    if (pathVal && pathVal.then) {\n      if (!(\"$$v\" in pathVal)) {\n        promise = pathVal;\n        promise.$$v = undefined;\n        promise.then(function(val) { promise.$$v = val; });\n      }\n      pathVal = pathVal.$$v;\n    }\n    if (!key4 || pathVal === null || pathVal === undefined) return pathVal;\n\n    pathVal = pathVal[key4];\n    if (pathVal && pathVal.then) {\n      if (!(\"$$v\" in pathVal)) {\n        promise = pathVal;\n        promise.$$v = undefined;\n        promise.then(function(val) { promise.$$v = val; });\n      }\n      pathVal = pathVal.$$v;\n    }\n    return pathVal;\n  };\n}\n\nfunction getterFn(path, csp, fullExp) {\n  if (getterFnCache.hasOwnProperty(path)) {\n    return getterFnCache[path];\n  }\n\n  var pathKeys = path.split('.'),\n      pathKeysLength = pathKeys.length,\n      fn;\n\n  if (csp) {\n    fn = (pathKeysLength < 6)\n        ? cspSafeGetterFn(pathKeys[0], pathKeys[1], pathKeys[2], pathKeys[3], pathKeys[4], fullExp)\n        : function(scope, locals) {\n          var i = 0, val;\n          do {\n            val = cspSafeGetterFn(\n                    pathKeys[i++], pathKeys[i++], pathKeys[i++], pathKeys[i++], pathKeys[i++], fullExp\n                  )(scope, locals);\n\n            locals = undefined; // clear after first iteration\n            scope = val;\n          } while (i < pathKeysLength);\n          return val;\n        }\n  } else {\n    var code = 'var l, fn, p;\\n';\n    forEach(pathKeys, function(key, index) {\n      ensureSafeMemberName(key, fullExp);\n      code += 'if(s === null || s === undefined) return s;\\n' +\n              'l=s;\\n' +\n              's='+ (index\n                      // we simply dereference 's' on any .dot notation\n                      ? 's'\n                      // but if we are first then we check locals first, and if so read it first\n                      : '((k&&k.hasOwnProperty(\"' + key + '\"))?k:s)') + '[\"' + key + '\"]' + ';\\n' +\n              'if (s && s.then) {\\n' +\n                ' if (!(\"$$v\" in s)) {\\n' +\n                  ' p=s;\\n' +\n                  ' p.$$v = undefined;\\n' +\n                  ' p.then(function(v) {p.$$v=v;});\\n' +\n                  '}\\n' +\n                ' s=s.$$v\\n' +\n              '}\\n';\n    });\n    code += 'return s;';\n    fn = Function('s', 'k', code); // s=scope, k=locals\n    fn.toString = function() { return code; };\n  }\n\n  return getterFnCache[path] = fn;\n}\n\n///////////////////////////////////\n\n/**\n * @ngdoc function\n * @name ng.$parse\n * @function\n *\n * @description\n *\n * Converts Angular {@link guide/expression expression} into a function.\n *\n * <pre>\n *   var getter = $parse('user.name');\n *   var setter = getter.assign;\n *   var context = {user:{name:'angular'}};\n *   var locals = {user:{name:'local'}};\n *\n *   expect(getter(context)).toEqual('angular');\n *   setter(context, 'newValue');\n *   expect(context.user.name).toEqual('newValue');\n *   expect(getter(context, locals)).toEqual('local');\n * </pre>\n *\n *\n * @param {string} expression String expression to compile.\n * @returns {function(context, locals)} a function which represents the compiled expression:\n *\n *    * `context` – `{object}` – an object against which any expressions embedded in the strings\n *      are evaluated against (typically a scope object).\n *    * `locals` – `{object=}` – local variables context object, useful for overriding values in\n *      `context`.\n *\n *    The returned function also has the following properties:\n *      * `literal` – `{boolean}` – whether the expression's top-level node is a JavaScript\n *        literal.\n *      * `constant` – `{boolean}` – whether the expression is made entirely of JavaScript\n *        constant literals.\n *      * `assign` – `{?function(context, value)}` – if the expression is assignable, this will be\n *        set to a function to change its value on the given context.\n *\n */\nfunction $ParseProvider() {\n  var cache = {};\n  this.$get = ['$filter', '$sniffer', function($filter, $sniffer) {\n    return function(exp) {\n      switch(typeof exp) {\n        case 'string':\n          return cache.hasOwnProperty(exp)\n            ? cache[exp]\n            : cache[exp] =  parser(exp, false, $filter, $sniffer.csp);\n        case 'function':\n          return exp;\n        default:\n          return noop;\n      }\n    };\n  }];\n}\n\n/**\n * @ngdoc service\n * @name ng.$q\n * @requires $rootScope\n *\n * @description\n * A promise/deferred implementation inspired by [Kris Kowal's Q](https://github.com/kriskowal/q).\n *\n * [The CommonJS Promise proposal](http://wiki.commonjs.org/wiki/Promises) describes a promise as an\n * interface for interacting with an object that represents the result of an action that is\n * performed asynchronously, and may or may not be finished at any given point in time.\n *\n * From the perspective of dealing with error handling, deferred and promise APIs are to\n * asynchronous programming what `try`, `catch` and `throw` keywords are to synchronous programming.\n *\n * <pre>\n *   // for the purpose of this example let's assume that variables `$q` and `scope` are\n *   // available in the current lexical scope (they could have been injected or passed in).\n *\n *   function asyncGreet(name) {\n *     var deferred = $q.defer();\n *\n *     setTimeout(function() {\n *       // since this fn executes async in a future turn of the event loop, we need to wrap\n *       // our code into an $apply call so that the model changes are properly observed.\n *       scope.$apply(function() {\n *         deferred.notify('About to greet ' + name + '.');\n *\n *         if (okToGreet(name)) {\n *           deferred.resolve('Hello, ' + name + '!');\n *         } else {\n *           deferred.reject('Greeting ' + name + ' is not allowed.');\n *         }\n *       });\n *     }, 1000);\n *\n *     return deferred.promise;\n *   }\n *\n *   var promise = asyncGreet('Robin Hood');\n *   promise.then(function(greeting) {\n *     alert('Success: ' + greeting);\n *   }, function(reason) {\n *     alert('Failed: ' + reason);\n *   }, function(update) {\n *     alert('Got notification: ' + update);\n *   });\n * </pre>\n *\n * At first it might not be obvious why this extra complexity is worth the trouble. The payoff\n * comes in the way of\n * [guarantees that promise and deferred APIs make](https://github.com/kriskowal/uncommonjs/blob/master/promises/specification.md).\n *\n * Additionally the promise api allows for composition that is very hard to do with the\n * traditional callback ([CPS](http://en.wikipedia.org/wiki/Continuation-passing_style)) approach.\n * For more on this please see the [Q documentation](https://github.com/kriskowal/q) especially the\n * section on serial or parallel joining of promises.\n *\n *\n * # The Deferred API\n *\n * A new instance of deferred is constructed by calling `$q.defer()`.\n *\n * The purpose of the deferred object is to expose the associated Promise instance as well as APIs\n * that can be used for signaling the successful or unsuccessful completion, as well as the status\n * of the task.\n *\n * **Methods**\n *\n * - `resolve(value)` – resolves the derived promise with the `value`. If the value is a rejection\n *   constructed via `$q.reject`, the promise will be rejected instead.\n * - `reject(reason)` – rejects the derived promise with the `reason`. This is equivalent to\n *   resolving it with a rejection constructed via `$q.reject`.\n * - `notify(value)` - provides updates on the status of the promises execution. This may be called\n *   multiple times before the promise is either resolved or rejected.\n *\n * **Properties**\n *\n * - promise – `{Promise}` – promise object associated with this deferred.\n *\n *\n * # The Promise API\n *\n * A new promise instance is created when a deferred instance is created and can be retrieved by\n * calling `deferred.promise`.\n *\n * The purpose of the promise object is to allow for interested parties to get access to the result\n * of the deferred task when it completes.\n *\n * **Methods**\n *\n * - `then(successCallback, errorCallback, notifyCallback)` – regardless of when the promise was or\n *   will be resolved or rejected, `then` calls one of the success or error callbacks asynchronously\n *   as soon as the result is available. The callbacks are called with a single argument: the result\n *   or rejection reason. Additionally, the notify callback may be called zero or more times to\n *   provide a progress indication, before the promise is resolved or rejected.\n *\n *   This method *returns a new promise* which is resolved or rejected via the return value of the\n *   `successCallback`, `errorCallback`. It also notifies via the return value of the `notifyCallback`\n *   method. The promise can not be resolved or rejected from the notifyCallback method.\n *\n * - `catch(errorCallback)` – shorthand for `promise.then(null, errorCallback)`\n *\n * - `finally(callback)` – allows you to observe either the fulfillment or rejection of a promise,\n *   but to do so without modifying the final value. This is useful to release resources or do some\n *   clean-up that needs to be done whether the promise was rejected or resolved. See the [full\n *   specification](https://github.com/kriskowal/q/wiki/API-Reference#promisefinallycallback) for\n *   more information.\n *\n *   Because `finally` is a reserved word in JavaScript and reserved keywords are not supported as\n *   property names by ES3, you'll need to invoke the method like `promise['finally'](callback)` to\n *   make your code IE8 compatible.\n *\n * # Chaining promises\n *\n * Because calling the `then` method of a promise returns a new derived promise, it is easily possible\n * to create a chain of promises:\n *\n * <pre>\n *   promiseB = promiseA.then(function(result) {\n *     return result + 1;\n *   });\n *\n *   // promiseB will be resolved immediately after promiseA is resolved and its value\n *   // will be the result of promiseA incremented by 1\n * </pre>\n *\n * It is possible to create chains of any length and since a promise can be resolved with another\n * promise (which will defer its resolution further), it is possible to pause/defer resolution of\n * the promises at any point in the chain. This makes it possible to implement powerful APIs like\n * $http's response interceptors.\n *\n *\n * # Differences between Kris Kowal's Q and $q\n *\n *  There are three main differences:\n *\n * - $q is integrated with the {@link ng.$rootScope.Scope} Scope model observation\n *   mechanism in angular, which means faster propagation of resolution or rejection into your\n *   models and avoiding unnecessary browser repaints, which would result in flickering UI.\n * - $q promises are recognized by the templating engine in angular, which means that in templates\n *   you can treat promises attached to a scope as if they were the resulting values.\n * - Q has many more features than $q, but that comes at a cost of bytes. $q is tiny, but contains\n *   all the important functionality needed for common async tasks.\n *\n *  # Testing\n *\n *  <pre>\n *    it('should simulate promise', inject(function($q, $rootScope) {\n *      var deferred = $q.defer();\n *      var promise = deferred.promise;\n *      var resolvedValue;\n *\n *      promise.then(function(value) { resolvedValue = value; });\n *      expect(resolvedValue).toBeUndefined();\n *\n *      // Simulate resolving of promise\n *      deferred.resolve(123);\n *      // Note that the 'then' function does not get called synchronously.\n *      // This is because we want the promise API to always be async, whether or not\n *      // it got called synchronously or asynchronously.\n *      expect(resolvedValue).toBeUndefined();\n *\n *      // Propagate promise resolution to 'then' functions using $apply().\n *      $rootScope.$apply();\n *      expect(resolvedValue).toEqual(123);\n *    });\n *  </pre>\n */\nfunction $QProvider() {\n\n  this.$get = ['$rootScope', '$exceptionHandler', function($rootScope, $exceptionHandler) {\n    return qFactory(function(callback) {\n      $rootScope.$evalAsync(callback);\n    }, $exceptionHandler);\n  }];\n}\n\n\n/**\n * Constructs a promise manager.\n *\n * @param {function(function)} nextTick Function for executing functions in the next turn.\n * @param {function(...*)} exceptionHandler Function into which unexpected exceptions are passed for\n *     debugging purposes.\n * @returns {object} Promise manager.\n */\nfunction qFactory(nextTick, exceptionHandler) {\n\n  /**\n   * @ngdoc\n   * @name ng.$q#defer\n   * @methodOf ng.$q\n   * @description\n   * Creates a `Deferred` object which represents a task which will finish in the future.\n   *\n   * @returns {Deferred} Returns a new instance of deferred.\n   */\n  var defer = function() {\n    var pending = [],\n        value, deferred;\n\n    deferred = {\n\n      resolve: function(val) {\n        if (pending) {\n          var callbacks = pending;\n          pending = undefined;\n          value = ref(val);\n\n          if (callbacks.length) {\n            nextTick(function() {\n              var callback;\n              for (var i = 0, ii = callbacks.length; i < ii; i++) {\n                callback = callbacks[i];\n                value.then(callback[0], callback[1], callback[2]);\n              }\n            });\n          }\n        }\n      },\n\n\n      reject: function(reason) {\n        deferred.resolve(reject(reason));\n      },\n\n\n      notify: function(progress) {\n        if (pending) {\n          var callbacks = pending;\n\n          if (pending.length) {\n            nextTick(function() {\n              var callback;\n              for (var i = 0, ii = callbacks.length; i < ii; i++) {\n                callback = callbacks[i];\n                callback[2](progress);\n              }\n            });\n          }\n        }\n      },\n\n\n      promise: {\n        then: function(callback, errback, progressback) {\n          var result = defer();\n\n          var wrappedCallback = function(value) {\n            try {\n              result.resolve((isFunction(callback) ? callback : defaultCallback)(value));\n            } catch(e) {\n              result.reject(e);\n              exceptionHandler(e);\n            }\n          };\n\n          var wrappedErrback = function(reason) {\n            try {\n              result.resolve((isFunction(errback) ? errback : defaultErrback)(reason));\n            } catch(e) {\n              result.reject(e);\n              exceptionHandler(e);\n            }\n          };\n\n          var wrappedProgressback = function(progress) {\n            try {\n              result.notify((isFunction(progressback) ? progressback : defaultCallback)(progress));\n            } catch(e) {\n              exceptionHandler(e);\n            }\n          };\n\n          if (pending) {\n            pending.push([wrappedCallback, wrappedErrback, wrappedProgressback]);\n          } else {\n            value.then(wrappedCallback, wrappedErrback, wrappedProgressback);\n          }\n\n          return result.promise;\n        },\n\n        \"catch\": function(callback) {\n          return this.then(null, callback);\n        },\n\n        \"finally\": function(callback) {\n\n          function makePromise(value, resolved) {\n            var result = defer();\n            if (resolved) {\n              result.resolve(value);\n            } else {\n              result.reject(value);\n            }\n            return result.promise;\n          }\n\n          function handleCallback(value, isResolved) {\n            var callbackOutput = null;\n            try {\n              callbackOutput = (callback ||defaultCallback)();\n            } catch(e) {\n              return makePromise(e, false);\n            }\n            if (callbackOutput && isFunction(callbackOutput.then)) {\n              return callbackOutput.then(function() {\n                return makePromise(value, isResolved);\n              }, function(error) {\n                return makePromise(error, false);\n              });\n            } else {\n              return makePromise(value, isResolved);\n            }\n          }\n\n          return this.then(function(value) {\n            return handleCallback(value, true);\n          }, function(error) {\n            return handleCallback(error, false);\n          });\n        }\n      }\n    };\n\n    return deferred;\n  };\n\n\n  var ref = function(value) {\n    if (value && isFunction(value.then)) return value;\n    return {\n      then: function(callback) {\n        var result = defer();\n        nextTick(function() {\n          result.resolve(callback(value));\n        });\n        return result.promise;\n      }\n    };\n  };\n\n\n  /**\n   * @ngdoc\n   * @name ng.$q#reject\n   * @methodOf ng.$q\n   * @description\n   * Creates a promise that is resolved as rejected with the specified `reason`. This api should be\n   * used to forward rejection in a chain of promises. If you are dealing with the last promise in\n   * a promise chain, you don't need to worry about it.\n   *\n   * When comparing deferreds/promises to the familiar behavior of try/catch/throw, think of\n   * `reject` as the `throw` keyword in JavaScript. This also means that if you \"catch\" an error via\n   * a promise error callback and you want to forward the error to the promise derived from the\n   * current promise, you have to \"rethrow\" the error by returning a rejection constructed via\n   * `reject`.\n   *\n   * <pre>\n   *   promiseB = promiseA.then(function(result) {\n   *     // success: do something and resolve promiseB\n   *     //          with the old or a new result\n   *     return result;\n   *   }, function(reason) {\n   *     // error: handle the error if possible and\n   *     //        resolve promiseB with newPromiseOrValue,\n   *     //        otherwise forward the rejection to promiseB\n   *     if (canHandle(reason)) {\n   *      // handle the error and recover\n   *      return newPromiseOrValue;\n   *     }\n   *     return $q.reject(reason);\n   *   });\n   * </pre>\n   *\n   * @param {*} reason Constant, message, exception or an object representing the rejection reason.\n   * @returns {Promise} Returns a promise that was already resolved as rejected with the `reason`.\n   */\n  var reject = function(reason) {\n    return {\n      then: function(callback, errback) {\n        var result = defer();\n        nextTick(function() {\n          try {\n            result.resolve((isFunction(errback) ? errback : defaultErrback)(reason));\n          } catch(e) {\n            result.reject(e);\n            exceptionHandler(e);\n          }\n        });\n        return result.promise;\n      }\n    };\n  };\n\n\n  /**\n   * @ngdoc\n   * @name ng.$q#when\n   * @methodOf ng.$q\n   * @description\n   * Wraps an object that might be a value or a (3rd party) then-able promise into a $q promise.\n   * This is useful when you are dealing with an object that might or might not be a promise, or if\n   * the promise comes from a source that can't be trusted.\n   *\n   * @param {*} value Value or a promise\n   * @returns {Promise} Returns a promise of the passed value or promise\n   */\n  var when = function(value, callback, errback, progressback) {\n    var result = defer(),\n        done;\n\n    var wrappedCallback = function(value) {\n      try {\n        return (isFunction(callback) ? callback : defaultCallback)(value);\n      } catch (e) {\n        exceptionHandler(e);\n        return reject(e);\n      }\n    };\n\n    var wrappedErrback = function(reason) {\n      try {\n        return (isFunction(errback) ? errback : defaultErrback)(reason);\n      } catch (e) {\n        exceptionHandler(e);\n        return reject(e);\n      }\n    };\n\n    var wrappedProgressback = function(progress) {\n      try {\n        return (isFunction(progressback) ? progressback : defaultCallback)(progress);\n      } catch (e) {\n        exceptionHandler(e);\n      }\n    };\n\n    nextTick(function() {\n      ref(value).then(function(value) {\n        if (done) return;\n        done = true;\n        result.resolve(ref(value).then(wrappedCallback, wrappedErrback, wrappedProgressback));\n      }, function(reason) {\n        if (done) return;\n        done = true;\n        result.resolve(wrappedErrback(reason));\n      }, function(progress) {\n        if (done) return;\n        result.notify(wrappedProgressback(progress));\n      });\n    });\n\n    return result.promise;\n  };\n\n\n  function defaultCallback(value) {\n    return value;\n  }\n\n\n  function defaultErrback(reason) {\n    return reject(reason);\n  }\n\n\n  /**\n   * @ngdoc\n   * @name ng.$q#all\n   * @methodOf ng.$q\n   * @description\n   * Combines multiple promises into a single promise that is resolved when all of the input\n   * promises are resolved.\n   *\n   * @param {Array.<Promise>|Object.<Promise>} promises An array or hash of promises.\n   * @returns {Promise} Returns a single promise that will be resolved with an array/hash of values,\n   *   each value corresponding to the promise at the same index/key in the `promises` array/hash. If any of\n   *   the promises is resolved with a rejection, this resulting promise will be resolved with the\n   *   same rejection.\n   */\n  function all(promises) {\n    var deferred = defer(),\n        counter = 0,\n        results = isArray(promises) ? [] : {};\n\n    forEach(promises, function(promise, key) {\n      counter++;\n      ref(promise).then(function(value) {\n        if (results.hasOwnProperty(key)) return;\n        results[key] = value;\n        if (!(--counter)) deferred.resolve(results);\n      }, function(reason) {\n        if (results.hasOwnProperty(key)) return;\n        deferred.reject(reason);\n      });\n    });\n\n    if (counter === 0) {\n      deferred.resolve(results);\n    }\n\n    return deferred.promise;\n  }\n\n  return {\n    defer: defer,\n    reject: reject,\n    when: when,\n    all: all\n  };\n}\n\n/**\n * DESIGN NOTES\n *\n * The design decisions behind the scope are heavily favored for speed and memory consumption.\n *\n * The typical use of scope is to watch the expressions, which most of the time return the same\n * value as last time so we optimize the operation.\n *\n * Closures construction is expensive in terms of speed as well as memory:\n *   - No closures, instead use prototypical inheritance for API\n *   - Internal state needs to be stored on scope directly, which means that private state is\n *     exposed as $$____ properties\n *\n * Loop operations are optimized by using while(count--) { ... }\n *   - this means that in order to keep the same order of execution as addition we have to add\n *     items to the array at the beginning (shift) instead of at the end (push)\n *\n * Child scopes are created and removed often\n *   - Using an array would be slow since inserts in middle are expensive so we use linked list\n *\n * There are few watches then a lot of observers. This is why you don't want the observer to be\n * implemented in the same way as watch. Watch requires return of initialization function which\n * are expensive to construct.\n */\n\n\n/**\n * @ngdoc object\n * @name ng.$rootScopeProvider\n * @description\n *\n * Provider for the $rootScope service.\n */\n\n/**\n * @ngdoc function\n * @name ng.$rootScopeProvider#digestTtl\n * @methodOf ng.$rootScopeProvider\n * @description\n *\n * Sets the number of digest iterations the scope should attempt to execute before giving up and\n * assuming that the model is unstable.\n *\n * The current default is 10 iterations.\n *\n * @param {number} limit The number of digest iterations.\n */\n\n\n/**\n * @ngdoc object\n * @name ng.$rootScope\n * @description\n *\n * Every application has a single root {@link ng.$rootScope.Scope scope}.\n * All other scopes are child scopes of the root scope. Scopes provide mechanism for watching the model and provide\n * event processing life-cycle. See {@link guide/scope developer guide on scopes}.\n */\nfunction $RootScopeProvider(){\n  var TTL = 10;\n  var $rootScopeMinErr = minErr('$rootScope');\n\n  this.digestTtl = function(value) {\n    if (arguments.length) {\n      TTL = value;\n    }\n    return TTL;\n  };\n\n  this.$get = ['$injector', '$exceptionHandler', '$parse', '$browser',\n      function( $injector,   $exceptionHandler,   $parse,   $browser) {\n\n    /**\n     * @ngdoc function\n     * @name ng.$rootScope.Scope\n     *\n     * @description\n     * A root scope can be retrieved using the {@link ng.$rootScope $rootScope} key from the\n     * {@link AUTO.$injector $injector}. Child scopes are created using the\n     * {@link ng.$rootScope.Scope#$new $new()} method. (Most scopes are created automatically when\n     * compiled HTML template is executed.)\n     *\n     * Here is a simple scope snippet to show how you can interact with the scope.\n     * <pre>\n     * <file src=\"./test/ng/rootScopeSpec.js\" tag=\"docs1\" />\n     * </pre>\n     *\n     * # Inheritance\n     * A scope can inherit from a parent scope, as in this example:\n     * <pre>\n         var parent = $rootScope;\n         var child = parent.$new();\n\n         parent.salutation = \"Hello\";\n         child.name = \"World\";\n         expect(child.salutation).toEqual('Hello');\n\n         child.salutation = \"Welcome\";\n         expect(child.salutation).toEqual('Welcome');\n         expect(parent.salutation).toEqual('Hello');\n     * </pre>\n     *\n     *\n     * @param {Object.<string, function()>=} providers Map of service factory which need to be provided\n     *     for the current scope. Defaults to {@link ng}.\n     * @param {Object.<string, *>=} instanceCache Provides pre-instantiated services which should\n     *     append/override services provided by `providers`. This is handy when unit-testing and having\n     *     the need to override a default service.\n     * @returns {Object} Newly created scope.\n     *\n     */\n    function Scope() {\n      this.$id = nextUid();\n      this.$$phase = this.$parent = this.$$watchers =\n                     this.$$nextSibling = this.$$prevSibling =\n                     this.$$childHead = this.$$childTail = null;\n      this['this'] = this.$root =  this;\n      this.$$destroyed = false;\n      this.$$asyncQueue = [];\n      this.$$postDigestQueue = [];\n      this.$$listeners = {};\n      this.$$isolateBindings = {};\n    }\n\n    /**\n     * @ngdoc property\n     * @name ng.$rootScope.Scope#$id\n     * @propertyOf ng.$rootScope.Scope\n     * @returns {number} Unique scope ID (monotonically increasing alphanumeric sequence) useful for\n     *   debugging.\n     */\n\n\n    Scope.prototype = {\n      constructor: Scope,\n      /**\n       * @ngdoc function\n       * @name ng.$rootScope.Scope#$new\n       * @methodOf ng.$rootScope.Scope\n       * @function\n       *\n       * @description\n       * Creates a new child {@link ng.$rootScope.Scope scope}.\n       *\n       * The parent scope will propagate the {@link ng.$rootScope.Scope#$digest $digest()} and\n       * {@link ng.$rootScope.Scope#$digest $digest()} events. The scope can be removed from the scope\n       * hierarchy using {@link ng.$rootScope.Scope#$destroy $destroy()}.\n       *\n       * {@link ng.$rootScope.Scope#$destroy $destroy()} must be called on a scope when it is desired for\n       * the scope and its child scopes to be permanently detached from the parent and thus stop\n       * participating in model change detection and listener notification by invoking.\n       *\n       * @param {boolean} isolate if true then the scope does not prototypically inherit from the\n       *         parent scope. The scope is isolated, as it can not see parent scope properties.\n       *         When creating widgets it is useful for the widget to not accidentally read parent\n       *         state.\n       *\n       * @returns {Object} The newly created child scope.\n       *\n       */\n      $new: function(isolate) {\n        var Child,\n            child;\n\n        if (isolate) {\n          child = new Scope();\n          child.$root = this.$root;\n          // ensure that there is just one async queue per $rootScope and it's children\n          child.$$asyncQueue = this.$$asyncQueue;\n          child.$$postDigestQueue = this.$$postDigestQueue;\n        } else {\n          Child = function() {}; // should be anonymous; This is so that when the minifier munges\n            // the name it does not become random set of chars. These will then show up as class\n            // name in the debugger.\n          Child.prototype = this;\n          child = new Child();\n          child.$id = nextUid();\n        }\n        child['this'] = child;\n        child.$$listeners = {};\n        child.$parent = this;\n        child.$$watchers = child.$$nextSibling = child.$$childHead = child.$$childTail = null;\n        child.$$prevSibling = this.$$childTail;\n        if (this.$$childHead) {\n          this.$$childTail.$$nextSibling = child;\n          this.$$childTail = child;\n        } else {\n          this.$$childHead = this.$$childTail = child;\n        }\n        return child;\n      },\n\n      /**\n       * @ngdoc function\n       * @name ng.$rootScope.Scope#$watch\n       * @methodOf ng.$rootScope.Scope\n       * @function\n       *\n       * @description\n       * Registers a `listener` callback to be executed whenever the `watchExpression` changes.\n       *\n       * - The `watchExpression` is called on every call to {@link ng.$rootScope.Scope#$digest $digest()} and\n       *   should return the value which will be watched. (Since {@link ng.$rootScope.Scope#$digest $digest()}\n       *   reruns when it detects changes the `watchExpression` can execute multiple times per\n       *   {@link ng.$rootScope.Scope#$digest $digest()} and should be idempotent.)\n       * - The `listener` is called only when the value from the current `watchExpression` and the\n       *   previous call to `watchExpression` are not equal (with the exception of the initial run,\n       *   see below). The inequality is determined according to\n       *   {@link angular.equals} function. To save the value of the object for later comparison, the\n       *   {@link angular.copy} function is used. It also means that watching complex options will\n       *   have adverse memory and performance implications.\n       * - The watch `listener` may change the model, which may trigger other `listener`s to fire. This\n       *   is achieved by rerunning the watchers until no changes are detected. The rerun iteration\n       *   limit is 10 to prevent an infinite loop deadlock.\n       *\n       *\n       * If you want to be notified whenever {@link ng.$rootScope.Scope#$digest $digest} is called,\n       * you can register a `watchExpression` function with no `listener`. (Since `watchExpression`\n       * can execute multiple times per {@link ng.$rootScope.Scope#$digest $digest} cycle when a change is\n       * detected, be prepared for multiple calls to your listener.)\n       *\n       * After a watcher is registered with the scope, the `listener` fn is called asynchronously\n       * (via {@link ng.$rootScope.Scope#$evalAsync $evalAsync}) to initialize the\n       * watcher. In rare cases, this is undesirable because the listener is called when the result\n       * of `watchExpression` didn't change. To detect this scenario within the `listener` fn, you\n       * can compare the `newVal` and `oldVal`. If these two values are identical (`===`) then the\n       * listener was called due to initialization.\n       *\n       *\n       * # Example\n       * <pre>\n           // let's assume that scope was dependency injected as the $rootScope\n           var scope = $rootScope;\n           scope.name = 'misko';\n           scope.counter = 0;\n\n           expect(scope.counter).toEqual(0);\n           scope.$watch('name', function(newValue, oldValue) { scope.counter = scope.counter + 1; });\n           expect(scope.counter).toEqual(0);\n\n           scope.$digest();\n           // no variable change\n           expect(scope.counter).toEqual(0);\n\n           scope.name = 'adam';\n           scope.$digest();\n           expect(scope.counter).toEqual(1);\n       * </pre>\n       *\n       *\n       *\n       * @param {(function()|string)} watchExpression Expression that is evaluated on each\n       *    {@link ng.$rootScope.Scope#$digest $digest} cycle. A change in the return value triggers a\n       *    call to the `listener`.\n       *\n       *    - `string`: Evaluated as {@link guide/expression expression}\n       *    - `function(scope)`: called with current `scope` as a parameter.\n       * @param {(function()|string)=} listener Callback called whenever the return value of\n       *   the `watchExpression` changes.\n       *\n       *    - `string`: Evaluated as {@link guide/expression expression}\n       *    - `function(newValue, oldValue, scope)`: called with current and previous values as parameters.\n       *\n       * @param {boolean=} objectEquality Compare object for equality rather than for reference.\n       * @returns {function()} Returns a deregistration function for this listener.\n       */\n      $watch: function(watchExp, listener, objectEquality) {\n        var scope = this,\n            get = compileToFn(watchExp, 'watch'),\n            array = scope.$$watchers,\n            watcher = {\n              fn: listener,\n              last: initWatchVal,\n              get: get,\n              exp: watchExp,\n              eq: !!objectEquality\n            };\n\n        // in the case user pass string, we need to compile it, do we really need this ?\n        if (!isFunction(listener)) {\n          var listenFn = compileToFn(listener || noop, 'listener');\n          watcher.fn = function(newVal, oldVal, scope) {listenFn(scope);};\n        }\n\n        if (typeof watchExp == 'string' && get.constant) {\n          var originalFn = watcher.fn;\n          watcher.fn = function(newVal, oldVal, scope) {\n            originalFn.call(this, newVal, oldVal, scope);\n            arrayRemove(array, watcher);\n          };\n        }\n\n        if (!array) {\n          array = scope.$$watchers = [];\n        }\n        // we use unshift since we use a while loop in $digest for speed.\n        // the while loop reads in reverse order.\n        array.unshift(watcher);\n\n        return function() {\n          arrayRemove(array, watcher);\n        };\n      },\n\n\n      /**\n       * @ngdoc function\n       * @name ng.$rootScope.Scope#$watchCollection\n       * @methodOf ng.$rootScope.Scope\n       * @function\n       *\n       * @description\n       * Shallow watches the properties of an object and fires whenever any of the properties change\n       * (for arrays this implies watching the array items, for object maps this implies watching the properties).\n       * If a change is detected the `listener` callback is fired.\n       *\n       * - The `obj` collection is observed via standard $watch operation and is examined on every call to $digest() to\n       *   see if any items have been added, removed, or moved.\n       * - The `listener` is called whenever anything within the `obj` has changed. Examples include adding new items\n       *   into the object or array, removing and moving items around.\n       *\n       *\n       * # Example\n       * <pre>\n          $scope.names = ['igor', 'matias', 'misko', 'james'];\n          $scope.dataCount = 4;\n\n          $scope.$watchCollection('names', function(newNames, oldNames) {\n            $scope.dataCount = newNames.length;\n          });\n\n          expect($scope.dataCount).toEqual(4);\n          $scope.$digest();\n\n          //still at 4 ... no changes\n          expect($scope.dataCount).toEqual(4);\n\n          $scope.names.pop();\n          $scope.$digest();\n\n          //now there's been a change\n          expect($scope.dataCount).toEqual(3);\n       * </pre>\n       *\n       *\n       * @param {string|Function(scope)} obj Evaluated as {@link guide/expression expression}. The expression value\n       *    should evaluate to an object or an array which is observed on each\n       *    {@link ng.$rootScope.Scope#$digest $digest} cycle. Any shallow change within the collection will trigger\n       *    a call to the `listener`.\n       *\n       * @param {function(newCollection, oldCollection, scope)} listener a callback function that is fired with both\n       *    the `newCollection` and `oldCollection` as parameters.\n       *    The `newCollection` object is the newly modified data obtained from the `obj` expression and the\n       *    `oldCollection` object is a copy of the former collection data.\n       *    The `scope` refers to the current scope.\n       *\n       * @returns {function()} Returns a de-registration function for this listener. When the de-registration function is executed\n       * then the internal watch operation is terminated.\n       */\n      $watchCollection: function(obj, listener) {\n        var self = this;\n        var oldValue;\n        var newValue;\n        var changeDetected = 0;\n        var objGetter = $parse(obj);\n        var internalArray = [];\n        var internalObject = {};\n        var oldLength = 0;\n\n        function $watchCollectionWatch() {\n          newValue = objGetter(self);\n          var newLength, key;\n\n          if (!isObject(newValue)) {\n            if (oldValue !== newValue) {\n              oldValue = newValue;\n              changeDetected++;\n            }\n          } else if (isArrayLike(newValue)) {\n            if (oldValue !== internalArray) {\n              // we are transitioning from something which was not an array into array.\n              oldValue = internalArray;\n              oldLength = oldValue.length = 0;\n              changeDetected++;\n            }\n\n            newLength = newValue.length;\n\n            if (oldLength !== newLength) {\n              // if lengths do not match we need to trigger change notification\n              changeDetected++;\n              oldValue.length = oldLength = newLength;\n            }\n            // copy the items to oldValue and look for changes.\n            for (var i = 0; i < newLength; i++) {\n              if (oldValue[i] !== newValue[i]) {\n                changeDetected++;\n                oldValue[i] = newValue[i];\n              }\n            }\n          } else {\n            if (oldValue !== internalObject) {\n              // we are transitioning from something which was not an object into object.\n              oldValue = internalObject = {};\n              oldLength = 0;\n              changeDetected++;\n            }\n            // copy the items to oldValue and look for changes.\n            newLength = 0;\n            for (key in newValue) {\n              if (newValue.hasOwnProperty(key)) {\n                newLength++;\n                if (oldValue.hasOwnProperty(key)) {\n                  if (oldValue[key] !== newValue[key]) {\n                    changeDetected++;\n                    oldValue[key] = newValue[key];\n                  }\n                } else {\n                  oldLength++;\n                  oldValue[key] = newValue[key];\n                  changeDetected++;\n                }\n              }\n            }\n            if (oldLength > newLength) {\n              // we used to have more keys, need to find them and destroy them.\n              changeDetected++;\n              for(key in oldValue) {\n                if (oldValue.hasOwnProperty(key) && !newValue.hasOwnProperty(key)) {\n                  oldLength--;\n                  delete oldValue[key];\n                }\n              }\n            }\n          }\n          return changeDetected;\n        }\n\n        function $watchCollectionAction() {\n          listener(newValue, oldValue, self);\n        }\n\n        return this.$watch($watchCollectionWatch, $watchCollectionAction);\n      },\n\n      /**\n       * @ngdoc function\n       * @name ng.$rootScope.Scope#$digest\n       * @methodOf ng.$rootScope.Scope\n       * @function\n       *\n       * @description\n       * Processes all of the {@link ng.$rootScope.Scope#$watch watchers} of the current scope and its children.\n       * Because a {@link ng.$rootScope.Scope#$watch watcher}'s listener can change the model, the\n       * `$digest()` keeps calling the {@link ng.$rootScope.Scope#$watch watchers} until no more listeners are\n       * firing. This means that it is possible to get into an infinite loop. This function will throw\n       * `'Maximum iteration limit exceeded.'` if the number of iterations exceeds 10.\n       *\n       * Usually you don't call `$digest()` directly in\n       * {@link ng.directive:ngController controllers} or in\n       * {@link ng.$compileProvider#directive directives}.\n       * Instead a call to {@link ng.$rootScope.Scope#$apply $apply()} (typically from within a\n       * {@link ng.$compileProvider#directive directives}) will force a `$digest()`.\n       *\n       * If you want to be notified whenever `$digest()` is called,\n       * you can register a `watchExpression` function  with {@link ng.$rootScope.Scope#$watch $watch()}\n       * with no `listener`.\n       *\n       * You may have a need to call `$digest()` from within unit-tests, to simulate the scope\n       * life-cycle.\n       *\n       * # Example\n       * <pre>\n           var scope = ...;\n           scope.name = 'misko';\n           scope.counter = 0;\n\n           expect(scope.counter).toEqual(0);\n           scope.$watch('name', function(newValue, oldValue) {\n             scope.counter = scope.counter + 1;\n           });\n           expect(scope.counter).toEqual(0);\n\n           scope.$digest();\n           // no variable change\n           expect(scope.counter).toEqual(0);\n\n           scope.name = 'adam';\n           scope.$digest();\n           expect(scope.counter).toEqual(1);\n       * </pre>\n       *\n       */\n      $digest: function() {\n        var watch, value, last,\n            watchers,\n            asyncQueue = this.$$asyncQueue,\n            postDigestQueue = this.$$postDigestQueue,\n            length,\n            dirty, ttl = TTL,\n            next, current, target = this,\n            watchLog = [],\n            logIdx, logMsg;\n\n        beginPhase('$digest');\n\n        do { // \"while dirty\" loop\n          dirty = false;\n          current = target;\n\n          while(asyncQueue.length) {\n            try {\n              current.$eval(asyncQueue.shift());\n            } catch (e) {\n              $exceptionHandler(e);\n            }\n          }\n\n          do { // \"traverse the scopes\" loop\n            if ((watchers = current.$$watchers)) {\n              // process our watches\n              length = watchers.length;\n              while (length--) {\n                try {\n                  watch = watchers[length];\n                  // Most common watches are on primitives, in which case we can short\n                  // circuit it with === operator, only when === fails do we use .equals\n                  if (watch && (value = watch.get(current)) !== (last = watch.last) &&\n                      !(watch.eq\n                          ? equals(value, last)\n                          : (typeof value == 'number' && typeof last == 'number'\n                             && isNaN(value) && isNaN(last)))) {\n                    dirty = true;\n                    watch.last = watch.eq ? copy(value) : value;\n                    watch.fn(value, ((last === initWatchVal) ? value : last), current);\n                    if (ttl < 5) {\n                      logIdx = 4 - ttl;\n                      if (!watchLog[logIdx]) watchLog[logIdx] = [];\n                      logMsg = (isFunction(watch.exp))\n                          ? 'fn: ' + (watch.exp.name || watch.exp.toString())\n                          : watch.exp;\n                      logMsg += '; newVal: ' + toJson(value) + '; oldVal: ' + toJson(last);\n                      watchLog[logIdx].push(logMsg);\n                    }\n                  }\n                } catch (e) {\n                  $exceptionHandler(e);\n                }\n              }\n            }\n\n            // Insanity Warning: scope depth-first traversal\n            // yes, this code is a bit crazy, but it works and we have tests to prove it!\n            // this piece should be kept in sync with the traversal in $broadcast\n            if (!(next = (current.$$childHead || (current !== target && current.$$nextSibling)))) {\n              while(current !== target && !(next = current.$$nextSibling)) {\n                current = current.$parent;\n              }\n            }\n          } while ((current = next));\n\n          if(dirty && !(ttl--)) {\n            clearPhase();\n            throw $rootScopeMinErr('infdig',\n                '{0} $digest() iterations reached. Aborting!\\nWatchers fired in the last 5 iterations: {1}',\n                TTL, toJson(watchLog));\n          }\n        } while (dirty || asyncQueue.length);\n\n        clearPhase();\n\n        while(postDigestQueue.length) {\n          try {\n            postDigestQueue.shift()();\n          } catch (e) {\n            $exceptionHandler(e);\n          }\n        }\n      },\n\n\n      /**\n       * @ngdoc event\n       * @name ng.$rootScope.Scope#$destroy\n       * @eventOf ng.$rootScope.Scope\n       * @eventType broadcast on scope being destroyed\n       *\n       * @description\n       * Broadcasted when a scope and its children are being destroyed.\n       *\n       * Note that, in AngularJS, there is also a `$destroy` jQuery event, which can be used to\n       * clean up DOM bindings before an element is removed from the DOM.\n       */\n\n      /**\n       * @ngdoc function\n       * @name ng.$rootScope.Scope#$destroy\n       * @methodOf ng.$rootScope.Scope\n       * @function\n       *\n       * @description\n       * Removes the current scope (and all of its children) from the parent scope. Removal implies\n       * that calls to {@link ng.$rootScope.Scope#$digest $digest()} will no longer\n       * propagate to the current scope and its children. Removal also implies that the current\n       * scope is eligible for garbage collection.\n       *\n       * The `$destroy()` is usually used by directives such as\n       * {@link ng.directive:ngRepeat ngRepeat} for managing the\n       * unrolling of the loop.\n       *\n       * Just before a scope is destroyed a `$destroy` event is broadcasted on this scope.\n       * Application code can register a `$destroy` event handler that will give it chance to\n       * perform any necessary cleanup.\n       *\n       * Note that, in AngularJS, there is also a `$destroy` jQuery event, which can be used to\n       * clean up DOM bindings before an element is removed from the DOM.\n       */\n      $destroy: function() {\n        // we can't destroy the root scope or a scope that has been already destroyed\n        if ($rootScope == this || this.$$destroyed) return;\n        var parent = this.$parent;\n\n        this.$broadcast('$destroy');\n        this.$$destroyed = true;\n\n        if (parent.$$childHead == this) parent.$$childHead = this.$$nextSibling;\n        if (parent.$$childTail == this) parent.$$childTail = this.$$prevSibling;\n        if (this.$$prevSibling) this.$$prevSibling.$$nextSibling = this.$$nextSibling;\n        if (this.$$nextSibling) this.$$nextSibling.$$prevSibling = this.$$prevSibling;\n\n        // This is bogus code that works around Chrome's GC leak\n        // see: https://github.com/angular/angular.js/issues/1313#issuecomment-10378451\n        this.$parent = this.$$nextSibling = this.$$prevSibling = this.$$childHead =\n            this.$$childTail = null;\n      },\n\n      /**\n       * @ngdoc function\n       * @name ng.$rootScope.Scope#$eval\n       * @methodOf ng.$rootScope.Scope\n       * @function\n       *\n       * @description\n       * Executes the `expression` on the current scope returning the result. Any exceptions in the\n       * expression are propagated (uncaught). This is useful when evaluating Angular expressions.\n       *\n       * # Example\n       * <pre>\n           var scope = ng.$rootScope.Scope();\n           scope.a = 1;\n           scope.b = 2;\n\n           expect(scope.$eval('a+b')).toEqual(3);\n           expect(scope.$eval(function(scope){ return scope.a + scope.b; })).toEqual(3);\n       * </pre>\n       *\n       * @param {(string|function())=} expression An angular expression to be executed.\n       *\n       *    - `string`: execute using the rules as defined in  {@link guide/expression expression}.\n       *    - `function(scope)`: execute the function with the current `scope` parameter.\n       *\n       * @returns {*} The result of evaluating the expression.\n       */\n      $eval: function(expr, locals) {\n        return $parse(expr)(this, locals);\n      },\n\n      /**\n       * @ngdoc function\n       * @name ng.$rootScope.Scope#$evalAsync\n       * @methodOf ng.$rootScope.Scope\n       * @function\n       *\n       * @description\n       * Executes the expression on the current scope at a later point in time.\n       *\n       * The `$evalAsync` makes no guarantees as to when the `expression` will be executed, only that:\n       *\n       *   - it will execute after the function that schedule the evaluation is done running (preferably before DOM rendering).\n       *   - at least one {@link ng.$rootScope.Scope#$digest $digest cycle} will be performed after `expression` execution.\n       *\n       * Any exceptions from the execution of the expression are forwarded to the\n       * {@link ng.$exceptionHandler $exceptionHandler} service.\n       *\n       * __Note:__ if this function is called outside of `$digest` cycle, a new $digest cycle will be scheduled.\n       * It is however encouraged to always call code that changes the model from withing an `$apply` call.\n       * That includes code evaluated via `$evalAsync`.\n       *\n       * @param {(string|function())=} expression An angular expression to be executed.\n       *\n       *    - `string`: execute using the rules as defined in  {@link guide/expression expression}.\n       *    - `function(scope)`: execute the function with the current `scope` parameter.\n       *\n       */\n      $evalAsync: function(expr) {\n        // if we are outside of an $digest loop and this is the first time we are scheduling async task also schedule\n        // async auto-flush\n        if (!$rootScope.$$phase && !$rootScope.$$asyncQueue.length) {\n          $browser.defer(function() {\n            if ($rootScope.$$asyncQueue.length) {\n              $rootScope.$digest();\n            }\n          });\n        }\n\n        this.$$asyncQueue.push(expr);\n      },\n\n      $$postDigest : function(expr) {\n        this.$$postDigestQueue.push(expr);\n      },\n\n      /**\n       * @ngdoc function\n       * @name ng.$rootScope.Scope#$apply\n       * @methodOf ng.$rootScope.Scope\n       * @function\n       *\n       * @description\n       * `$apply()` is used to execute an expression in angular from outside of the angular framework.\n       * (For example from browser DOM events, setTimeout, XHR or third party libraries).\n       * Because we are calling into the angular framework we need to perform proper scope life-cycle\n       * of {@link ng.$exceptionHandler exception handling},\n       * {@link ng.$rootScope.Scope#$digest executing watches}.\n       *\n       * ## Life cycle\n       *\n       * # Pseudo-Code of `$apply()`\n       * <pre>\n           function $apply(expr) {\n             try {\n               return $eval(expr);\n             } catch (e) {\n               $exceptionHandler(e);\n             } finally {\n               $root.$digest();\n             }\n           }\n       * </pre>\n       *\n       *\n       * Scope's `$apply()` method transitions through the following stages:\n       *\n       * 1. The {@link guide/expression expression} is executed using the\n       *    {@link ng.$rootScope.Scope#$eval $eval()} method.\n       * 2. Any exceptions from the execution of the expression are forwarded to the\n       *    {@link ng.$exceptionHandler $exceptionHandler} service.\n       * 3. The {@link ng.$rootScope.Scope#$watch watch} listeners are fired immediately after the expression\n       *    was executed using the {@link ng.$rootScope.Scope#$digest $digest()} method.\n       *\n       *\n       * @param {(string|function())=} exp An angular expression to be executed.\n       *\n       *    - `string`: execute using the rules as defined in {@link guide/expression expression}.\n       *    - `function(scope)`: execute the function with current `scope` parameter.\n       *\n       * @returns {*} The result of evaluating the expression.\n       */\n      $apply: function(expr) {\n        try {\n          beginPhase('$apply');\n          return this.$eval(expr);\n        } catch (e) {\n          $exceptionHandler(e);\n        } finally {\n          clearPhase();\n          try {\n            $rootScope.$digest();\n          } catch (e) {\n            $exceptionHandler(e);\n            throw e;\n          }\n        }\n      },\n\n      /**\n       * @ngdoc function\n       * @name ng.$rootScope.Scope#$on\n       * @methodOf ng.$rootScope.Scope\n       * @function\n       *\n       * @description\n       * Listens on events of a given type. See {@link ng.$rootScope.Scope#$emit $emit} for discussion of\n       * event life cycle.\n       *\n       * The event listener function format is: `function(event, args...)`. The `event` object\n       * passed into the listener has the following attributes:\n       *\n       *   - `targetScope` - `{Scope}`: the scope on which the event was `$emit`-ed or `$broadcast`-ed.\n       *   - `currentScope` - `{Scope}`: the current scope which is handling the event.\n       *   - `name` - `{string}`: Name of the event.\n       *   - `stopPropagation` - `{function=}`: calling `stopPropagation` function will cancel further event\n       *     propagation (available only for events that were `$emit`-ed).\n       *   - `preventDefault` - `{function}`: calling `preventDefault` sets `defaultPrevented` flag to true.\n       *   - `defaultPrevented` - `{boolean}`: true if `preventDefault` was called.\n       *\n       * @param {string} name Event name to listen on.\n       * @param {function(event, args...)} listener Function to call when the event is emitted.\n       * @returns {function()} Returns a deregistration function for this listener.\n       */\n      $on: function(name, listener) {\n        var namedListeners = this.$$listeners[name];\n        if (!namedListeners) {\n          this.$$listeners[name] = namedListeners = [];\n        }\n        namedListeners.push(listener);\n\n        return function() {\n          namedListeners[indexOf(namedListeners, listener)] = null;\n        };\n      },\n\n\n      /**\n       * @ngdoc function\n       * @name ng.$rootScope.Scope#$emit\n       * @methodOf ng.$rootScope.Scope\n       * @function\n       *\n       * @description\n       * Dispatches an event `name` upwards through the scope hierarchy notifying the\n       * registered {@link ng.$rootScope.Scope#$on} listeners.\n       *\n       * The event life cycle starts at the scope on which `$emit` was called. All\n       * {@link ng.$rootScope.Scope#$on listeners} listening for `name` event on this scope get notified.\n       * Afterwards, the event traverses upwards toward the root scope and calls all registered\n       * listeners along the way. The event will stop propagating if one of the listeners cancels it.\n       *\n       * Any exception emitted from the {@link ng.$rootScope.Scope#$on listeners} will be passed\n       * onto the {@link ng.$exceptionHandler $exceptionHandler} service.\n       *\n       * @param {string} name Event name to emit.\n       * @param {...*} args Optional set of arguments which will be passed onto the event listeners.\n       * @return {Object} Event object, see {@link ng.$rootScope.Scope#$on}\n       */\n      $emit: function(name, args) {\n        var empty = [],\n            namedListeners,\n            scope = this,\n            stopPropagation = false,\n            event = {\n              name: name,\n              targetScope: scope,\n              stopPropagation: function() {stopPropagation = true;},\n              preventDefault: function() {\n                event.defaultPrevented = true;\n              },\n              defaultPrevented: false\n            },\n            listenerArgs = concat([event], arguments, 1),\n            i, length;\n\n        do {\n          namedListeners = scope.$$listeners[name] || empty;\n          event.currentScope = scope;\n          for (i=0, length=namedListeners.length; i<length; i++) {\n\n            // if listeners were deregistered, defragment the array\n            if (!namedListeners[i]) {\n              namedListeners.splice(i, 1);\n              i--;\n              length--;\n              continue;\n            }\n            try {\n              namedListeners[i].apply(null, listenerArgs);\n              if (stopPropagation) return event;\n            } catch (e) {\n              $exceptionHandler(e);\n            }\n          }\n          //traverse upwards\n          scope = scope.$parent;\n        } while (scope);\n\n        return event;\n      },\n\n\n      /**\n       * @ngdoc function\n       * @name ng.$rootScope.Scope#$broadcast\n       * @methodOf ng.$rootScope.Scope\n       * @function\n       *\n       * @description\n       * Dispatches an event `name` downwards to all child scopes (and their children) notifying the\n       * registered {@link ng.$rootScope.Scope#$on} listeners.\n       *\n       * The event life cycle starts at the scope on which `$broadcast` was called. All\n       * {@link ng.$rootScope.Scope#$on listeners} listening for `name` event on this scope get notified.\n       * Afterwards, the event propagates to all direct and indirect scopes of the current scope and\n       * calls all registered listeners along the way. The event cannot be canceled.\n       *\n       * Any exception emitted from the {@link ng.$rootScope.Scope#$on listeners} will be passed\n       * onto the {@link ng.$exceptionHandler $exceptionHandler} service.\n       *\n       * @param {string} name Event name to broadcast.\n       * @param {...*} args Optional set of arguments which will be passed onto the event listeners.\n       * @return {Object} Event object, see {@link ng.$rootScope.Scope#$on}\n       */\n      $broadcast: function(name, args) {\n        var target = this,\n            current = target,\n            next = target,\n            event = {\n              name: name,\n              targetScope: target,\n              preventDefault: function() {\n                event.defaultPrevented = true;\n              },\n              defaultPrevented: false\n            },\n            listenerArgs = concat([event], arguments, 1),\n            listeners, i, length;\n\n        //down while you can, then up and next sibling or up and next sibling until back at root\n        do {\n          current = next;\n          event.currentScope = current;\n          listeners = current.$$listeners[name] || [];\n          for (i=0, length = listeners.length; i<length; i++) {\n            // if listeners were deregistered, defragment the array\n            if (!listeners[i]) {\n              listeners.splice(i, 1);\n              i--;\n              length--;\n              continue;\n            }\n\n            try {\n              listeners[i].apply(null, listenerArgs);\n            } catch(e) {\n              $exceptionHandler(e);\n            }\n          }\n\n          // Insanity Warning: scope depth-first traversal\n          // yes, this code is a bit crazy, but it works and we have tests to prove it!\n          // this piece should be kept in sync with the traversal in $digest\n          if (!(next = (current.$$childHead || (current !== target && current.$$nextSibling)))) {\n            while(current !== target && !(next = current.$$nextSibling)) {\n              current = current.$parent;\n            }\n          }\n        } while ((current = next));\n\n        return event;\n      }\n    };\n\n    var $rootScope = new Scope();\n\n    return $rootScope;\n\n\n    function beginPhase(phase) {\n      if ($rootScope.$$phase) {\n        throw $rootScopeMinErr('inprog', '{0} already in progress', $rootScope.$$phase);\n      }\n\n      $rootScope.$$phase = phase;\n    }\n\n    function clearPhase() {\n      $rootScope.$$phase = null;\n    }\n\n    function compileToFn(exp, name) {\n      var fn = $parse(exp);\n      assertArgFn(fn, name);\n      return fn;\n    }\n\n    /**\n     * function used as an initial value for watchers.\n     * because it's unique we can easily tell it apart from other values\n     */\n    function initWatchVal() {}\n  }];\n}\n\nvar $sceMinErr = minErr('$sce');\n\nvar SCE_CONTEXTS = {\n  HTML: 'html',\n  CSS: 'css',\n  URL: 'url',\n  // RESOURCE_URL is a subtype of URL used in contexts where a privileged resource is sourced from a\n  // url.  (e.g. ng-include, script src, templateUrl)\n  RESOURCE_URL: 'resourceUrl',\n  JS: 'js'\n};\n\n\n/**\n * @ngdoc service\n * @name ng.$sceDelegate\n * @function\n *\n * @description\n *\n * `$sceDelegate` is a service that is used by the `$sce` service to provide {@link ng.$sce Strict\n * Contextual Escaping (SCE)} services to AngularJS.\n *\n * Typically, you would configure or override the {@link ng.$sceDelegate $sceDelegate} instead of\n * the `$sce` service to customize the way Strict Contextual Escaping works in AngularJS.  This is\n * because, while the `$sce` provides numerous shorthand methods, etc., you really only need to\n * override 3 core functions (`trustAs`, `getTrusted` and `valueOf`) to replace the way things\n * work because `$sce` delegates to `$sceDelegate` for these operations.\n *\n * Refer {@link ng.$sceDelegateProvider $sceDelegateProvider} to configure this service.\n *\n * The default instance of `$sceDelegate` should work out of the box with little pain.  While you\n * can override it completely to change the behavior of `$sce`, the common case would\n * involve configuring the {@link ng.$sceDelegateProvider $sceDelegateProvider} instead by setting\n * your own whitelists and blacklists for trusting URLs used for loading AngularJS resources such as\n * templates.  Refer {@link ng.$sceDelegateProvider#resourceUrlWhitelist\n * $sceDelegateProvider.resourceUrlWhitelist} and {@link\n * ng.$sceDelegateProvider#resourceUrlBlacklist $sceDelegateProvider.resourceUrlBlacklist}\n */\n\n/**\n * @ngdoc object\n * @name ng.$sceDelegateProvider\n * @description\n *\n * The $sceDelegateProvider provider allows developers to configure the {@link ng.$sceDelegate\n * $sceDelegate} service.  This allows one to get/set the whitelists and blacklists used to ensure\n * that URLs used for sourcing Angular templates are safe.  Refer {@link\n * ng.$sceDelegateProvider#resourceUrlWhitelist $sceDelegateProvider.resourceUrlWhitelist} and\n * {@link ng.$sceDelegateProvider#resourceUrlBlacklist $sceDelegateProvider.resourceUrlBlacklist}\n *\n * Read more about {@link ng.$sce Strict Contextual Escaping (SCE)}.\n */\n\nfunction $SceDelegateProvider() {\n  this.SCE_CONTEXTS = SCE_CONTEXTS;\n\n  // Resource URLs can also be trusted by policy.\n  var resourceUrlWhitelist = ['self'],\n      resourceUrlBlacklist = [];\n\n  /**\n   * @ngdoc function\n   * @name ng.sceDelegateProvider#resourceUrlWhitelist\n   * @methodOf ng.$sceDelegateProvider\n   * @function\n   *\n   * @param {Array=} whitelist When provided, replaces the resourceUrlWhitelist with the value\n   *     provided.  This must be an array.\n   *\n   *     Each element of this array must either be a regex or the special string `'self'`.\n   *\n   *     When a regex is used, it is matched against the normalized / absolute URL of the resource\n   *     being tested.\n   *\n   *     The **special string** `'self'` can be used to match against all URLs of the same domain as the\n   *     application document with the same protocol (allows sourcing https resources from http documents.)\n   *\n   *     Please note that **an empty whitelist array will block all URLs**!\n   *\n   * @return {Array} the currently set whitelist array.\n   *\n   * The **default value** when no whitelist has been explicitly set is `['self']`.\n   *\n   * @description\n   * Sets/Gets the whitelist of trusted resource URLs.\n   */\n  this.resourceUrlWhitelist = function (value) {\n    if (arguments.length) {\n      resourceUrlWhitelist = value;\n    }\n    return resourceUrlWhitelist;\n  };\n\n  /**\n   * @ngdoc function\n   * @name ng.sceDelegateProvider#resourceUrlBlacklist\n   * @methodOf ng.$sceDelegateProvider\n   * @function\n   *\n   * @param {Array=} blacklist When provided, replaces the resourceUrlBlacklist with the value\n   *     provided.  This must be an array.\n   *\n   *     Each element of this array must either be a regex or the special string `'self'` (see\n   *     `resourceUrlWhitelist` for meaning - it's only really useful there.)\n   *\n   *     When a regex is used, it is matched against the normalized / absolute URL of the resource\n   *     being tested.\n   *\n   *     The typical usage for the blacklist is to **block [open redirects](http://cwe.mitre.org/data/definitions/601.html)**\n   *     served by your domain as these would otherwise be trusted but actually return content from the redirected\n   *     domain.\n   *\n   *     Finally, **the blacklist overrides the whitelist** and has the final say.\n   *\n   * @return {Array} the currently set blacklist array.\n   *\n   * The **default value** when no whitelist has been explicitly set is the empty array (i.e. there is\n   * no blacklist.)\n   *\n   * @description\n   * Sets/Gets the blacklist of trusted resource URLs.\n   */\n\n  this.resourceUrlBlacklist = function (value) {\n    if (arguments.length) {\n      resourceUrlBlacklist = value;\n    }\n    return resourceUrlBlacklist;\n  };\n\n  // Helper functions for matching resource urls by policy.\n  function isCompatibleProtocol(documentProtocol, resourceProtocol) {\n    return ((documentProtocol === resourceProtocol) ||\n            (documentProtocol === \"http:\" && resourceProtocol === \"https:\"));\n  }\n\n  this.$get = ['$log', '$document', '$injector', '$$urlUtils', function(\n                $log,   $document,   $injector,   $$urlUtils) {\n\n    var htmlSanitizer = function htmlSanitizer(html) {\n      throw $sceMinErr('unsafe', 'Attempting to use an unsafe value in a safe context.');\n    };\n\n    if ($injector.has('$sanitize')) {\n      htmlSanitizer = $injector.get('$sanitize');\n    }\n\n\n    function matchUrl(matcher, parsedUrl) {\n      if (matcher === 'self') {\n        return $$urlUtils.isSameOrigin(parsedUrl);\n      } else {\n        return !!parsedUrl.href.match(matcher);\n      }\n    }\n\n    function isResourceUrlAllowedByPolicy(url) {\n      var parsedUrl = $$urlUtils.resolve(url.toString(), true);\n      var i, n, allowed = false;\n      // Ensure that at least one item from the whitelist allows this url.\n      for (i = 0, n = resourceUrlWhitelist.length; i < n; i++) {\n        if (matchUrl(resourceUrlWhitelist[i], parsedUrl)) {\n          allowed = true;\n          break;\n        }\n      }\n      if (allowed) {\n        // Ensure that no item from the blacklist blocked this url.\n        for (i = 0, n = resourceUrlBlacklist.length; i < n; i++) {\n          if (matchUrl(resourceUrlBlacklist[i], parsedUrl)) {\n            allowed = false;\n            break;\n          }\n        }\n      }\n      return allowed;\n    }\n\n    function generateHolderType(base) {\n      var holderType = function TrustedValueHolderType(trustedValue) {\n        this.$$unwrapTrustedValue = function() {\n          return trustedValue;\n        };\n      };\n      if (base) {\n        holderType.prototype = new base();\n      }\n      holderType.prototype.valueOf = function sceValueOf() {\n        return this.$$unwrapTrustedValue();\n      }\n      holderType.prototype.toString = function sceToString() {\n        return this.$$unwrapTrustedValue().toString();\n      }\n      return holderType;\n    }\n\n    var trustedValueHolderBase = generateHolderType(),\n        byType = {};\n\n    byType[SCE_CONTEXTS.HTML] = generateHolderType(trustedValueHolderBase);\n    byType[SCE_CONTEXTS.CSS] = generateHolderType(trustedValueHolderBase);\n    byType[SCE_CONTEXTS.URL] = generateHolderType(trustedValueHolderBase);\n    byType[SCE_CONTEXTS.JS] = generateHolderType(trustedValueHolderBase);\n    byType[SCE_CONTEXTS.RESOURCE_URL] = generateHolderType(byType[SCE_CONTEXTS.URL]);\n\n    /**\n     * @ngdoc method\n     * @name ng.$sceDelegate#trustAs\n     * @methodOf ng.$sceDelegate\n     *\n     * @description\n     * Returns an object that is trusted by angular for use in specified strict\n     * contextual escaping contexts (such as ng-html-bind-unsafe, ng-include, any src\n     * attribute interpolation, any dom event binding attribute interpolation\n     * such as for onclick,  etc.) that uses the provided value.\n     * See {@link ng.$sce $sce} for enabling strict contextual escaping.\n     *\n     * @param {string} type The kind of context in which this value is safe for use.  e.g. url,\n     *   resourceUrl, html, js and css.\n     * @param {*} value The value that that should be considered trusted/safe.\n     * @returns {*} A value that can be used to stand in for the provided `value` in places\n     * where Angular expects a $sce.trustAs() return value.\n     */\n    function trustAs(type, trustedValue) {\n      var constructor = (byType.hasOwnProperty(type) ? byType[type] : null);\n      if (!constructor) {\n        throw $sceMinErr('icontext', 'Attempted to trust a value in invalid context. Context: {0}; Value: {1}',\n            type, trustedValue);\n      }\n      if (trustedValue === null || trustedValue === undefined || trustedValue === '') {\n        return trustedValue;\n      }\n      // All the current contexts in SCE_CONTEXTS happen to be strings.  In order to avoid trusting\n      // mutable objects, we ensure here that the value passed in is actually a string.\n      if (typeof trustedValue !== 'string') {\n        throw $sceMinErr('itype',\n            'Attempted to trust a non-string value in a content requiring a string: Context: {0}',\n            type);\n      }\n      return new constructor(trustedValue);\n    }\n\n    /**\n     * @ngdoc method\n     * @name ng.$sceDelegate#valueOf\n     * @methodOf ng.$sceDelegate\n     *\n     * @description\n     * If the passed parameter had been returned by a prior call to {@link ng.$sceDelegate#trustAs\n     * `$sceDelegate.trustAs`}, returns the value that had been passed to {@link\n     * ng.$sceDelegate#trustAs `$sceDelegate.trustAs`}.\n     *\n     * If the passed parameter is not a value that had been returned by {@link\n     * ng.$sceDelegate#trustAs `$sceDelegate.trustAs`}, returns it as-is.\n     *\n     * @param {*} value The result of a prior {@link ng.$sceDelegate#trustAs `$sceDelegate.trustAs`}\n     *      call or anything else.\n     * @returns {*} The value the was originally provided to {@link ng.$sceDelegate#trustAs\n     *     `$sceDelegate.trustAs`} if `value` is the result of such a call.  Otherwise, returns `value`\n     *     unchanged.\n     */\n    function valueOf(maybeTrusted) {\n      if (maybeTrusted instanceof trustedValueHolderBase) {\n        return maybeTrusted.$$unwrapTrustedValue();\n      } else {\n        return maybeTrusted;\n      }\n    }\n\n    /**\n     * @ngdoc method\n     * @name ng.$sceDelegate#getTrusted\n     * @methodOf ng.$sceDelegate\n     *\n     * @description\n     * Takes the result of a {@link ng.$sceDelegate#trustAs `$sceDelegate.trustAs`} call and returns the\n     * originally supplied value if the queried context type is a supertype of the created type.  If\n     * this condition isn't satisfied, throws an exception.\n     *\n     * @param {string} type The kind of context in which this value is to be used.\n     * @param {*} maybeTrusted The result of a prior {@link ng.$sceDelegate#trustAs\n     * `$sceDelegate.trustAs`} call.\n     * @returns {*} The value the was originally provided to {@link ng.$sceDelegate#trustAs\n     *     `$sceDelegate.trustAs`} if valid in this context.  Otherwise, throws an exception.\n     */\n    function getTrusted(type, maybeTrusted) {\n      if (maybeTrusted === null || maybeTrusted === undefined || maybeTrusted === '') {\n        return maybeTrusted;\n      }\n      var constructor = (byType.hasOwnProperty(type) ? byType[type] : null);\n      if (constructor && maybeTrusted instanceof constructor) {\n        return maybeTrusted.$$unwrapTrustedValue();\n      }\n      // If we get here, then we may only take one of two actions.\n      // 1. sanitize the value for the requested type, or\n      // 2. throw an exception.\n      if (type === SCE_CONTEXTS.RESOURCE_URL) {\n        if (isResourceUrlAllowedByPolicy(maybeTrusted)) {\n          return maybeTrusted;\n        } else {\n          throw $sceMinErr('insecurl',\n              'Blocked loading resource from url not allowed by $sceDelegate policy.  URL: {0}', maybeTrusted.toString());\n        }\n      } else if (type === SCE_CONTEXTS.HTML) {\n        return htmlSanitizer(maybeTrusted);\n      }\n      throw $sceMinErr('unsafe', 'Attempting to use an unsafe value in a safe context.');\n    }\n\n    return { trustAs: trustAs,\n             getTrusted: getTrusted,\n             valueOf: valueOf };\n  }];\n}\n\n\n/**\n * @ngdoc object\n * @name ng.$sceProvider\n * @description\n *\n * The $sceProvider provider allows developers to configure the {@link ng.$sce $sce} service.\n * -   enable/disable Strict Contextual Escaping (SCE) in a module\n * -   override the default implementation with a custom delegate\n *\n * Read more about {@link ng.$sce Strict Contextual Escaping (SCE)}.\n */\n\n/**\n * @ngdoc service\n * @name ng.$sce\n * @function\n *\n * @description\n *\n * `$sce` is a service that provides Strict Contextual Escaping services to AngularJS.\n *\n * # Strict Contextual Escaping\n *\n * Strict Contextual Escaping (SCE) is a mode in which AngularJS requires bindings in certain\n * contexts to result in a value that is marked as safe to use for that context One example of such\n * a context is binding arbitrary html controlled by the user via `ng-bind-html`.  We refer to these\n * contexts as privileged or SCE contexts.\n *\n * As of version 1.2, Angular ships with SCE enabled by default.\n *\n * Note:  When enabled (the default), IE8 in quirks mode is not supported.  In this mode, IE8 allows\n * one to execute arbitrary javascript by the use of the expression() syntax.  Refer\n * <http://blogs.msdn.com/b/ie/archive/2008/10/16/ending-expressions.aspx> to learn more about them.\n * You can ensure your document is in standards mode and not quirks mode by adding `<!doctype html>`\n * to the top of your HTML document.\n *\n * SCE assists in writing code in way that (a) is secure by default and (b) makes auditing for\n * security vulnerabilities such as XSS, clickjacking, etc. a lot easier.\n *\n * Here's an example of a binding in a privileged context:\n *\n * <pre class=\"prettyprint\">\n *     <input ng-model=\"userHtml\">\n *     <div ng-bind-html=\"{{userHtml}}\">\n * </pre>\n *\n * Notice that `ng-bind-html` is bound to `{{userHtml}}` controlled by the user.  With SCE\n * disabled, this application allows the user to render arbitrary HTML into the DIV.\n * In a more realistic example, one may be rendering user comments, blog articles, etc. via\n * bindings.  (HTML is just one example of a context where rendering user controlled input creates\n * security vulnerabilities.)\n *\n * For the case of HTML, you might use a library, either on the client side, or on the server side,\n * to sanitize unsafe HTML before binding to the value and rendering it in the document.\n *\n * How would you ensure that every place that used these types of bindings was bound to a value that\n * was sanitized by your library (or returned as safe for rendering by your server?)  How can you\n * ensure that you didn't accidentally delete the line that sanitized the value, or renamed some\n * properties/fields and forgot to update the binding to the sanitized value?\n *\n * To be secure by default, you want to ensure that any such bindings are disallowed unless you can\n * determine that something explicitly says it's safe to use a value for binding in that\n * context.  You can then audit your code (a simple grep would do) to ensure that this is only done\n * for those values that you can easily tell are safe - because they were received from your server,\n * sanitized by your library, etc.  You can organize your codebase to help with this - perhaps\n * allowing only the files in a specific directory to do this.  Ensuring that the internal API\n * exposed by that code doesn't markup arbitrary values as safe then becomes a more manageable task.\n *\n * In the case of AngularJS' SCE service, one uses {@link ng.$sce#trustAs $sce.trustAs} (and shorthand\n * methods such as {@link ng.$sce#trustAsHtml $sce.trustAsHtml}, etc.) to obtain values that will be\n * accepted by SCE / privileged contexts.\n *\n *\n * ## How does it work?\n *\n * In privileged contexts, directives and code will bind to the result of {@link ng.$sce#getTrusted\n * $sce.getTrusted(context, value)} rather than to the value directly.  Directives use {@link\n * ng.$sce#parse $sce.parseAs} rather than `$parse` to watch attribute bindings, which performs the\n * {@link ng.$sce#getTrusted $sce.getTrusted} behind the scenes on non-constant literals.\n *\n * As an example, {@link ng.directive:ngBindHtml ngBindHtml} uses {@link\n * ng.$sce#parseAsHtml $sce.parseAsHtml(binding expression)}.  Here's the actual code (slightly\n * simplified):\n *\n * <pre class=\"prettyprint\">\n *   var ngBindHtmlDirective = ['$sce', function($sce) {\n *     return function(scope, element, attr) {\n *       scope.$watch($sce.parseAsHtml(attr.ngBindHtml), function(value) {\n *         element.html(value || '');\n *       });\n *     };\n *   }];\n * </pre>\n *\n * ## Impact on loading templates\n *\n * This applies both to the {@link ng.directive:ngInclude `ng-include`} directive as well as\n * `templateUrl`'s specified by {@link guide/directive directives}.\n *\n * By default, Angular only loads templates from the same domain and protocol as the application\n * document.  This is done by calling {@link ng.$sce#getTrustedResourceUrl\n * $sce.getTrustedResourceUrl} on the template URL.  To load templates from other domains and/or\n * protocols, you may either either {@link ng.$sceDelegateProvider#resourceUrlWhitelist whitelist\n * them} or {@link ng.$sce#trustAsResourceUrl wrap it} into a trusted value.\n *\n * *Please note*:\n * The browser's\n * {@link https://code.google.com/p/browsersec/wiki/Part2#Same-origin_policy_for_XMLHttpRequest\n * Same Origin Policy} and {@link http://www.w3.org/TR/cors/ Cross-Origin Resource Sharing (CORS)}\n * policy apply in addition to this and may further restrict whether the template is successfully\n * loaded.  This means that without the right CORS policy, loading templates from a different domain\n * won't work on all browsers.  Also, loading templates from `file://` URL does not work on some\n * browsers.\n *\n * ## This feels like too much overhead for the developer?\n *\n * It's important to remember that SCE only applies to interpolation expressions.\n *\n * If your expressions are constant literals, they're automatically trusted and you don't need to\n * call `$sce.trustAs` on them.  (e.g.\n * `<div ng-html-bind-unsafe=\"'<b>implicitly trusted</b>'\"></div>`) just works.\n *\n * Additionally, `a[href]` and `img[src]` automatically sanitize their URLs and do not pass them\n * through {@link ng.$sce#getTrusted $sce.getTrusted}.  SCE doesn't play a role here.\n *\n * The included {@link ng.$sceDelegate $sceDelegate} comes with sane defaults to allow you to load\n * templates in `ng-include` from your application's domain without having to even know about SCE.\n * It blocks loading templates from other domains or loading templates over http from an https\n * served document.  You can change these by setting your own custom {@link\n * ng.$sceDelegateProvider#resourceUrlWhitelist whitelists} and {@link\n * ng.$sceDelegateProvider#resourceUrlBlacklist blacklists} for matching such URLs.\n *\n * This significantly reduces the overhead.  It is far easier to pay the small overhead and have an\n * application that's secure and can be audited to verify that with much more ease than bolting\n * security onto an application later.\n *\n * ## What trusted context types are supported?<a name=\"contexts\"></a>\n *\n * | Context             | Notes          |\n * |---------------------|----------------|\n * | `$sce.HTML`         | For HTML that's safe to source into the application.  The {@link ng.directive:ngBindHtml ngBindHtml} directive uses this context for bindings. |\n * | `$sce.CSS`          | For CSS that's safe to source into the application.  Currently unused.  Feel free to use it in your own directives. |\n * | `$sce.URL`          | For URLs that are safe to follow as links.  Currently unused (`<a href=` and `<img src=` sanitize their urls and don't consititute an SCE context. |\n * | `$sce.RESOURCE_URL` | For URLs that are not only safe to follow as links, but whose contens are also safe to include in your application.  Examples include `ng-include`, `src` / `ngSrc` bindings for tags other than `IMG` (e.g. `IFRAME`, `OBJECT`, etc.)  <br><br>Note that `$sce.RESOURCE_URL` makes a stronger statement about the URL than `$sce.URL` does and therefore contexts requiring values trusted for `$sce.RESOURCE_URL` can be used anywhere that values trusted for `$sce.URL` are required. |\n * | `$sce.JS`           | For JavaScript that is safe to execute in your application's context.  Currently unused.  Feel free to use it in your own directives. |\n *\n * ## Show me an example.\n *\n *\n *\n * @example\n <example module=\"mySceApp\">\n  <file name=\"index.html\">\n    <div ng-controller=\"myAppController as myCtrl\">\n      <i ng-bind-html=\"myCtrl.explicitlyTrustedHtml\" id=\"explicitlyTrustedHtml\"></i><br><br>\n      <b>User comments</b><br>\n      By default, HTML that isn't explicitly trusted (e.g. Alice's comment) is sanitized when $sanitize is available.  If $sanitize isn't available, this results in an error instead of an exploit.\n      <div class=\"well\">\n        <div ng-repeat=\"userComment in myCtrl.userComments\">\n          <b>{{userComment.name}}</b>:\n          <span ng-bind-html=\"userComment.htmlComment\" class=\"htmlComment\"></span>\n          <br>\n        </div>\n      </div>\n    </div>\n  </file>\n\n  <file name=\"script.js\">\n    var mySceApp = angular.module('mySceApp', ['ngSanitize']);\n\n    mySceApp.controller(\"myAppController\", function myAppController($http, $templateCache, $sce) {\n      var self = this;\n      $http.get(\"test_data.json\", {cache: $templateCache}).success(function(userComments) {\n        self.userComments = userComments;\n      });\n      self.explicitlyTrustedHtml = $sce.trustAsHtml(\n          '<span onmouseover=\"this.textContent=&quot;Explicitly trusted HTML bypasses ' +\n          'sanitization.&quot;\">Hover over this text.</span>');\n    });\n  </file>\n\n  <file name=\"test_data.json\">\n    [\n      { \"name\": \"Alice\",\n        \"htmlComment\": \"<span onmouseover='this.textContent=\\\"PWN3D!\\\"'>Is <i>anyone</i> reading this?</span>\"\n      },\n      { \"name\": \"Bob\",\n        \"htmlComment\": \"<i>Yes!</i>  Am I the only other one?\"\n      }\n    ]\n  </file>\n\n  <file name=\"scenario.js\">\n    describe('SCE doc demo', function() {\n      it('should sanitize untrusted values', function() {\n        expect(element('.htmlComment').html()).toBe('<span>Is <i>anyone</i> reading this?</span>');\n      });\n      it('should NOT sanitize explicitly trusted values', function() {\n        expect(element('#explicitlyTrustedHtml').html()).toBe(\n            '<span onmouseover=\"this.textContent=&quot;Explicitly trusted HTML bypasses ' +\n            'sanitization.&quot;\">Hover over this text.</span>');\n      });\n    });\n  </file>\n </example>\n *\n *\n *\n * ## Can I disable SCE completely?\n *\n * Yes, you can.  However, this is strongly discouraged.  SCE gives you a lot of security benefits\n * for little coding overhead.  It will be much harder to take an SCE disabled application and\n * either secure it on your own or enable SCE at a later stage.  It might make sense to disable SCE\n * for cases where you have a lot of existing code that was written before SCE was introduced and\n * you're migrating them a module at a time.\n *\n * That said, here's how you can completely disable SCE:\n *\n * <pre class=\"prettyprint\">\n *   angular.module('myAppWithSceDisabledmyApp', []).config(function($sceProvider) {\n *     // Completely disable SCE.  For demonstration purposes only!\n *     // Do not use in new projects.\n *     $sceProvider.enabled(false);\n *   });\n * </pre>\n *\n */\n\nfunction $SceProvider() {\n  var enabled = true;\n\n  /**\n   * @ngdoc function\n   * @name ng.sceProvider#enabled\n   * @methodOf ng.$sceProvider\n   * @function\n   *\n   * @param {boolean=} value If provided, then enables/disables SCE.\n   * @return {boolean} true if SCE is enabled, false otherwise.\n   *\n   * @description\n   * Enables/disables SCE and returns the current value.\n   */\n  this.enabled = function (value) {\n    if (arguments.length) {\n      enabled = !!value;\n    }\n    return enabled;\n  };\n\n\n  /* Design notes on the default implementation for SCE.\n   *\n   * The API contract for the SCE delegate\n   * -------------------------------------\n   * The SCE delegate object must provide the following 3 methods:\n   *\n   * - trustAs(contextEnum, value)\n   *     This method is used to tell the SCE service that the provided value is OK to use in the\n   *     contexts specified by contextEnum.  It must return an object that will be accepted by\n   *     getTrusted() for a compatible contextEnum and return this value.\n   *\n   * - valueOf(value)\n   *     For values that were not produced by trustAs(), return them as is.  For values that were\n   *     produced by trustAs(), return the corresponding input value to trustAs.  Basically, if\n   *     trustAs is wrapping the given values into some type, this operation unwraps it when given\n   *     such a value.\n   *\n   * - getTrusted(contextEnum, value)\n   *     This function should return the a value that is safe to use in the context specified by\n   *     contextEnum or throw and exception otherwise.\n   *\n   * NOTE: This contract deliberately does NOT state that values returned by trustAs() must be opaque\n   * or wrapped in some holder object.  That happens to be an implementation detail.  For instance,\n   * an implementation could maintain a registry of all trusted objects by context.  In such a case,\n   * trustAs() would return the same object that was passed in.  getTrusted() would return the same\n   * object passed in if it was found in the registry under a compatible context or throw an\n   * exception otherwise.  An implementation might only wrap values some of the time based on\n   * some criteria.  getTrusted() might return a value and not throw an exception for special\n   * constants or objects even if not wrapped.  All such implementations fulfill this contract.\n   *\n   *\n   * A note on the inheritance model for SCE contexts\n   * ------------------------------------------------\n   * I've used inheritance and made RESOURCE_URL wrapped types a subtype of URL wrapped types.  This\n   * is purely an implementation details.\n   *\n   * The contract is simply this:\n   *\n   *     getTrusted($sce.RESOURCE_URL, value) succeeding implies that getTrusted($sce.URL, value)\n   *     will also succeed.\n   *\n   * Inheritance happens to capture this in a natural way.  In some future, we\n   * may not use inheritance anymore.  That is OK because no code outside of\n   * sce.js and sceSpecs.js would need to be aware of this detail.\n   */\n\n  this.$get = ['$parse', '$document', '$sceDelegate', function(\n                $parse,   $document,   $sceDelegate) {\n    // Prereq: Ensure that we're not running in IE8 quirks mode.  In that mode, IE allows\n    // the \"expression(javascript expression)\" syntax which is insecure.\n    if (enabled && msie) {\n      var documentMode = $document[0].documentMode;\n      if (documentMode !== undefined && documentMode < 8) {\n        throw $sceMinErr('iequirks',\n          'Strict Contextual Escaping does not support Internet Explorer version < 9 in quirks ' +\n          'mode.  You can fix this by adding the text <!doctype html> to the top of your HTML ' +\n          'document.  See http://docs.angularjs.org/api/ng.$sce for more information.');\n      }\n    }\n\n    var sce = copy(SCE_CONTEXTS);\n\n    /**\n     * @ngdoc function\n     * @name ng.sce#isEnabled\n     * @methodOf ng.$sce\n     * @function\n     *\n     * @return {Boolean} true if SCE is enabled, false otherwise.  If you want to set the value, you\n     * have to do it at module config time on {@link ng.$sceProvider $sceProvider}.\n     *\n     * @description\n     * Returns a boolean indicating if SCE is enabled.\n     */\n    sce.isEnabled = function () {\n      return enabled;\n    };\n    sce.trustAs = $sceDelegate.trustAs;\n    sce.getTrusted = $sceDelegate.getTrusted;\n    sce.valueOf = $sceDelegate.valueOf;\n\n    if (!enabled) {\n      sce.trustAs = sce.getTrusted = function(type, value) { return value; },\n      sce.valueOf = identity\n    }\n\n    /**\n     * @ngdoc method\n     * @name ng.$sce#parse\n     * @methodOf ng.$sce\n     *\n     * @description\n     * Converts Angular {@link guide/expression expression} into a function.  This is like {@link\n     * ng.$parse $parse} and is identical when the expression is a literal constant.  Otherwise, it\n     * wraps the expression in a call to {@link ng.$sce#getTrusted $sce.getTrusted(*type*,\n     * *result*)}\n     *\n     * @param {string} type The kind of SCE context in which this result will be used.\n     * @param {string} expression String expression to compile.\n     * @returns {function(context, locals)} a function which represents the compiled expression:\n     *\n     *    * `context` – `{object}` – an object against which any expressions embedded in the strings\n     *      are evaluated against (typically a scope object).\n     *    * `locals` – `{object=}` – local variables context object, useful for overriding values in\n     *      `context`.\n     */\n    sce.parseAs = function sceParseAs(type, expr) {\n      var parsed = $parse(expr);\n      if (parsed.literal && parsed.constant) {\n        return parsed;\n      } else {\n        return function sceParseAsTrusted(self, locals) {\n          return sce.getTrusted(type, parsed(self, locals));\n        }\n      }\n    };\n\n    /**\n     * @ngdoc method\n     * @name ng.$sce#trustAs\n     * @methodOf ng.$sce\n     *\n     * @description\n     * Delegates to {@link ng.$sceDelegate#trustAs `$sceDelegate.trustAs`}.  As such, returns an object\n     * that is trusted by angular for use in specified strict contextual escaping contexts (such as\n     * ng-html-bind-unsafe, ng-include, any src attribute interpolation, any dom event binding\n     * attribute interpolation such as for onclick,  etc.) that uses the provided value.  See *\n     * {@link ng.$sce $sce} for enabling strict contextual escaping.\n     *\n     * @param {string} type The kind of context in which this value is safe for use.  e.g. url,\n     *   resource_url, html, js and css.\n     * @param {*} value The value that that should be considered trusted/safe.\n     * @returns {*} A value that can be used to stand in for the provided `value` in places\n     * where Angular expects a $sce.trustAs() return value.\n     */\n\n    /**\n     * @ngdoc method\n     * @name ng.$sce#trustAsHtml\n     * @methodOf ng.$sce\n     *\n     * @description\n     * Shorthand method.  `$sce.trustAsHtml(value)` → {@link ng.$sceDelegate#trustAs `$sceDelegate.trustAs($sce.HTML, value)`}\n     *\n     * @param {*} value The value to trustAs.\n     * @returns {*} An object that can be passed to {@link ng.$sce#getTrustedHtml\n     *     $sce.getTrustedHtml(value)} to obtain the original value.  (privileged directives\n     *     only accept expressions that are either literal constants or are the\n     *     return value of {@link ng.$sce#trustAs $sce.trustAs}.)\n     */\n\n    /**\n     * @ngdoc method\n     * @name ng.$sce#trustAsUrl\n     * @methodOf ng.$sce\n     *\n     * @description\n     * Shorthand method.  `$sce.trustAsUrl(value)` → {@link ng.$sceDelegate#trustAs `$sceDelegate.trustAs($sce.URL, value)`}\n     *\n     * @param {*} value The value to trustAs.\n     * @returns {*} An object that can be passed to {@link ng.$sce#getTrustedUrl\n     *     $sce.getTrustedUrl(value)} to obtain the original value.  (privileged directives\n     *     only accept expressions that are either literal constants or are the\n     *     return value of {@link ng.$sce#trustAs $sce.trustAs}.)\n     */\n\n    /**\n     * @ngdoc method\n     * @name ng.$sce#trustAsResourceUrl\n     * @methodOf ng.$sce\n     *\n     * @description\n     * Shorthand method.  `$sce.trustAsResourceUrl(value)` → {@link ng.$sceDelegate#trustAs `$sceDelegate.trustAs($sce.RESOURCE_URL, value)`}\n     *\n     * @param {*} value The value to trustAs.\n     * @returns {*} An object that can be passed to {@link ng.$sce#getTrustedResourceUrl\n     *     $sce.getTrustedResourceUrl(value)} to obtain the original value.  (privileged directives\n     *     only accept expressions that are either literal constants or are the return\n     *     value of {@link ng.$sce#trustAs $sce.trustAs}.)\n     */\n\n    /**\n     * @ngdoc method\n     * @name ng.$sce#trustAsJs\n     * @methodOf ng.$sce\n     *\n     * @description\n     * Shorthand method.  `$sce.trustAsJs(value)` → {@link ng.$sceDelegate#trustAs `$sceDelegate.trustAs($sce.JS, value)`}\n     *\n     * @param {*} value The value to trustAs.\n     * @returns {*} An object that can be passed to {@link ng.$sce#getTrustedJs\n     *     $sce.getTrustedJs(value)} to obtain the original value.  (privileged directives\n     *     only accept expressions that are either literal constants or are the\n     *     return value of {@link ng.$sce#trustAs $sce.trustAs}.)\n     */\n\n    /**\n     * @ngdoc method\n     * @name ng.$sce#getTrusted\n     * @methodOf ng.$sce\n     *\n     * @description\n     * Delegates to {@link ng.$sceDelegate#getTrusted `$sceDelegate.getTrusted`}.  As such, takes\n     * the result of a {@link ng.$sce#trustAs `$sce.trustAs`}() call and returns the originally supplied\n     * value if the queried context type is a supertype of the created type.  If this condition\n     * isn't satisfied, throws an exception.\n     *\n     * @param {string} type The kind of context in which this value is to be used.\n     * @param {*} maybeTrusted The result of a prior {@link ng.$sce#trustAs `$sce.trustAs`} call.\n     * @returns {*} The value the was originally provided to {@link ng.$sce#trustAs `$sce.trustAs`} if\n     *     valid in this context.  Otherwise, throws an exception.\n     */\n\n    /**\n     * @ngdoc method\n     * @name ng.$sce#getTrustedHtml\n     * @methodOf ng.$sce\n     *\n     * @description\n     * Shorthand method.  `$sce.getTrustedHtml(value)` → {@link ng.$sceDelegate#getTrusted `$sceDelegate.getTrusted($sce.HTML, value)`}\n     *\n     * @param {*} value The value to pass to `$sce.getTrusted`.\n     * @returns {*} The return value of `$sce.getTrusted($sce.HTML, value)`\n     */\n\n    /**\n     * @ngdoc method\n     * @name ng.$sce#getTrustedCss\n     * @methodOf ng.$sce\n     *\n     * @description\n     * Shorthand method.  `$sce.getTrustedCss(value)` → {@link ng.$sceDelegate#getTrusted `$sceDelegate.getTrusted($sce.CSS, value)`}\n     *\n     * @param {*} value The value to pass to `$sce.getTrusted`.\n     * @returns {*} The return value of `$sce.getTrusted($sce.CSS, value)`\n     */\n\n    /**\n     * @ngdoc method\n     * @name ng.$sce#getTrustedUrl\n     * @methodOf ng.$sce\n     *\n     * @description\n     * Shorthand method.  `$sce.getTrustedUrl(value)` → {@link ng.$sceDelegate#getTrusted `$sceDelegate.getTrusted($sce.URL, value)`}\n     *\n     * @param {*} value The value to pass to `$sce.getTrusted`.\n     * @returns {*} The return value of `$sce.getTrusted($sce.URL, value)`\n     */\n\n    /**\n     * @ngdoc method\n     * @name ng.$sce#getTrustedResourceUrl\n     * @methodOf ng.$sce\n     *\n     * @description\n     * Shorthand method.  `$sce.getTrustedResourceUrl(value)` → {@link ng.$sceDelegate#getTrusted `$sceDelegate.getTrusted($sce.RESOURCE_URL, value)`}\n     *\n     * @param {*} value The value to pass to `$sceDelegate.getTrusted`.\n     * @returns {*} The return value of `$sce.getTrusted($sce.RESOURCE_URL, value)`\n     */\n\n    /**\n     * @ngdoc method\n     * @name ng.$sce#getTrustedJs\n     * @methodOf ng.$sce\n     *\n     * @description\n     * Shorthand method.  `$sce.getTrustedJs(value)` → {@link ng.$sceDelegate#getTrusted `$sceDelegate.getTrusted($sce.JS, value)`}\n     *\n     * @param {*} value The value to pass to `$sce.getTrusted`.\n     * @returns {*} The return value of `$sce.getTrusted($sce.JS, value)`\n     */\n\n    /**\n     * @ngdoc method\n     * @name ng.$sce#parseAsHtml\n     * @methodOf ng.$sce\n     *\n     * @description\n     * Shorthand method.  `$sce.parseAsHtml(expression string)` → {@link ng.$sce#parse `$sce.parseAs($sce.HTML, value)`}\n     *\n     * @param {string} expression String expression to compile.\n     * @returns {function(context, locals)} a function which represents the compiled expression:\n     *\n     *    * `context` – `{object}` – an object against which any expressions embedded in the strings\n     *      are evaluated against (typically a scope object).\n     *    * `locals` – `{object=}` – local variables context object, useful for overriding values in\n     *      `context`.\n     */\n\n    /**\n     * @ngdoc method\n     * @name ng.$sce#parseAsCss\n     * @methodOf ng.$sce\n     *\n     * @description\n     * Shorthand method.  `$sce.parseAsCss(value)` → {@link ng.$sce#parse `$sce.parseAs($sce.CSS, value)`}\n     *\n     * @param {string} expression String expression to compile.\n     * @returns {function(context, locals)} a function which represents the compiled expression:\n     *\n     *    * `context` – `{object}` – an object against which any expressions embedded in the strings\n     *      are evaluated against (typically a scope object).\n     *    * `locals` – `{object=}` – local variables context object, useful for overriding values in\n     *      `context`.\n     */\n\n    /**\n     * @ngdoc method\n     * @name ng.$sce#parseAsUrl\n     * @methodOf ng.$sce\n     *\n     * @description\n     * Shorthand method.  `$sce.parseAsUrl(value)` → {@link ng.$sce#parse `$sce.parseAs($sce.URL, value)`}\n     *\n     * @param {string} expression String expression to compile.\n     * @returns {function(context, locals)} a function which represents the compiled expression:\n     *\n     *    * `context` – `{object}` – an object against which any expressions embedded in the strings\n     *      are evaluated against (typically a scope object).\n     *    * `locals` – `{object=}` – local variables context object, useful for overriding values in\n     *      `context`.\n     */\n\n    /**\n     * @ngdoc method\n     * @name ng.$sce#parseAsResourceUrl\n     * @methodOf ng.$sce\n     *\n     * @description\n     * Shorthand method.  `$sce.parseAsResourceUrl(value)` → {@link ng.$sce#parse `$sce.parseAs($sce.RESOURCE_URL, value)`}\n     *\n     * @param {string} expression String expression to compile.\n     * @returns {function(context, locals)} a function which represents the compiled expression:\n     *\n     *    * `context` – `{object}` – an object against which any expressions embedded in the strings\n     *      are evaluated against (typically a scope object).\n     *    * `locals` – `{object=}` – local variables context object, useful for overriding values in\n     *      `context`.\n     */\n\n    /**\n     * @ngdoc method\n     * @name ng.$sce#parseAsJs\n     * @methodOf ng.$sce\n     *\n     * @description\n     * Shorthand method.  `$sce.parseAsJs(value)` → {@link ng.$sce#parse `$sce.parseAs($sce.JS, value)`}\n     *\n     * @param {string} expression String expression to compile.\n     * @returns {function(context, locals)} a function which represents the compiled expression:\n     *\n     *    * `context` – `{object}` – an object against which any expressions embedded in the strings\n     *      are evaluated against (typically a scope object).\n     *    * `locals` – `{object=}` – local variables context object, useful for overriding values in\n     *      `context`.\n     */\n\n    // Shorthand delegations.\n    var parse = sce.parseAs,\n        getTrusted = sce.getTrusted,\n        trustAs = sce.trustAs;\n\n    angular.forEach(SCE_CONTEXTS, function (enumValue, name) {\n      var lName = lowercase(name);\n      sce[camelCase(\"parse_as_\" + lName)] = function (expr) {\n        return parse(enumValue, expr);\n      }\n      sce[camelCase(\"get_trusted_\" + lName)] = function (value) {\n        return getTrusted(enumValue, value);\n      }\n      sce[camelCase(\"trust_as_\" + lName)] = function (value) {\n        return trustAs(enumValue, value);\n      }\n    });\n\n    return sce;\n  }];\n}\n\n/**\n * !!! This is an undocumented \"private\" service !!!\n *\n * @name ng.$sniffer\n * @requires $window\n * @requires $document\n *\n * @property {boolean} history Does the browser support html5 history api ?\n * @property {boolean} hashchange Does the browser support hashchange event ?\n * @property {boolean} transitions Does the browser support CSS transition events ?\n * @property {boolean} animations Does the browser support CSS animation events ?\n *\n * @description\n * This is very simple implementation of testing browser's features.\n */\nfunction $SnifferProvider() {\n  this.$get = ['$window', '$document', function($window, $document) {\n    var eventSupport = {},\n        android = int((/android (\\d+)/.exec(lowercase(($window.navigator || {}).userAgent)) || [])[1]),\n        boxee = /Boxee/i.test(($window.navigator || {}).userAgent),\n        document = $document[0] || {},\n        vendorPrefix,\n        vendorRegex = /^(Moz|webkit|O|ms)(?=[A-Z])/,\n        bodyStyle = document.body && document.body.style,\n        transitions = false,\n        animations = false,\n        match;\n\n    if (bodyStyle) {\n      for(var prop in bodyStyle) {\n        if(match = vendorRegex.exec(prop)) {\n          vendorPrefix = match[0];\n          vendorPrefix = vendorPrefix.substr(0, 1).toUpperCase() + vendorPrefix.substr(1);\n          break;\n        }\n      }\n\n      if(!vendorPrefix) {\n        vendorPrefix = ('WebkitOpacity' in bodyStyle) && 'webkit';\n      }\n\n      transitions = !!(('transition' in bodyStyle) || (vendorPrefix + 'Transition' in bodyStyle));\n      animations  = !!(('animation' in bodyStyle) || (vendorPrefix + 'Animation' in bodyStyle));\n\n      if (android && (!transitions||!animations)) {\n        transitions = isString(document.body.style.webkitTransition);\n        animations = isString(document.body.style.webkitAnimation);\n      }\n    }\n\n\n    return {\n      // Android has history.pushState, but it does not update location correctly\n      // so let's not use the history API at all.\n      // http://code.google.com/p/android/issues/detail?id=17471\n      // https://github.com/angular/angular.js/issues/904\n\n      // older webit browser (533.9) on Boxee box has exactly the same problem as Android has\n      // so let's not use the history API also\n      history: !!($window.history && $window.history.pushState && !(android < 4) && !boxee),\n      hashchange: 'onhashchange' in $window &&\n                  // IE8 compatible mode lies\n                  (!document.documentMode || document.documentMode > 7),\n      hasEvent: function(event) {\n        // IE9 implements 'input' event it's so fubared that we rather pretend that it doesn't have\n        // it. In particular the event is not fired when backspace or delete key are pressed or\n        // when cut operation is performed.\n        if (event == 'input' && msie == 9) return false;\n\n        if (isUndefined(eventSupport[event])) {\n          var divElm = document.createElement('div');\n          eventSupport[event] = 'on' + event in divElm;\n        }\n\n        return eventSupport[event];\n      },\n      csp: document.securityPolicy ? document.securityPolicy.isActive : false,\n      vendorPrefix: vendorPrefix,\n      transitions : transitions,\n      animations : animations\n    };\n  }];\n}\n\nfunction $TimeoutProvider() {\n  this.$get = ['$rootScope', '$browser', '$q', '$exceptionHandler',\n       function($rootScope,   $browser,   $q,   $exceptionHandler) {\n    var deferreds = {};\n\n\n     /**\n      * @ngdoc function\n      * @name ng.$timeout\n      * @requires $browser\n      *\n      * @description\n      * Angular's wrapper for `window.setTimeout`. The `fn` function is wrapped into a try/catch\n      * block and delegates any exceptions to\n      * {@link ng.$exceptionHandler $exceptionHandler} service.\n      *\n      * The return value of registering a timeout function is a promise, which will be resolved when\n      * the timeout is reached and the timeout function is executed.\n      *\n      * To cancel a timeout request, call `$timeout.cancel(promise)`.\n      *\n      * In tests you can use {@link ngMock.$timeout `$timeout.flush()`} to\n      * synchronously flush the queue of deferred functions.\n      *\n      * @param {function()} fn A function, whose execution should be delayed.\n      * @param {number=} [delay=0] Delay in milliseconds.\n      * @param {boolean=} [invokeApply=true] If set to `false` skips model dirty checking, otherwise\n      *   will invoke `fn` within the {@link ng.$rootScope.Scope#$apply $apply} block.\n      * @returns {Promise} Promise that will be resolved when the timeout is reached. The value this\n      *   promise will be resolved with is the return value of the `fn` function.\n      */\n    function timeout(fn, delay, invokeApply) {\n      var deferred = $q.defer(),\n          promise = deferred.promise,\n          skipApply = (isDefined(invokeApply) && !invokeApply),\n          timeoutId;\n\n      timeoutId = $browser.defer(function() {\n        try {\n          deferred.resolve(fn());\n        } catch(e) {\n          deferred.reject(e);\n          $exceptionHandler(e);\n        }\n        finally {\n          delete deferreds[promise.$$timeoutId];\n        }\n\n        if (!skipApply) $rootScope.$apply();\n      }, delay);\n\n      promise.$$timeoutId = timeoutId;\n      deferreds[timeoutId] = deferred;\n\n      return promise;\n    }\n\n\n     /**\n      * @ngdoc function\n      * @name ng.$timeout#cancel\n      * @methodOf ng.$timeout\n      *\n      * @description\n      * Cancels a task associated with the `promise`. As a result of this, the promise will be\n      * resolved with a rejection.\n      *\n      * @param {Promise=} promise Promise returned by the `$timeout` function.\n      * @returns {boolean} Returns `true` if the task hasn't executed yet and was successfully\n      *   canceled.\n      */\n    timeout.cancel = function(promise) {\n      if (promise && promise.$$timeoutId in deferreds) {\n        deferreds[promise.$$timeoutId].reject('canceled');\n        delete deferreds[promise.$$timeoutId];\n        return $browser.defer.cancel(promise.$$timeoutId);\n      }\n      return false;\n    };\n\n    return timeout;\n  }];\n}\n\nfunction $$UrlUtilsProvider() {\n  this.$get = [function() {\n    var urlParsingNode = document.createElement(\"a\"),\n        // NOTE:  The usage of window and document instead of $window and $document here is\n        // deliberate.  This service depends on the specific behavior of anchor nodes created by the\n        // browser (resolving and parsing URLs) that is unlikely to be provided by mock objects and\n        // cause us to break tests.  In addition, when the browser resolves a URL for XHR, it\n        // doesn't know about mocked locations and resolves URLs to the real document - which is\n        // exactly the behavior needed here.  There is little value is mocking these our for this\n        // service.\n        originUrl = resolve(window.location.href, true);\n\n    /**\n     * @description\n     * Normalizes and optionally parses a URL.\n     *\n     * NOTE:  This is a private service.  The API is subject to change unpredictably in any commit.\n     *\n     * Implementation Notes for non-IE browsers\n     * ----------------------------------------\n     * Assigning a URL to the href property of an anchor DOM node, even one attached to the DOM,\n     * results both in the normalizing and parsing of the URL.  Normalizing means that a relative\n     * URL will be resolved into an absolute URL in the context of the application document.\n     * Parsing means that the anchor node's host, hostname, protocol, port, pathname and related\n     * properties are all populated to reflect the normalized URL.  This approach has wide\n     * compatibility - Safari 1+, Mozilla 1+, Opera 7+,e etc.  See\n     * http://www.aptana.com/reference/html/api/HTMLAnchorElement.html\n     *\n     * Implementation Notes for IE\n     * ---------------------------\n     * IE >= 8 and <= 10 normalizes the URL when assigned to the anchor node similar to the other\n     * browsers.  However, the parsed components will not be set if the URL assigned did not specify\n     * them.  (e.g. if you assign a.href = \"foo\", then a.protocol, a.host, etc. will be empty.)  We\n     * work around that by performing the parsing in a 2nd step by taking a previously normalized\n     * URL (e.g. by assining to a.href) and assigning it a.href again.  This correctly populates the\n     * properties such as protocol, hostname, port, etc.\n     *\n     * IE7 does not normalize the URL when assigned to an anchor node.  (Apparently, it does, if one\n     * uses the inner HTML approach to assign the URL as part of an HTML snippet -\n     * http://stackoverflow.com/a/472729)  However, setting img[src] does normalize the URL.\n     * Unfortunately, setting img[src] to something like \"javascript:foo\" on IE throws an exception.\n     * Since the primary usage for normalizing URLs is to sanitize such URLs, we can't use that\n     * method and IE < 8 is unsupported.\n     *\n     * References:\n     *   http://developer.mozilla.org/en-US/docs/Web/API/HTMLAnchorElement\n     *   http://www.aptana.com/reference/html/api/HTMLAnchorElement.html\n     *   http://url.spec.whatwg.org/#urlutils\n     *   https://github.com/angular/angular.js/pull/2902\n     *   http://james.padolsey.com/javascript/parsing-urls-with-the-dom/\n     *\n     * @param {string} url The URL to be parsed.\n     * @param {boolean=} parse When true, returns an object for the parsed URL.  Otherwise, returns\n     *   a single string that is the normalized URL.\n     * @returns {object|string} When parse is true, returns the normalized URL as a string.\n     * Otherwise, returns an object with the following members.\n     *\n     *   | member name   | Description    |\n     *   |---------------|----------------|\n     *   | href          | A normalized version of the provided URL if it was not an absolute URL |\n     *   | protocol      | The protocol including the trailing colon                              |\n     *   | host          | The host and port (if the port is non-default) of the normalizedUrl    |\n     *\n     * These fields from the UrlUtils interface are currently not needed and hence not returned.\n     *\n     *   | member name   | Description    |\n     *   |---------------|----------------|\n     *   | hostname      | The host without the port of the normalizedUrl                         |\n     *   | pathname      | The path following the host in the normalizedUrl                       |\n     *   | hash          | The URL hash if present                                                |\n     *   | search        | The query string                                                       |\n     *\n     */\n    function resolve(url, parse) {\n      var href = url;\n      if (msie <= 11) {\n        // Normalize before parse.  Refer Implementation Notes on why this is\n        // done in two steps on IE.\n        urlParsingNode.setAttribute(\"href\", href);\n        href = urlParsingNode.href;\n      }\n      urlParsingNode.setAttribute('href', href);\n\n      if (!parse) {\n        return urlParsingNode.href;\n      }\n      // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils\n      return {\n        href: urlParsingNode.href,\n        protocol: urlParsingNode.protocol,\n        host: urlParsingNode.host\n        // Currently unused and hence commented out.\n        // hostname: urlParsingNode.hostname,\n        // port: urlParsingNode.port,\n        // pathname: urlParsingNode.pathname,\n        // hash: urlParsingNode.hash,\n        // search: urlParsingNode.search\n      };\n    }\n\n    return {\n      resolve: resolve,\n      /**\n       * Parse a request URL and determine whether this is a same-origin request as the application document.\n       *\n       * @param {string|object} requestUrl The url of the request as a string that will be resolved\n       * or a parsed URL object.\n       * @returns {boolean} Whether the request is for the same origin as the application document.\n       */\n      isSameOrigin: function isSameOrigin(requestUrl) {\n        var parsed = (typeof requestUrl === 'string') ? resolve(requestUrl, true) : requestUrl;\n        return (parsed.protocol === originUrl.protocol &&\n                parsed.host === originUrl.host);\n      }\n    };\n  }];\n}\n\n/**\n * @ngdoc object\n * @name ng.$window\n *\n * @description\n * A reference to the browser's `window` object. While `window`\n * is globally available in JavaScript, it causes testability problems, because\n * it is a global variable. In angular we always refer to it through the\n * `$window` service, so it may be overridden, removed or mocked for testing.\n *\n * Expressions, like the one defined for the `ngClick` directive in the example\n * below, are evaluated with respect to the current scope.  Therefore, there is\n * no risk of inadvertently coding in a dependency on a global value in such an\n * expression.\n *\n * @example\n   <doc:example>\n     <doc:source>\n       <script>\n         function Ctrl($scope, $window) {\n           $scope.$window = $window;\n           $scope.greeting = 'Hello, World!';\n         }\n       </script>\n       <div ng-controller=\"Ctrl\">\n         <input type=\"text\" ng-model=\"greeting\" />\n         <button ng-click=\"$window.alert(greeting)\">ALERT</button>\n       </div>\n     </doc:source>\n     <doc:scenario>\n      it('should display the greeting in the input box', function() {\n       input('greeting').enter('Hello, E2E Tests');\n       // If we click the button it will block the test runner\n       // element(':button').click();\n      });\n     </doc:scenario>\n   </doc:example>\n */\nfunction $WindowProvider(){\n  this.$get = valueFn(window);\n}\n\n/**\n * @ngdoc object\n * @name ng.$filterProvider\n * @description\n *\n * Filters are just functions which transform input to an output. However filters need to be Dependency Injected. To\n * achieve this a filter definition consists of a factory function which is annotated with dependencies and is\n * responsible for creating a filter function.\n *\n * <pre>\n *   // Filter registration\n *   function MyModule($provide, $filterProvider) {\n *     // create a service to demonstrate injection (not always needed)\n *     $provide.value('greet', function(name){\n *       return 'Hello ' + name + '!';\n *     });\n *\n *     // register a filter factory which uses the\n *     // greet service to demonstrate DI.\n *     $filterProvider.register('greet', function(greet){\n *       // return the filter function which uses the greet service\n *       // to generate salutation\n *       return function(text) {\n *         // filters need to be forgiving so check input validity\n *         return text && greet(text) || text;\n *       };\n *     });\n *   }\n * </pre>\n *\n * The filter function is registered with the `$injector` under the filter name suffix with `Filter`.\n * <pre>\n *   it('should be the same instance', inject(\n *     function($filterProvider) {\n *       $filterProvider.register('reverse', function(){\n *         return ...;\n *       });\n *     },\n *     function($filter, reverseFilter) {\n *       expect($filter('reverse')).toBe(reverseFilter);\n *     });\n * </pre>\n *\n *\n * For more information about how angular filters work, and how to create your own filters, see\n * {@link guide/dev_guide.templates.filters Understanding Angular Filters} in the angular Developer\n * Guide.\n */\n/**\n * @ngdoc method\n * @name ng.$filterProvider#register\n * @methodOf ng.$filterProvider\n * @description\n * Register filter factory function.\n *\n * @param {String} name Name of the filter.\n * @param {function} fn The filter factory function which is injectable.\n */\n\n\n/**\n * @ngdoc function\n * @name ng.$filter\n * @function\n * @description\n * Filters are used for formatting data displayed to the user.\n *\n * The general syntax in templates is as follows:\n *\n *         {{ expression [| filter_name[:parameter_value] ... ] }}\n *\n * @param {String} name Name of the filter function to retrieve\n * @return {Function} the filter function\n */\n$FilterProvider.$inject = ['$provide'];\nfunction $FilterProvider($provide) {\n  var suffix = 'Filter';\n\n  function register(name, factory) {\n    return $provide.factory(name + suffix, factory);\n  }\n  this.register = register;\n\n  this.$get = ['$injector', function($injector) {\n    return function(name) {\n      return $injector.get(name + suffix);\n    }\n  }];\n\n  ////////////////////////////////////////\n\n  register('currency', currencyFilter);\n  register('date', dateFilter);\n  register('filter', filterFilter);\n  register('json', jsonFilter);\n  register('limitTo', limitToFilter);\n  register('lowercase', lowercaseFilter);\n  register('number', numberFilter);\n  register('orderBy', orderByFilter);\n  register('uppercase', uppercaseFilter);\n}\n\n/**\n * @ngdoc filter\n * @name ng.filter:filter\n * @function\n *\n * @description\n * Selects a subset of items from `array` and returns it as a new array.\n *\n * Note: This function is used to augment the `Array` type in Angular expressions. See\n * {@link ng.$filter} for more information about Angular arrays.\n *\n * @param {Array} array The source array.\n * @param {string|Object|function()} expression The predicate to be used for selecting items from\n *   `array`.\n *\n *   Can be one of:\n *\n *   - `string`: Predicate that results in a substring match using the value of `expression`\n *     string. All strings or objects with string properties in `array` that contain this string\n *     will be returned. The predicate can be negated by prefixing the string with `!`.\n *\n *   - `Object`: A pattern object can be used to filter specific properties on objects contained\n *     by `array`. For example `{name:\"M\", phone:\"1\"}` predicate will return an array of items\n *     which have property `name` containing \"M\" and property `phone` containing \"1\". A special\n *     property name `$` can be used (as in `{$:\"text\"}`) to accept a match against any\n *     property of the object. That's equivalent to the simple substring match with a `string`\n *     as described above.\n *\n *   - `function`: A predicate function can be used to write arbitrary filters. The function is\n *     called for each element of `array`. The final result is an array of those elements that\n *     the predicate returned true for.\n *\n * @param {function(expected, actual)|true|undefined} comparator Comparator which is used in\n *     determining if the expected value (from the filter expression) and actual value (from\n *     the object in the array) should be considered a match.\n *\n *   Can be one of:\n *\n *     - `function(expected, actual)`:\n *       The function will be given the object value and the predicate value to compare and\n *       should return true if the item should be included in filtered result.\n *\n *     - `true`: A shorthand for `function(expected, actual) { return angular.equals(expected, actual)}`.\n *       this is essentially strict comparison of expected and actual.\n *\n *     - `false|undefined`: A short hand for a function which will look for a substring match in case\n *       insensitive way.\n *\n * @example\n   <doc:example>\n     <doc:source>\n       <div ng-init=\"friends = [{name:'John', phone:'555-1276'},\n                                {name:'Mary', phone:'800-BIG-MARY'},\n                                {name:'Mike', phone:'555-4321'},\n                                {name:'Adam', phone:'555-5678'},\n                                {name:'Julie', phone:'555-8765'},\n                                {name:'Juliette', phone:'555-5678'}]\"></div>\n\n       Search: <input ng-model=\"searchText\">\n       <table id=\"searchTextResults\">\n         <tr><th>Name</th><th>Phone</th></tr>\n         <tr ng-repeat=\"friend in friends | filter:searchText\">\n           <td>{{friend.name}}</td>\n           <td>{{friend.phone}}</td>\n         </tr>\n       </table>\n       <hr>\n       Any: <input ng-model=\"search.$\"> <br>\n       Name only <input ng-model=\"search.name\"><br>\n       Phone only <input ng-model=\"search.phone\"><br>\n       Equality <input type=\"checkbox\" ng-model=\"strict\"><br>\n       <table id=\"searchObjResults\">\n         <tr><th>Name</th><th>Phone</th></tr>\n         <tr ng-repeat=\"friend in friends | filter:search:strict\">\n           <td>{{friend.name}}</td>\n           <td>{{friend.phone}}</td>\n         </tr>\n       </table>\n     </doc:source>\n     <doc:scenario>\n       it('should search across all fields when filtering with a string', function() {\n         input('searchText').enter('m');\n         expect(repeater('#searchTextResults tr', 'friend in friends').column('friend.name')).\n           toEqual(['Mary', 'Mike', 'Adam']);\n\n         input('searchText').enter('76');\n         expect(repeater('#searchTextResults tr', 'friend in friends').column('friend.name')).\n           toEqual(['John', 'Julie']);\n       });\n\n       it('should search in specific fields when filtering with a predicate object', function() {\n         input('search.$').enter('i');\n         expect(repeater('#searchObjResults tr', 'friend in friends').column('friend.name')).\n           toEqual(['Mary', 'Mike', 'Julie', 'Juliette']);\n       });\n       it('should use a equal comparison when comparator is true', function() {\n         input('search.name').enter('Julie');\n         input('strict').check();\n         expect(repeater('#searchObjResults tr', 'friend in friends').column('friend.name')).\n           toEqual(['Julie']);\n       });\n     </doc:scenario>\n   </doc:example>\n */\nfunction filterFilter() {\n  return function(array, expression, comperator) {\n    if (!isArray(array)) return array;\n    var predicates = [];\n    predicates.check = function(value) {\n      for (var j = 0; j < predicates.length; j++) {\n        if(!predicates[j](value)) {\n          return false;\n        }\n      }\n      return true;\n    };\n    switch(typeof comperator) {\n      case \"function\":\n        break;\n      case \"boolean\":\n        if(comperator == true) {\n          comperator = function(obj, text) {\n            return angular.equals(obj, text);\n          }\n          break;\n        }\n      default:\n        comperator = function(obj, text) {\n          text = (''+text).toLowerCase();\n          return (''+obj).toLowerCase().indexOf(text) > -1\n        };\n    }\n    var search = function(obj, text){\n      if (typeof text == 'string' && text.charAt(0) === '!') {\n        return !search(obj, text.substr(1));\n      }\n      switch (typeof obj) {\n        case \"boolean\":\n        case \"number\":\n        case \"string\":\n          return comperator(obj, text);\n        case \"object\":\n          switch (typeof text) {\n            case \"object\":\n              return comperator(obj, text);\n              break;\n            default:\n              for ( var objKey in obj) {\n                if (objKey.charAt(0) !== '$' && search(obj[objKey], text)) {\n                  return true;\n                }\n              }\n              break;\n          }\n          return false;\n        case \"array\":\n          for ( var i = 0; i < obj.length; i++) {\n            if (search(obj[i], text)) {\n              return true;\n            }\n          }\n          return false;\n        default:\n          return false;\n      }\n    };\n    switch (typeof expression) {\n      case \"boolean\":\n      case \"number\":\n      case \"string\":\n        expression = {$:expression};\n      case \"object\":\n        for (var key in expression) {\n          if (key == '$') {\n            (function() {\n              if (!expression[key]) return;\n              var path = key\n              predicates.push(function(value) {\n                return search(value, expression[path]);\n              });\n            })();\n          } else {\n            (function() {\n              if (typeof(expression[key]) == 'undefined') { return; }\n              var path = key;\n              predicates.push(function(value) {\n                return search(getter(value,path), expression[path]);\n              });\n            })();\n          }\n        }\n        break;\n      case 'function':\n        predicates.push(expression);\n        break;\n      default:\n        return array;\n    }\n    var filtered = [];\n    for ( var j = 0; j < array.length; j++) {\n      var value = array[j];\n      if (predicates.check(value)) {\n        filtered.push(value);\n      }\n    }\n    return filtered;\n  }\n}\n\n/**\n * @ngdoc filter\n * @name ng.filter:currency\n * @function\n *\n * @description\n * Formats a number as a currency (ie $1,234.56). When no currency symbol is provided, default\n * symbol for current locale is used.\n *\n * @param {number} amount Input to filter.\n * @param {string=} symbol Currency symbol or identifier to be displayed.\n * @returns {string} Formatted number.\n *\n *\n * @example\n   <doc:example>\n     <doc:source>\n       <script>\n         function Ctrl($scope) {\n           $scope.amount = 1234.56;\n         }\n       </script>\n       <div ng-controller=\"Ctrl\">\n         <input type=\"number\" ng-model=\"amount\"> <br>\n         default currency symbol ($): {{amount | currency}}<br>\n         custom currency identifier (USD$): {{amount | currency:\"USD$\"}}\n       </div>\n     </doc:source>\n     <doc:scenario>\n       it('should init with 1234.56', function() {\n         expect(binding('amount | currency')).toBe('$1,234.56');\n         expect(binding('amount | currency:\"USD$\"')).toBe('USD$1,234.56');\n       });\n       it('should update', function() {\n         input('amount').enter('-1234');\n         expect(binding('amount | currency')).toBe('($1,234.00)');\n         expect(binding('amount | currency:\"USD$\"')).toBe('(USD$1,234.00)');\n       });\n     </doc:scenario>\n   </doc:example>\n */\ncurrencyFilter.$inject = ['$locale'];\nfunction currencyFilter($locale) {\n  var formats = $locale.NUMBER_FORMATS;\n  return function(amount, currencySymbol){\n    if (isUndefined(currencySymbol)) currencySymbol = formats.CURRENCY_SYM;\n    return formatNumber(amount, formats.PATTERNS[1], formats.GROUP_SEP, formats.DECIMAL_SEP, 2).\n                replace(/\\u00A4/g, currencySymbol);\n  };\n}\n\n/**\n * @ngdoc filter\n * @name ng.filter:number\n * @function\n *\n * @description\n * Formats a number as text.\n *\n * If the input is not a number an empty string is returned.\n *\n * @param {number|string} number Number to format.\n * @param {(number|string)=} fractionSize Number of decimal places to round the number to.\n * If this is not provided then the fraction size is computed from the current locale's number\n * formatting pattern. In the case of the default locale, it will be 3.\n * @returns {string} Number rounded to decimalPlaces and places a “,” after each third digit.\n *\n * @example\n   <doc:example>\n     <doc:source>\n       <script>\n         function Ctrl($scope) {\n           $scope.val = 1234.56789;\n         }\n       </script>\n       <div ng-controller=\"Ctrl\">\n         Enter number: <input ng-model='val'><br>\n         Default formatting: {{val | number}}<br>\n         No fractions: {{val | number:0}}<br>\n         Negative number: {{-val | number:4}}\n       </div>\n     </doc:source>\n     <doc:scenario>\n       it('should format numbers', function() {\n         expect(binding('val | number')).toBe('1,234.568');\n         expect(binding('val | number:0')).toBe('1,235');\n         expect(binding('-val | number:4')).toBe('-1,234.5679');\n       });\n\n       it('should update', function() {\n         input('val').enter('3374.333');\n         expect(binding('val | number')).toBe('3,374.333');\n         expect(binding('val | number:0')).toBe('3,374');\n         expect(binding('-val | number:4')).toBe('-3,374.3330');\n       });\n     </doc:scenario>\n   </doc:example>\n */\n\n\nnumberFilter.$inject = ['$locale'];\nfunction numberFilter($locale) {\n  var formats = $locale.NUMBER_FORMATS;\n  return function(number, fractionSize) {\n    return formatNumber(number, formats.PATTERNS[0], formats.GROUP_SEP, formats.DECIMAL_SEP,\n      fractionSize);\n  };\n}\n\nvar DECIMAL_SEP = '.';\nfunction formatNumber(number, pattern, groupSep, decimalSep, fractionSize) {\n  if (isNaN(number) || !isFinite(number)) return '';\n\n  var isNegative = number < 0;\n  number = Math.abs(number);\n  var numStr = number + '',\n      formatedText = '',\n      parts = [];\n\n  var hasExponent = false;\n  if (numStr.indexOf('e') !== -1) {\n    var match = numStr.match(/([\\d\\.]+)e(-?)(\\d+)/);\n    if (match && match[2] == '-' && match[3] > fractionSize + 1) {\n      numStr = '0';\n    } else {\n      formatedText = numStr;\n      hasExponent = true;\n    }\n  }\n\n  if (!hasExponent) {\n    var fractionLen = (numStr.split(DECIMAL_SEP)[1] || '').length;\n\n    // determine fractionSize if it is not specified\n    if (isUndefined(fractionSize)) {\n      fractionSize = Math.min(Math.max(pattern.minFrac, fractionLen), pattern.maxFrac);\n    }\n\n    var pow = Math.pow(10, fractionSize);\n    number = Math.round(number * pow) / pow;\n    var fraction = ('' + number).split(DECIMAL_SEP);\n    var whole = fraction[0];\n    fraction = fraction[1] || '';\n\n    var pos = 0,\n        lgroup = pattern.lgSize,\n        group = pattern.gSize;\n\n    if (whole.length >= (lgroup + group)) {\n      pos = whole.length - lgroup;\n      for (var i = 0; i < pos; i++) {\n        if ((pos - i)%group === 0 && i !== 0) {\n          formatedText += groupSep;\n        }\n        formatedText += whole.charAt(i);\n      }\n    }\n\n    for (i = pos; i < whole.length; i++) {\n      if ((whole.length - i)%lgroup === 0 && i !== 0) {\n        formatedText += groupSep;\n      }\n      formatedText += whole.charAt(i);\n    }\n\n    // format fraction part.\n    while(fraction.length < fractionSize) {\n      fraction += '0';\n    }\n\n    if (fractionSize && fractionSize !== \"0\") formatedText += decimalSep + fraction.substr(0, fractionSize);\n  } else {\n\n    if (fractionSize > 0 && number > -1 && number < 1) {\n      formatedText = number.toFixed(fractionSize);\n    }\n  }\n\n  parts.push(isNegative ? pattern.negPre : pattern.posPre);\n  parts.push(formatedText);\n  parts.push(isNegative ? pattern.negSuf : pattern.posSuf);\n  return parts.join('');\n}\n\nfunction padNumber(num, digits, trim) {\n  var neg = '';\n  if (num < 0) {\n    neg =  '-';\n    num = -num;\n  }\n  num = '' + num;\n  while(num.length < digits) num = '0' + num;\n  if (trim)\n    num = num.substr(num.length - digits);\n  return neg + num;\n}\n\n\nfunction dateGetter(name, size, offset, trim) {\n  offset = offset || 0;\n  return function(date) {\n    var value = date['get' + name]();\n    if (offset > 0 || value > -offset)\n      value += offset;\n    if (value === 0 && offset == -12 ) value = 12;\n    return padNumber(value, size, trim);\n  };\n}\n\nfunction dateStrGetter(name, shortForm) {\n  return function(date, formats) {\n    var value = date['get' + name]();\n    var get = uppercase(shortForm ? ('SHORT' + name) : name);\n\n    return formats[get][value];\n  };\n}\n\nfunction timeZoneGetter(date) {\n  var zone = -1 * date.getTimezoneOffset();\n  var paddedZone = (zone >= 0) ? \"+\" : \"\";\n\n  paddedZone += padNumber(Math[zone > 0 ? 'floor' : 'ceil'](zone / 60), 2) +\n                padNumber(Math.abs(zone % 60), 2);\n\n  return paddedZone;\n}\n\nfunction ampmGetter(date, formats) {\n  return date.getHours() < 12 ? formats.AMPMS[0] : formats.AMPMS[1];\n}\n\nvar DATE_FORMATS = {\n  yyyy: dateGetter('FullYear', 4),\n    yy: dateGetter('FullYear', 2, 0, true),\n     y: dateGetter('FullYear', 1),\n  MMMM: dateStrGetter('Month'),\n   MMM: dateStrGetter('Month', true),\n    MM: dateGetter('Month', 2, 1),\n     M: dateGetter('Month', 1, 1),\n    dd: dateGetter('Date', 2),\n     d: dateGetter('Date', 1),\n    HH: dateGetter('Hours', 2),\n     H: dateGetter('Hours', 1),\n    hh: dateGetter('Hours', 2, -12),\n     h: dateGetter('Hours', 1, -12),\n    mm: dateGetter('Minutes', 2),\n     m: dateGetter('Minutes', 1),\n    ss: dateGetter('Seconds', 2),\n     s: dateGetter('Seconds', 1),\n     // while ISO 8601 requires fractions to be prefixed with `.` or `,`\n     // we can be just safely rely on using `sss` since we currently don't support single or two digit fractions\n   sss: dateGetter('Milliseconds', 3),\n  EEEE: dateStrGetter('Day'),\n   EEE: dateStrGetter('Day', true),\n     a: ampmGetter,\n     Z: timeZoneGetter\n};\n\nvar DATE_FORMATS_SPLIT = /((?:[^yMdHhmsaZE']+)|(?:'(?:[^']|'')*')|(?:E+|y+|M+|d+|H+|h+|m+|s+|a|Z))(.*)/,\n    NUMBER_STRING = /^\\d+$/;\n\n/**\n * @ngdoc filter\n * @name ng.filter:date\n * @function\n *\n * @description\n *   Formats `date` to a string based on the requested `format`.\n *\n *   `format` string can be composed of the following elements:\n *\n *   * `'yyyy'`: 4 digit representation of year (e.g. AD 1 => 0001, AD 2010 => 2010)\n *   * `'yy'`: 2 digit representation of year, padded (00-99). (e.g. AD 2001 => 01, AD 2010 => 10)\n *   * `'y'`: 1 digit representation of year, e.g. (AD 1 => 1, AD 199 => 199)\n *   * `'MMMM'`: Month in year (January-December)\n *   * `'MMM'`: Month in year (Jan-Dec)\n *   * `'MM'`: Month in year, padded (01-12)\n *   * `'M'`: Month in year (1-12)\n *   * `'dd'`: Day in month, padded (01-31)\n *   * `'d'`: Day in month (1-31)\n *   * `'EEEE'`: Day in Week,(Sunday-Saturday)\n *   * `'EEE'`: Day in Week, (Sun-Sat)\n *   * `'HH'`: Hour in day, padded (00-23)\n *   * `'H'`: Hour in day (0-23)\n *   * `'hh'`: Hour in am/pm, padded (01-12)\n *   * `'h'`: Hour in am/pm, (1-12)\n *   * `'mm'`: Minute in hour, padded (00-59)\n *   * `'m'`: Minute in hour (0-59)\n *   * `'ss'`: Second in minute, padded (00-59)\n *   * `'s'`: Second in minute (0-59)\n *   * `'.sss' or ',sss'`: Millisecond in second, padded (000-999)\n *   * `'a'`: am/pm marker\n *   * `'Z'`: 4 digit (+sign) representation of the timezone offset (-1200-+1200)\n *\n *   `format` string can also be one of the following predefined\n *   {@link guide/i18n localizable formats}:\n *\n *   * `'medium'`: equivalent to `'MMM d, y h:mm:ss a'` for en_US locale\n *     (e.g. Sep 3, 2010 12:05:08 pm)\n *   * `'short'`: equivalent to `'M/d/yy h:mm a'` for en_US  locale (e.g. 9/3/10 12:05 pm)\n *   * `'fullDate'`: equivalent to `'EEEE, MMMM d,y'` for en_US  locale\n *     (e.g. Friday, September 3, 2010)\n *   * `'longDate'`: equivalent to `'MMMM d, y'` for en_US  locale (e.g. September 3, 2010)\n *   * `'mediumDate'`: equivalent to `'MMM d, y'` for en_US  locale (e.g. Sep 3, 2010)\n *   * `'shortDate'`: equivalent to `'M/d/yy'` for en_US locale (e.g. 9/3/10)\n *   * `'mediumTime'`: equivalent to `'h:mm:ss a'` for en_US locale (e.g. 12:05:08 pm)\n *   * `'shortTime'`: equivalent to `'h:mm a'` for en_US locale (e.g. 12:05 pm)\n *\n *   `format` string can contain literal values. These need to be quoted with single quotes (e.g.\n *   `\"h 'in the morning'\"`). In order to output single quote, use two single quotes in a sequence\n *   (e.g. `\"h 'o''clock'\"`).\n *\n * @param {(Date|number|string)} date Date to format either as Date object, milliseconds (string or\n *    number) or various ISO 8601 datetime string formats (e.g. yyyy-MM-ddTHH:mm:ss.SSSZ and its\n *    shorter versions like yyyy-MM-ddTHH:mmZ, yyyy-MM-dd or yyyyMMddTHHmmssZ). If no timezone is\n *    specified in the string input, the time is considered to be in the local timezone.\n * @param {string=} format Formatting rules (see Description). If not specified,\n *    `mediumDate` is used.\n * @returns {string} Formatted string or the input if input is not recognized as date/millis.\n *\n * @example\n   <doc:example>\n     <doc:source>\n       <span ng-non-bindable>{{1288323623006 | date:'medium'}}</span>:\n           {{1288323623006 | date:'medium'}}<br>\n       <span ng-non-bindable>{{1288323623006 | date:'yyyy-MM-dd HH:mm:ss Z'}}</span>:\n          {{1288323623006 | date:'yyyy-MM-dd HH:mm:ss Z'}}<br>\n       <span ng-non-bindable>{{1288323623006 | date:'MM/dd/yyyy @ h:mma'}}</span>:\n          {{'1288323623006' | date:'MM/dd/yyyy @ h:mma'}}<br>\n     </doc:source>\n     <doc:scenario>\n       it('should format date', function() {\n         expect(binding(\"1288323623006 | date:'medium'\")).\n            toMatch(/Oct 2\\d, 2010 \\d{1,2}:\\d{2}:\\d{2} (AM|PM)/);\n         expect(binding(\"1288323623006 | date:'yyyy-MM-dd HH:mm:ss Z'\")).\n            toMatch(/2010\\-10\\-2\\d \\d{2}:\\d{2}:\\d{2} (\\-|\\+)?\\d{4}/);\n         expect(binding(\"'1288323623006' | date:'MM/dd/yyyy @ h:mma'\")).\n            toMatch(/10\\/2\\d\\/2010 @ \\d{1,2}:\\d{2}(AM|PM)/);\n       });\n     </doc:scenario>\n   </doc:example>\n */\ndateFilter.$inject = ['$locale'];\nfunction dateFilter($locale) {\n\n\n  var R_ISO8601_STR = /^(\\d{4})-?(\\d\\d)-?(\\d\\d)(?:T(\\d\\d)(?::?(\\d\\d)(?::?(\\d\\d)(?:\\.(\\d+))?)?)?(Z|([+-])(\\d\\d):?(\\d\\d))?)?$/;\n                     // 1        2       3         4          5          6          7          8  9     10      11\n  function jsonStringToDate(string) {\n    var match;\n    if (match = string.match(R_ISO8601_STR)) {\n      var date = new Date(0),\n          tzHour = 0,\n          tzMin  = 0,\n          dateSetter = match[8] ? date.setUTCFullYear : date.setFullYear,\n          timeSetter = match[8] ? date.setUTCHours : date.setHours;\n\n      if (match[9]) {\n        tzHour = int(match[9] + match[10]);\n        tzMin = int(match[9] + match[11]);\n      }\n      dateSetter.call(date, int(match[1]), int(match[2]) - 1, int(match[3]));\n      var h = int(match[4]||0) - tzHour;\n      var m = int(match[5]||0) - tzMin\n      var s = int(match[6]||0);\n      var ms = Math.round(parseFloat('0.' + (match[7]||0)) * 1000);\n      timeSetter.call(date, h, m, s, ms);\n      return date;\n    }\n    return string;\n  }\n\n\n  return function(date, format) {\n    var text = '',\n        parts = [],\n        fn, match;\n\n    format = format || 'mediumDate';\n    format = $locale.DATETIME_FORMATS[format] || format;\n    if (isString(date)) {\n      if (NUMBER_STRING.test(date)) {\n        date = int(date);\n      } else {\n        date = jsonStringToDate(date);\n      }\n    }\n\n    if (isNumber(date)) {\n      date = new Date(date);\n    }\n\n    if (!isDate(date)) {\n      return date;\n    }\n\n    while(format) {\n      match = DATE_FORMATS_SPLIT.exec(format);\n      if (match) {\n        parts = concat(parts, match, 1);\n        format = parts.pop();\n      } else {\n        parts.push(format);\n        format = null;\n      }\n    }\n\n    forEach(parts, function(value){\n      fn = DATE_FORMATS[value];\n      text += fn ? fn(date, $locale.DATETIME_FORMATS)\n                 : value.replace(/(^'|'$)/g, '').replace(/''/g, \"'\");\n    });\n\n    return text;\n  };\n}\n\n\n/**\n * @ngdoc filter\n * @name ng.filter:json\n * @function\n *\n * @description\n *   Allows you to convert a JavaScript object into JSON string.\n *\n *   This filter is mostly useful for debugging. When using the double curly {{value}} notation\n *   the binding is automatically converted to JSON.\n *\n * @param {*} object Any JavaScript object (including arrays and primitive types) to filter.\n * @returns {string} JSON string.\n *\n *\n * @example:\n   <doc:example>\n     <doc:source>\n       <pre>{{ {'name':'value'} | json }}</pre>\n     </doc:source>\n     <doc:scenario>\n       it('should jsonify filtered objects', function() {\n         expect(binding(\"{'name':'value'}\")).toMatch(/\\{\\n  \"name\": ?\"value\"\\n}/);\n       });\n     </doc:scenario>\n   </doc:example>\n *\n */\nfunction jsonFilter() {\n  return function(object) {\n    return toJson(object, true);\n  };\n}\n\n\n/**\n * @ngdoc filter\n * @name ng.filter:lowercase\n * @function\n * @description\n * Converts string to lowercase.\n * @see angular.lowercase\n */\nvar lowercaseFilter = valueFn(lowercase);\n\n\n/**\n * @ngdoc filter\n * @name ng.filter:uppercase\n * @function\n * @description\n * Converts string to uppercase.\n * @see angular.uppercase\n */\nvar uppercaseFilter = valueFn(uppercase);\n\n/**\n * @ngdoc function\n * @name ng.filter:limitTo\n * @function\n *\n * @description\n * Creates a new array or string containing only a specified number of elements. The elements\n * are taken from either the beginning or the end of the source array or string, as specified by\n * the value and sign (positive or negative) of `limit`.\n *\n * Note: This function is used to augment the `Array` type in Angular expressions. See\n * {@link ng.$filter} for more information about Angular arrays.\n *\n * @param {Array|string} input Source array or string to be limited.\n * @param {string|number} limit The length of the returned array or string. If the `limit` number \n *     is positive, `limit` number of items from the beginning of the source array/string are copied.\n *     If the number is negative, `limit` number  of items from the end of the source array/string \n *     are copied. The `limit` will be trimmed if it exceeds `array.length`\n * @returns {Array|string} A new sub-array or substring of length `limit` or less if input array\n *     had less than `limit` elements.\n *\n * @example\n   <doc:example>\n     <doc:source>\n       <script>\n         function Ctrl($scope) {\n           $scope.numbers = [1,2,3,4,5,6,7,8,9];\n           $scope.letters = \"abcdefghi\";\n           $scope.numLimit = 3;\n           $scope.letterLimit = 3;\n         }\n       </script>\n       <div ng-controller=\"Ctrl\">\n         Limit {{numbers}} to: <input type=\"integer\" ng-model=\"numLimit\">\n         <p>Output numbers: {{ numbers | limitTo:numLimit }}</p>\n         Limit {{letters}} to: <input type=\"integer\" ng-model=\"letterLimit\">\n         <p>Output letters: {{ letters | limitTo:letterLimit }}</p>\n       </div>\n     </doc:source>\n     <doc:scenario>\n       it('should limit the number array to first three items', function() {\n         expect(element('.doc-example-live input[ng-model=numLimit]').val()).toBe('3');\n         expect(element('.doc-example-live input[ng-model=letterLimit]').val()).toBe('3');\n         expect(binding('numbers | limitTo:numLimit')).toEqual('[1,2,3]');\n         expect(binding('letters | limitTo:letterLimit')).toEqual('abc');\n       });\n\n       it('should update the output when -3 is entered', function() {\n         input('numLimit').enter(-3);\n         input('letterLimit').enter(-3);\n         expect(binding('numbers | limitTo:numLimit')).toEqual('[7,8,9]');\n         expect(binding('letters | limitTo:letterLimit')).toEqual('ghi');\n       });\n\n       it('should not exceed the maximum size of input array', function() {\n         input('numLimit').enter(100);\n         input('letterLimit').enter(100);\n         expect(binding('numbers | limitTo:numLimit')).toEqual('[1,2,3,4,5,6,7,8,9]');\n         expect(binding('letters | limitTo:letterLimit')).toEqual('abcdefghi');\n       });\n     </doc:scenario>\n   </doc:example>\n */\nfunction limitToFilter(){\n  return function(input, limit) {\n    if (!isArray(input) && !isString(input)) return input;\n    \n    limit = int(limit);\n\n    if (isString(input)) {\n      //NaN check on limit\n      if (limit) {\n        return limit >= 0 ? input.slice(0, limit) : input.slice(limit, input.length);\n      } else {\n        return \"\";\n      }\n    }\n\n    var out = [],\n      i, n;\n\n    // if abs(limit) exceeds maximum length, trim it\n    if (limit > input.length)\n      limit = input.length;\n    else if (limit < -input.length)\n      limit = -input.length;\n\n    if (limit > 0) {\n      i = 0;\n      n = limit;\n    } else {\n      i = input.length + limit;\n      n = input.length;\n    }\n\n    for (; i<n; i++) {\n      out.push(input[i]);\n    }\n\n    return out;\n  }\n}\n\n/**\n * @ngdoc function\n * @name ng.filter:orderBy\n * @function\n *\n * @description\n * Orders a specified `array` by the `expression` predicate.\n *\n * Note: this function is used to augment the `Array` type in Angular expressions. See\n * {@link ng.$filter} for more information about Angular arrays.\n *\n * @param {Array} array The array to sort.\n * @param {function(*)|string|Array.<(function(*)|string)>} expression A predicate to be\n *    used by the comparator to determine the order of elements.\n *\n *    Can be one of:\n *\n *    - `function`: Getter function. The result of this function will be sorted using the\n *      `<`, `=`, `>` operator.\n *    - `string`: An Angular expression which evaluates to an object to order by, such as 'name'\n *      to sort by a property called 'name'. Optionally prefixed with `+` or `-` to control\n *      ascending or descending sort order (for example, +name or -name).\n *    - `Array`: An array of function or string predicates. The first predicate in the array\n *      is used for sorting, but when two items are equivalent, the next predicate is used.\n *\n * @param {boolean=} reverse Reverse the order the array.\n * @returns {Array} Sorted copy of the source array.\n *\n * @example\n   <doc:example>\n     <doc:source>\n       <script>\n         function Ctrl($scope) {\n           $scope.friends =\n               [{name:'John', phone:'555-1212', age:10},\n                {name:'Mary', phone:'555-9876', age:19},\n                {name:'Mike', phone:'555-4321', age:21},\n                {name:'Adam', phone:'555-5678', age:35},\n                {name:'Julie', phone:'555-8765', age:29}]\n           $scope.predicate = '-age';\n         }\n       </script>\n       <div ng-controller=\"Ctrl\">\n         <pre>Sorting predicate = {{predicate}}; reverse = {{reverse}}</pre>\n         <hr/>\n         [ <a href=\"\" ng-click=\"predicate=''\">unsorted</a> ]\n         <table class=\"friend\">\n           <tr>\n             <th><a href=\"\" ng-click=\"predicate = 'name'; reverse=false\">Name</a>\n                 (<a href ng-click=\"predicate = '-name'; reverse=false\">^</a>)</th>\n             <th><a href=\"\" ng-click=\"predicate = 'phone'; reverse=!reverse\">Phone Number</a></th>\n             <th><a href=\"\" ng-click=\"predicate = 'age'; reverse=!reverse\">Age</a></th>\n           </tr>\n           <tr ng-repeat=\"friend in friends | orderBy:predicate:reverse\">\n             <td>{{friend.name}}</td>\n             <td>{{friend.phone}}</td>\n             <td>{{friend.age}}</td>\n           </tr>\n         </table>\n       </div>\n     </doc:source>\n     <doc:scenario>\n       it('should be reverse ordered by aged', function() {\n         expect(binding('predicate')).toBe('-age');\n         expect(repeater('table.friend', 'friend in friends').column('friend.age')).\n           toEqual(['35', '29', '21', '19', '10']);\n         expect(repeater('table.friend', 'friend in friends').column('friend.name')).\n           toEqual(['Adam', 'Julie', 'Mike', 'Mary', 'John']);\n       });\n\n       it('should reorder the table when user selects different predicate', function() {\n         element('.doc-example-live a:contains(\"Name\")').click();\n         expect(repeater('table.friend', 'friend in friends').column('friend.name')).\n           toEqual(['Adam', 'John', 'Julie', 'Mary', 'Mike']);\n         expect(repeater('table.friend', 'friend in friends').column('friend.age')).\n           toEqual(['35', '10', '29', '19', '21']);\n\n         element('.doc-example-live a:contains(\"Phone\")').click();\n         expect(repeater('table.friend', 'friend in friends').column('friend.phone')).\n           toEqual(['555-9876', '555-8765', '555-5678', '555-4321', '555-1212']);\n         expect(repeater('table.friend', 'friend in friends').column('friend.name')).\n           toEqual(['Mary', 'Julie', 'Adam', 'Mike', 'John']);\n       });\n     </doc:scenario>\n   </doc:example>\n */\norderByFilter.$inject = ['$parse'];\nfunction orderByFilter($parse){\n  return function(array, sortPredicate, reverseOrder) {\n    if (!isArray(array)) return array;\n    if (!sortPredicate) return array;\n    sortPredicate = isArray(sortPredicate) ? sortPredicate: [sortPredicate];\n    sortPredicate = map(sortPredicate, function(predicate){\n      var descending = false, get = predicate || identity;\n      if (isString(predicate)) {\n        if ((predicate.charAt(0) == '+' || predicate.charAt(0) == '-')) {\n          descending = predicate.charAt(0) == '-';\n          predicate = predicate.substring(1);\n        }\n        get = $parse(predicate);\n      }\n      return reverseComparator(function(a,b){\n        return compare(get(a),get(b));\n      }, descending);\n    });\n    var arrayCopy = [];\n    for ( var i = 0; i < array.length; i++) { arrayCopy.push(array[i]); }\n    return arrayCopy.sort(reverseComparator(comparator, reverseOrder));\n\n    function comparator(o1, o2){\n      for ( var i = 0; i < sortPredicate.length; i++) {\n        var comp = sortPredicate[i](o1, o2);\n        if (comp !== 0) return comp;\n      }\n      return 0;\n    }\n    function reverseComparator(comp, descending) {\n      return toBoolean(descending)\n          ? function(a,b){return comp(b,a);}\n          : comp;\n    }\n    function compare(v1, v2){\n      var t1 = typeof v1;\n      var t2 = typeof v2;\n      if (t1 == t2) {\n        if (t1 == \"string\") {\n           v1 = v1.toLowerCase();\n           v2 = v2.toLowerCase();\n        }\n        if (v1 === v2) return 0;\n        return v1 < v2 ? -1 : 1;\n      } else {\n        return t1 < t2 ? -1 : 1;\n      }\n    }\n  }\n}\n\nfunction ngDirective(directive) {\n  if (isFunction(directive)) {\n    directive = {\n      link: directive\n    }\n  }\n  directive.restrict = directive.restrict || 'AC';\n  return valueFn(directive);\n}\n\n/**\n * @ngdoc directive\n * @name ng.directive:a\n * @restrict E\n *\n * @description\n * Modifies the default behavior of html A tag, so that the default action is prevented when href\n * attribute is empty.\n *\n * The reasoning for this change is to allow easy creation of action links with `ngClick` directive\n * without changing the location or causing page reloads, e.g.:\n * `<a href=\"\" ng-click=\"model.$save()\">Save</a>`\n */\nvar htmlAnchorDirective = valueFn({\n  restrict: 'E',\n  compile: function(element, attr) {\n\n    if (msie <= 8) {\n\n      // turn <a href ng-click=\"..\">link</a> into a stylable link in IE\n      // but only if it doesn't have name attribute, in which case it's an anchor\n      if (!attr.href && !attr.name) {\n        attr.$set('href', '');\n      }\n\n      // add a comment node to anchors to workaround IE bug that causes element content to be reset\n      // to new attribute content if attribute is updated with value containing @ and element also\n      // contains value with @\n      // see issue #1949\n      element.append(document.createComment('IE fix'));\n    }\n\n    return function(scope, element) {\n      element.on('click', function(event){\n        // if we have no href url, then don't navigate anywhere.\n        if (!element.attr('href')) {\n          event.preventDefault();\n        }\n      });\n    }\n  }\n});\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngHref\n * @restrict A\n *\n * @description\n * Using Angular markup like {{hash}} in an href attribute makes\n * the page open to a wrong URL, if the user clicks that link before\n * angular has a chance to replace the {{hash}} with actual URL, the\n * link will be broken and will most likely return a 404 error.\n * The `ngHref` directive solves this problem.\n *\n * The buggy way to write it:\n * <pre>\n * <a href=\"http://www.gravatar.com/avatar/{{hash}}\"/>\n * </pre>\n *\n * The correct way to write it:\n * <pre>\n * <a ng-href=\"http://www.gravatar.com/avatar/{{hash}}\"/>\n * </pre>\n *\n * @element A\n * @param {template} ngHref any string which can contain `{{}}` markup.\n *\n * @example\n * This example uses `link` variable inside `href` attribute:\n    <doc:example>\n      <doc:source>\n        <input ng-model=\"value\" /><br />\n        <a id=\"link-1\" href ng-click=\"value = 1\">link 1</a> (link, don't reload)<br />\n        <a id=\"link-2\" href=\"\" ng-click=\"value = 2\">link 2</a> (link, don't reload)<br />\n        <a id=\"link-3\" ng-href=\"/{{'123'}}\">link 3</a> (link, reload!)<br />\n        <a id=\"link-4\" href=\"\" name=\"xx\" ng-click=\"value = 4\">anchor</a> (link, don't reload)<br />\n        <a id=\"link-5\" name=\"xxx\" ng-click=\"value = 5\">anchor</a> (no link)<br />\n        <a id=\"link-6\" ng-href=\"{{value}}\">link</a> (link, change location)\n      </doc:source>\n      <doc:scenario>\n        it('should execute ng-click but not reload when href without value', function() {\n          element('#link-1').click();\n          expect(input('value').val()).toEqual('1');\n          expect(element('#link-1').attr('href')).toBe(\"\");\n        });\n\n        it('should execute ng-click but not reload when href empty string', function() {\n          element('#link-2').click();\n          expect(input('value').val()).toEqual('2');\n          expect(element('#link-2').attr('href')).toBe(\"\");\n        });\n\n        it('should execute ng-click and change url when ng-href specified', function() {\n          expect(element('#link-3').attr('href')).toBe(\"/123\");\n\n          element('#link-3').click();\n          expect(browser().window().path()).toEqual('/123');\n        });\n\n        it('should execute ng-click but not reload when href empty string and name specified', function() {\n          element('#link-4').click();\n          expect(input('value').val()).toEqual('4');\n          expect(element('#link-4').attr('href')).toBe('');\n        });\n\n        it('should execute ng-click but not reload when no href but name specified', function() {\n          element('#link-5').click();\n          expect(input('value').val()).toEqual('5');\n          expect(element('#link-5').attr('href')).toBe(undefined);\n        });\n\n        it('should only change url when only ng-href', function() {\n          input('value').enter('6');\n          expect(element('#link-6').attr('href')).toBe('6');\n\n          element('#link-6').click();\n          expect(browser().location().url()).toEqual('/6');\n        });\n      </doc:scenario>\n    </doc:example>\n */\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngSrc\n * @restrict A\n *\n * @description\n * Using Angular markup like `{{hash}}` in a `src` attribute doesn't\n * work right: The browser will fetch from the URL with the literal\n * text `{{hash}}` until Angular replaces the expression inside\n * `{{hash}}`. The `ngSrc` directive solves this problem.\n *\n * The buggy way to write it:\n * <pre>\n * <img src=\"http://www.gravatar.com/avatar/{{hash}}\"/>\n * </pre>\n *\n * The correct way to write it:\n * <pre>\n * <img ng-src=\"http://www.gravatar.com/avatar/{{hash}}\"/>\n * </pre>\n *\n * @element IMG\n * @param {template} ngSrc any string which can contain `{{}}` markup.\n */\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngSrcset\n * @restrict A\n *\n * @description\n * Using Angular markup like `{{hash}}` in a `srcset` attribute doesn't\n * work right: The browser will fetch from the URL with the literal\n * text `{{hash}}` until Angular replaces the expression inside\n * `{{hash}}`. The `ngSrcset` directive solves this problem.\n *\n * The buggy way to write it:\n * <pre>\n * <img srcset=\"http://www.gravatar.com/avatar/{{hash}} 2x\"/>\n * </pre>\n *\n * The correct way to write it:\n * <pre>\n * <img ng-srcset=\"http://www.gravatar.com/avatar/{{hash}} 2x\"/>\n * </pre>\n *\n * @element IMG\n * @param {template} ngSrcset any string which can contain `{{}}` markup.\n */\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngDisabled\n * @restrict A\n *\n * @description\n *\n * The following markup will make the button enabled on Chrome/Firefox but not on IE8 and older IEs:\n * <pre>\n * <div ng-init=\"scope = { isDisabled: false }\">\n *  <button disabled=\"{{scope.isDisabled}}\">Disabled</button>\n * </div>\n * </pre>\n *\n * The HTML specs do not require browsers to preserve the special attributes such as disabled.\n * (The presence of them means true and absence means false)\n * This prevents the angular compiler from correctly retrieving the binding expression.\n * To solve this problem, we introduce the `ngDisabled` directive.\n *\n * @example\n    <doc:example>\n      <doc:source>\n        Click me to toggle: <input type=\"checkbox\" ng-model=\"checked\"><br/>\n        <button ng-model=\"button\" ng-disabled=\"checked\">Button</button>\n      </doc:source>\n      <doc:scenario>\n        it('should toggle button', function() {\n          expect(element('.doc-example-live :button').prop('disabled')).toBeFalsy();\n          input('checked').check();\n          expect(element('.doc-example-live :button').prop('disabled')).toBeTruthy();\n        });\n      </doc:scenario>\n    </doc:example>\n *\n * @element INPUT\n * @param {expression} ngDisabled Angular expression that will be evaluated.\n */\n\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngChecked\n * @restrict A\n *\n * @description\n * The HTML specs do not require browsers to preserve the special attributes such as checked.\n * (The presence of them means true and absence means false)\n * This prevents the angular compiler from correctly retrieving the binding expression.\n * To solve this problem, we introduce the `ngChecked` directive.\n * @example\n    <doc:example>\n      <doc:source>\n        Check me to check both: <input type=\"checkbox\" ng-model=\"master\"><br/>\n        <input id=\"checkSlave\" type=\"checkbox\" ng-checked=\"master\">\n      </doc:source>\n      <doc:scenario>\n        it('should check both checkBoxes', function() {\n          expect(element('.doc-example-live #checkSlave').prop('checked')).toBeFalsy();\n          input('master').check();\n          expect(element('.doc-example-live #checkSlave').prop('checked')).toBeTruthy();\n        });\n      </doc:scenario>\n    </doc:example>\n *\n * @element INPUT\n * @param {expression} ngChecked Angular expression that will be evaluated.\n */\n\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngReadonly\n * @restrict A\n *\n * @description\n * The HTML specs do not require browsers to preserve the special attributes such as readonly.\n * (The presence of them means true and absence means false)\n * This prevents the angular compiler from correctly retrieving the binding expression.\n * To solve this problem, we introduce the `ngReadonly` directive.\n * @example\n    <doc:example>\n      <doc:source>\n        Check me to make text readonly: <input type=\"checkbox\" ng-model=\"checked\"><br/>\n        <input type=\"text\" ng-readonly=\"checked\" value=\"I'm Angular\"/>\n      </doc:source>\n      <doc:scenario>\n        it('should toggle readonly attr', function() {\n          expect(element('.doc-example-live :text').prop('readonly')).toBeFalsy();\n          input('checked').check();\n          expect(element('.doc-example-live :text').prop('readonly')).toBeTruthy();\n        });\n      </doc:scenario>\n    </doc:example>\n *\n * @element INPUT\n * @param {string} expression Angular expression that will be evaluated.\n */\n\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngSelected\n * @restrict A\n *\n * @description\n * The HTML specs do not require browsers to preserve the special attributes such as selected.\n * (The presence of them means true and absence means false)\n * This prevents the angular compiler from correctly retrieving the binding expression.\n * To solve this problem, we introduced the `ngSelected` directive.\n * @example\n    <doc:example>\n      <doc:source>\n        Check me to select: <input type=\"checkbox\" ng-model=\"selected\"><br/>\n        <select>\n          <option>Hello!</option>\n          <option id=\"greet\" ng-selected=\"selected\">Greetings!</option>\n        </select>\n      </doc:source>\n      <doc:scenario>\n        it('should select Greetings!', function() {\n          expect(element('.doc-example-live #greet').prop('selected')).toBeFalsy();\n          input('selected').check();\n          expect(element('.doc-example-live #greet').prop('selected')).toBeTruthy();\n        });\n      </doc:scenario>\n    </doc:example>\n *\n * @element OPTION\n * @param {string} expression Angular expression that will be evaluated.\n */\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngOpen\n * @restrict A\n *\n * @description\n * The HTML specs do not require browsers to preserve the special attributes such as open.\n * (The presence of them means true and absence means false)\n * This prevents the angular compiler from correctly retrieving the binding expression.\n * To solve this problem, we introduce the `ngOpen` directive.\n *\n * @example\n     <doc:example>\n       <doc:source>\n         Check me check multiple: <input type=\"checkbox\" ng-model=\"open\"><br/>\n         <details id=\"details\" ng-open=\"open\">\n            <summary>Show/Hide me</summary>\n         </details>\n       </doc:source>\n       <doc:scenario>\n         it('should toggle open', function() {\n           expect(element('#details').prop('open')).toBeFalsy();\n           input('open').check();\n           expect(element('#details').prop('open')).toBeTruthy();\n         });\n       </doc:scenario>\n     </doc:example>\n *\n * @element DETAILS\n * @param {string} expression Angular expression that will be evaluated.\n */\n\nvar ngAttributeAliasDirectives = {};\n\n\n// boolean attrs are evaluated\nforEach(BOOLEAN_ATTR, function(propName, attrName) {\n  // binding to multiple is not supported\n  if (propName == \"multiple\") return;\n\n  var normalized = directiveNormalize('ng-' + attrName);\n  ngAttributeAliasDirectives[normalized] = function() {\n    return {\n      priority: 100,\n      compile: function() {\n        return function(scope, element, attr) {\n          scope.$watch(attr[normalized], function ngBooleanAttrWatchAction(value) {\n            attr.$set(attrName, !!value);\n          });\n        };\n      }\n    };\n  };\n});\n\n\n// ng-src, ng-srcset, ng-href are interpolated\nforEach(['src', 'srcset', 'href'], function(attrName) {\n  var normalized = directiveNormalize('ng-' + attrName);\n  ngAttributeAliasDirectives[normalized] = function() {\n    return {\n      priority: 99, // it needs to run after the attributes are interpolated\n      link: function(scope, element, attr) {\n        attr.$observe(normalized, function(value) {\n          if (!value)\n             return;\n\n          attr.$set(attrName, value);\n\n          // on IE, if \"ng:src\" directive declaration is used and \"src\" attribute doesn't exist\n          // then calling element.setAttribute('src', 'foo') doesn't do anything, so we need\n          // to set the property as well to achieve the desired effect.\n          // we use attr[attrName] value since $set can sanitize the url.\n          if (msie) element.prop(attrName, attr[attrName]);\n        });\n      }\n    };\n  };\n});\n\nvar nullFormCtrl = {\n  $addControl: noop,\n  $removeControl: noop,\n  $setValidity: noop,\n  $setDirty: noop,\n  $setPristine: noop\n};\n\n/**\n * @ngdoc object\n * @name ng.directive:form.FormController\n *\n * @property {boolean} $pristine True if user has not interacted with the form yet.\n * @property {boolean} $dirty True if user has already interacted with the form.\n * @property {boolean} $valid True if all of the containing forms and controls are valid.\n * @property {boolean} $invalid True if at least one containing control or form is invalid.\n *\n * @property {Object} $error Is an object hash, containing references to all invalid controls or\n *  forms, where:\n *\n *  - keys are validation tokens (error names) — such as `required`, `url` or `email`),\n *  - values are arrays of controls or forms that are invalid with given error.\n *\n * @description\n * `FormController` keeps track of all its controls and nested forms as well as state of them,\n * such as being valid/invalid or dirty/pristine.\n *\n * Each {@link ng.directive:form form} directive creates an instance\n * of `FormController`.\n *\n */\n//asks for $scope to fool the BC controller module\nFormController.$inject = ['$element', '$attrs', '$scope'];\nfunction FormController(element, attrs) {\n  var form = this,\n      parentForm = element.parent().controller('form') || nullFormCtrl,\n      invalidCount = 0, // used to easily determine if we are valid\n      errors = form.$error = {},\n      controls = [];\n\n  // init state\n  form.$name = attrs.name || attrs.ngForm;\n  form.$dirty = false;\n  form.$pristine = true;\n  form.$valid = true;\n  form.$invalid = false;\n\n  parentForm.$addControl(form);\n\n  // Setup initial state of the control\n  element.addClass(PRISTINE_CLASS);\n  toggleValidCss(true);\n\n  // convenience method for easy toggling of classes\n  function toggleValidCss(isValid, validationErrorKey) {\n    validationErrorKey = validationErrorKey ? '-' + snake_case(validationErrorKey, '-') : '';\n    element.\n      removeClass((isValid ? INVALID_CLASS : VALID_CLASS) + validationErrorKey).\n      addClass((isValid ? VALID_CLASS : INVALID_CLASS) + validationErrorKey);\n  }\n\n  /**\n   * @ngdoc function\n   * @name ng.directive:form.FormController#$addControl\n   * @methodOf ng.directive:form.FormController\n   *\n   * @description\n   * Register a control with the form.\n   *\n   * Input elements using ngModelController do this automatically when they are linked.\n   */\n  form.$addControl = function(control) {\n    controls.push(control);\n\n    if (control.$name && !form.hasOwnProperty(control.$name)) {\n      form[control.$name] = control;\n    }\n  };\n\n  /**\n   * @ngdoc function\n   * @name ng.directive:form.FormController#$removeControl\n   * @methodOf ng.directive:form.FormController\n   *\n   * @description\n   * Deregister a control from the form.\n   *\n   * Input elements using ngModelController do this automatically when they are destroyed.\n   */\n  form.$removeControl = function(control) {\n    if (control.$name && form[control.$name] === control) {\n      delete form[control.$name];\n    }\n    forEach(errors, function(queue, validationToken) {\n      form.$setValidity(validationToken, true, control);\n    });\n\n    arrayRemove(controls, control);\n  };\n\n  /**\n   * @ngdoc function\n   * @name ng.directive:form.FormController#$setValidity\n   * @methodOf ng.directive:form.FormController\n   *\n   * @description\n   * Sets the validity of a form control.\n   *\n   * This method will also propagate to parent forms.\n   */\n  form.$setValidity = function(validationToken, isValid, control) {\n    var queue = errors[validationToken];\n\n    if (isValid) {\n      if (queue) {\n        arrayRemove(queue, control);\n        if (!queue.length) {\n          invalidCount--;\n          if (!invalidCount) {\n            toggleValidCss(isValid);\n            form.$valid = true;\n            form.$invalid = false;\n          }\n          errors[validationToken] = false;\n          toggleValidCss(true, validationToken);\n          parentForm.$setValidity(validationToken, true, form);\n        }\n      }\n\n    } else {\n      if (!invalidCount) {\n        toggleValidCss(isValid);\n      }\n      if (queue) {\n        if (includes(queue, control)) return;\n      } else {\n        errors[validationToken] = queue = [];\n        invalidCount++;\n        toggleValidCss(false, validationToken);\n        parentForm.$setValidity(validationToken, false, form);\n      }\n      queue.push(control);\n\n      form.$valid = false;\n      form.$invalid = true;\n    }\n  };\n\n  /**\n   * @ngdoc function\n   * @name ng.directive:form.FormController#$setDirty\n   * @methodOf ng.directive:form.FormController\n   *\n   * @description\n   * Sets the form to a dirty state.\n   *\n   * This method can be called to add the 'ng-dirty' class and set the form to a dirty\n   * state (ng-dirty class). This method will also propagate to parent forms.\n   */\n  form.$setDirty = function() {\n    element.removeClass(PRISTINE_CLASS).addClass(DIRTY_CLASS);\n    form.$dirty = true;\n    form.$pristine = false;\n    parentForm.$setDirty();\n  };\n\n  /**\n   * @ngdoc function\n   * @name ng.directive:form.FormController#$setPristine\n   * @methodOf ng.directive:form.FormController\n   *\n   * @description\n   * Sets the form to its pristine state.\n   *\n   * This method can be called to remove the 'ng-dirty' class and set the form to its pristine\n   * state (ng-pristine class). This method will also propagate to all the controls contained\n   * in this form.\n   *\n   * Setting a form back to a pristine state is often useful when we want to 'reuse' a form after\n   * saving or resetting it.\n   */\n  form.$setPristine = function () {\n    element.removeClass(DIRTY_CLASS).addClass(PRISTINE_CLASS);\n    form.$dirty = false;\n    form.$pristine = true;\n    forEach(controls, function(control) {\n      control.$setPristine();\n    });\n  };\n}\n\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngForm\n * @restrict EAC\n *\n * @description\n * Nestable alias of {@link ng.directive:form `form`} directive. HTML\n * does not allow nesting of form elements. It is useful to nest forms, for example if the validity of a\n * sub-group of controls needs to be determined.\n *\n * @param {string=} name|ngForm Name of the form. If specified, the form controller will be published into\n *                       related scope, under this name.\n *\n */\n\n /**\n * @ngdoc directive\n * @name ng.directive:form\n * @restrict E\n *\n * @description\n * Directive that instantiates\n * {@link ng.directive:form.FormController FormController}.\n *\n * If `name` attribute is specified, the form controller is published onto the current scope under\n * this name.\n *\n * # Alias: {@link ng.directive:ngForm `ngForm`}\n *\n * In angular forms can be nested. This means that the outer form is valid when all of the child\n * forms are valid as well. However browsers do not allow nesting of `<form>` elements, for this\n * reason angular provides {@link ng.directive:ngForm `ngForm`} alias\n * which behaves identical to `<form>` but allows form nesting.\n *\n *\n * # CSS classes\n *  - `ng-valid` Is set if the form is valid.\n *  - `ng-invalid` Is set if the form is invalid.\n *  - `ng-pristine` Is set if the form is pristine.\n *  - `ng-dirty` Is set if the form is dirty.\n *\n *\n * # Submitting a form and preventing default action\n *\n * Since the role of forms in client-side Angular applications is different than in classical\n * roundtrip apps, it is desirable for the browser not to translate the form submission into a full\n * page reload that sends the data to the server. Instead some javascript logic should be triggered\n * to handle the form submission in application specific way.\n *\n * For this reason, Angular prevents the default action (form submission to the server) unless the\n * `<form>` element has an `action` attribute specified.\n *\n * You can use one of the following two ways to specify what javascript method should be called when\n * a form is submitted:\n *\n * - {@link ng.directive:ngSubmit ngSubmit} directive on the form element\n * - {@link ng.directive:ngClick ngClick} directive on the first\n  *  button or input field of type submit (input[type=submit])\n *\n * To prevent double execution of the handler, use only one of ngSubmit or ngClick directives. This\n * is because of the following form submission rules coming from the html spec:\n *\n * - If a form has only one input field then hitting enter in this field triggers form submit\n * (`ngSubmit`)\n * - if a form has has 2+ input fields and no buttons or input[type=submit] then hitting enter\n * doesn't trigger submit\n * - if a form has one or more input fields and one or more buttons or input[type=submit] then\n * hitting enter in any of the input fields will trigger the click handler on the *first* button or\n * input[type=submit] (`ngClick`) *and* a submit handler on the enclosing form (`ngSubmit`)\n *\n * @param {string=} name Name of the form. If specified, the form controller will be published into\n *                       related scope, under this name.\n *\n * @example\n    <doc:example>\n      <doc:source>\n       <script>\n         function Ctrl($scope) {\n           $scope.userType = 'guest';\n         }\n       </script>\n       <form name=\"myForm\" ng-controller=\"Ctrl\">\n         userType: <input name=\"input\" ng-model=\"userType\" required>\n         <span class=\"error\" ng-show=\"myForm.input.$error.required\">Required!</span><br>\n         <tt>userType = {{userType}}</tt><br>\n         <tt>myForm.input.$valid = {{myForm.input.$valid}}</tt><br>\n         <tt>myForm.input.$error = {{myForm.input.$error}}</tt><br>\n         <tt>myForm.$valid = {{myForm.$valid}}</tt><br>\n         <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br>\n        </form>\n      </doc:source>\n      <doc:scenario>\n        it('should initialize to model', function() {\n         expect(binding('userType')).toEqual('guest');\n         expect(binding('myForm.input.$valid')).toEqual('true');\n        });\n\n        it('should be invalid if empty', function() {\n         input('userType').enter('');\n         expect(binding('userType')).toEqual('');\n         expect(binding('myForm.input.$valid')).toEqual('false');\n        });\n      </doc:scenario>\n    </doc:example>\n */\nvar formDirectiveFactory = function(isNgForm) {\n  return ['$timeout', function($timeout) {\n    var formDirective = {\n      name: 'form',\n      restrict: 'E',\n      controller: FormController,\n      compile: function() {\n        return {\n          pre: function(scope, formElement, attr, controller) {\n            if (!attr.action) {\n              // we can't use jq events because if a form is destroyed during submission the default\n              // action is not prevented. see #1238\n              //\n              // IE 9 is not affected because it doesn't fire a submit event and try to do a full\n              // page reload if the form was destroyed by submission of the form via a click handler\n              // on a button in the form. Looks like an IE9 specific bug.\n              var preventDefaultListener = function(event) {\n                event.preventDefault\n                  ? event.preventDefault()\n                  : event.returnValue = false; // IE\n              };\n\n              addEventListenerFn(formElement[0], 'submit', preventDefaultListener);\n\n              // unregister the preventDefault listener so that we don't not leak memory but in a\n              // way that will achieve the prevention of the default action.\n              formElement.on('$destroy', function() {\n                $timeout(function() {\n                  removeEventListenerFn(formElement[0], 'submit', preventDefaultListener);\n                }, 0, false);\n              });\n            }\n\n            var parentFormCtrl = formElement.parent().controller('form'),\n                alias = attr.name || attr.ngForm;\n\n            if (alias) {\n              setter(scope, alias, controller, alias);\n            }\n            if (parentFormCtrl) {\n              formElement.on('$destroy', function() {\n                parentFormCtrl.$removeControl(controller);\n                if (alias) {\n                  setter(scope, alias, undefined, alias);\n                }\n                extend(controller, nullFormCtrl); //stop propagating child destruction handlers upwards\n              });\n            }\n          }\n        };\n      }\n    };\n\n    return isNgForm ? extend(copy(formDirective), {restrict: 'EAC'}) : formDirective;\n  }];\n};\n\nvar formDirective = formDirectiveFactory();\nvar ngFormDirective = formDirectiveFactory(true);\n\nvar URL_REGEXP = /^(ftp|http|https):\\/\\/(\\w+:{0,1}\\w*@)?(\\S+)(:[0-9]+)?(\\/|\\/([\\w#!:.?+=&%@!\\-\\/]))?$/;\nvar EMAIL_REGEXP = /^[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\\.[A-Za-z]{2,6}$/;\nvar NUMBER_REGEXP = /^\\s*(\\-|\\+)?(\\d+|(\\d*(\\.\\d*)))\\s*$/;\n\nvar inputType = {\n\n  /**\n   * @ngdoc inputType\n   * @name ng.directive:input.text\n   *\n   * @description\n   * Standard HTML text input with angular data binding.\n   *\n   * @param {string} ngModel Assignable angular expression to data-bind to.\n   * @param {string=} name Property name of the form under which the control is published.\n   * @param {string=} required Adds `required` validation error key if the value is not entered.\n   * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to\n   *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of\n   *    `required` when you want to data-bind to the `required` attribute.\n   * @param {number=} ngMinlength Sets `minlength` validation error key if the value is shorter than\n   *    minlength.\n   * @param {number=} ngMaxlength Sets `maxlength` validation error key if the value is longer than\n   *    maxlength.\n   * @param {string=} ngPattern Sets `pattern` validation error key if the value does not match the\n   *    RegExp pattern expression. Expected value is `/regexp/` for inline patterns or `regexp` for\n   *    patterns defined as scope expressions.\n   * @param {string=} ngChange Angular expression to be executed when input changes due to user\n   *    interaction with the input element.\n   * @param {boolean=} [ngTrim=true] If set to false Angular will not automatically trimming the\n   *    input.\n   *\n   * @example\n      <doc:example>\n        <doc:source>\n         <script>\n           function Ctrl($scope) {\n             $scope.text = 'guest';\n             $scope.word = /^\\s*\\w*\\s*$/;\n           }\n         </script>\n         <form name=\"myForm\" ng-controller=\"Ctrl\">\n           Single word: <input type=\"text\" name=\"input\" ng-model=\"text\"\n                               ng-pattern=\"word\" required ng-trim=\"false\">\n           <span class=\"error\" ng-show=\"myForm.input.$error.required\">\n             Required!</span>\n           <span class=\"error\" ng-show=\"myForm.input.$error.pattern\">\n             Single word only!</span>\n\n           <tt>text = {{text}}</tt><br/>\n           <tt>myForm.input.$valid = {{myForm.input.$valid}}</tt><br/>\n           <tt>myForm.input.$error = {{myForm.input.$error}}</tt><br/>\n           <tt>myForm.$valid = {{myForm.$valid}}</tt><br/>\n           <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br/>\n          </form>\n        </doc:source>\n        <doc:scenario>\n          it('should initialize to model', function() {\n            expect(binding('text')).toEqual('guest');\n            expect(binding('myForm.input.$valid')).toEqual('true');\n          });\n\n          it('should be invalid if empty', function() {\n            input('text').enter('');\n            expect(binding('text')).toEqual('');\n            expect(binding('myForm.input.$valid')).toEqual('false');\n          });\n\n          it('should be invalid if multi word', function() {\n            input('text').enter('hello world');\n            expect(binding('myForm.input.$valid')).toEqual('false');\n          });\n\n          it('should not be trimmed', function() {\n            input('text').enter('untrimmed ');\n            expect(binding('text')).toEqual('untrimmed ');\n            expect(binding('myForm.input.$valid')).toEqual('true');\n          });\n        </doc:scenario>\n      </doc:example>\n   */\n  'text': textInputType,\n\n\n  /**\n   * @ngdoc inputType\n   * @name ng.directive:input.number\n   *\n   * @description\n   * Text input with number validation and transformation. Sets the `number` validation\n   * error if not a valid number.\n   *\n   * @param {string} ngModel Assignable angular expression to data-bind to.\n   * @param {string=} name Property name of the form under which the control is published.\n   * @param {string=} min Sets the `min` validation error key if the value entered is less than `min`.\n   * @param {string=} max Sets the `max` validation error key if the value entered is greater than `max`.\n   * @param {string=} required Sets `required` validation error key if the value is not entered.\n   * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to\n   *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of\n   *    `required` when you want to data-bind to the `required` attribute.\n   * @param {number=} ngMinlength Sets `minlength` validation error key if the value is shorter than\n   *    minlength.\n   * @param {number=} ngMaxlength Sets `maxlength` validation error key if the value is longer than\n   *    maxlength.\n   * @param {string=} ngPattern Sets `pattern` validation error key if the value does not match the\n   *    RegExp pattern expression. Expected value is `/regexp/` for inline patterns or `regexp` for\n   *    patterns defined as scope expressions.\n   * @param {string=} ngChange Angular expression to be executed when input changes due to user\n   *    interaction with the input element.\n   *\n   * @example\n      <doc:example>\n        <doc:source>\n         <script>\n           function Ctrl($scope) {\n             $scope.value = 12;\n           }\n         </script>\n         <form name=\"myForm\" ng-controller=\"Ctrl\">\n           Number: <input type=\"number\" name=\"input\" ng-model=\"value\"\n                          min=\"0\" max=\"99\" required>\n           <span class=\"error\" ng-show=\"myForm.input.$error.required\">\n             Required!</span>\n           <span class=\"error\" ng-show=\"myForm.input.$error.number\">\n             Not valid number!</span>\n           <tt>value = {{value}}</tt><br/>\n           <tt>myForm.input.$valid = {{myForm.input.$valid}}</tt><br/>\n           <tt>myForm.input.$error = {{myForm.input.$error}}</tt><br/>\n           <tt>myForm.$valid = {{myForm.$valid}}</tt><br/>\n           <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br/>\n          </form>\n        </doc:source>\n        <doc:scenario>\n          it('should initialize to model', function() {\n           expect(binding('value')).toEqual('12');\n           expect(binding('myForm.input.$valid')).toEqual('true');\n          });\n\n          it('should be invalid if empty', function() {\n           input('value').enter('');\n           expect(binding('value')).toEqual('');\n           expect(binding('myForm.input.$valid')).toEqual('false');\n          });\n\n          it('should be invalid if over max', function() {\n           input('value').enter('123');\n           expect(binding('value')).toEqual('');\n           expect(binding('myForm.input.$valid')).toEqual('false');\n          });\n        </doc:scenario>\n      </doc:example>\n   */\n  'number': numberInputType,\n\n\n  /**\n   * @ngdoc inputType\n   * @name ng.directive:input.url\n   *\n   * @description\n   * Text input with URL validation. Sets the `url` validation error key if the content is not a\n   * valid URL.\n   *\n   * @param {string} ngModel Assignable angular expression to data-bind to.\n   * @param {string=} name Property name of the form under which the control is published.\n   * @param {string=} required Sets `required` validation error key if the value is not entered.\n   * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to\n   *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of\n   *    `required` when you want to data-bind to the `required` attribute.\n   * @param {number=} ngMinlength Sets `minlength` validation error key if the value is shorter than\n   *    minlength.\n   * @param {number=} ngMaxlength Sets `maxlength` validation error key if the value is longer than\n   *    maxlength.\n   * @param {string=} ngPattern Sets `pattern` validation error key if the value does not match the\n   *    RegExp pattern expression. Expected value is `/regexp/` for inline patterns or `regexp` for\n   *    patterns defined as scope expressions.\n   * @param {string=} ngChange Angular expression to be executed when input changes due to user\n   *    interaction with the input element.\n   *\n   * @example\n      <doc:example>\n        <doc:source>\n         <script>\n           function Ctrl($scope) {\n             $scope.text = 'http://google.com';\n           }\n         </script>\n         <form name=\"myForm\" ng-controller=\"Ctrl\">\n           URL: <input type=\"url\" name=\"input\" ng-model=\"text\" required>\n           <span class=\"error\" ng-show=\"myForm.input.$error.required\">\n             Required!</span>\n           <span class=\"error\" ng-show=\"myForm.input.$error.url\">\n             Not valid url!</span>\n           <tt>text = {{text}}</tt><br/>\n           <tt>myForm.input.$valid = {{myForm.input.$valid}}</tt><br/>\n           <tt>myForm.input.$error = {{myForm.input.$error}}</tt><br/>\n           <tt>myForm.$valid = {{myForm.$valid}}</tt><br/>\n           <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br/>\n           <tt>myForm.$error.url = {{!!myForm.$error.url}}</tt><br/>\n          </form>\n        </doc:source>\n        <doc:scenario>\n          it('should initialize to model', function() {\n            expect(binding('text')).toEqual('http://google.com');\n            expect(binding('myForm.input.$valid')).toEqual('true');\n          });\n\n          it('should be invalid if empty', function() {\n            input('text').enter('');\n            expect(binding('text')).toEqual('');\n            expect(binding('myForm.input.$valid')).toEqual('false');\n          });\n\n          it('should be invalid if not url', function() {\n            input('text').enter('xxx');\n            expect(binding('myForm.input.$valid')).toEqual('false');\n          });\n        </doc:scenario>\n      </doc:example>\n   */\n  'url': urlInputType,\n\n\n  /**\n   * @ngdoc inputType\n   * @name ng.directive:input.email\n   *\n   * @description\n   * Text input with email validation. Sets the `email` validation error key if not a valid email\n   * address.\n   *\n   * @param {string} ngModel Assignable angular expression to data-bind to.\n   * @param {string=} name Property name of the form under which the control is published.\n   * @param {string=} required Sets `required` validation error key if the value is not entered.\n   * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to\n   *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of\n   *    `required` when you want to data-bind to the `required` attribute.\n   * @param {number=} ngMinlength Sets `minlength` validation error key if the value is shorter than\n   *    minlength.\n   * @param {number=} ngMaxlength Sets `maxlength` validation error key if the value is longer than\n   *    maxlength.\n   * @param {string=} ngPattern Sets `pattern` validation error key if the value does not match the\n   *    RegExp pattern expression. Expected value is `/regexp/` for inline patterns or `regexp` for\n   *    patterns defined as scope expressions.\n   * @param {string=} ngChange Angular expression to be executed when input changes due to user\n   *    interaction with the input element.\n   *\n   * @example\n      <doc:example>\n        <doc:source>\n         <script>\n           function Ctrl($scope) {\n             $scope.text = 'me@example.com';\n           }\n         </script>\n           <form name=\"myForm\" ng-controller=\"Ctrl\">\n             Email: <input type=\"email\" name=\"input\" ng-model=\"text\" required>\n             <span class=\"error\" ng-show=\"myForm.input.$error.required\">\n               Required!</span>\n             <span class=\"error\" ng-show=\"myForm.input.$error.email\">\n               Not valid email!</span>\n             <tt>text = {{text}}</tt><br/>\n             <tt>myForm.input.$valid = {{myForm.input.$valid}}</tt><br/>\n             <tt>myForm.input.$error = {{myForm.input.$error}}</tt><br/>\n             <tt>myForm.$valid = {{myForm.$valid}}</tt><br/>\n             <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br/>\n             <tt>myForm.$error.email = {{!!myForm.$error.email}}</tt><br/>\n           </form>\n        </doc:source>\n        <doc:scenario>\n          it('should initialize to model', function() {\n            expect(binding('text')).toEqual('me@example.com');\n            expect(binding('myForm.input.$valid')).toEqual('true');\n          });\n\n          it('should be invalid if empty', function() {\n            input('text').enter('');\n            expect(binding('text')).toEqual('');\n            expect(binding('myForm.input.$valid')).toEqual('false');\n          });\n\n          it('should be invalid if not email', function() {\n            input('text').enter('xxx');\n            expect(binding('myForm.input.$valid')).toEqual('false');\n          });\n        </doc:scenario>\n      </doc:example>\n   */\n  'email': emailInputType,\n\n\n  /**\n   * @ngdoc inputType\n   * @name ng.directive:input.radio\n   *\n   * @description\n   * HTML radio button.\n   *\n   * @param {string} ngModel Assignable angular expression to data-bind to.\n   * @param {string} value The value to which the expression should be set when selected.\n   * @param {string=} name Property name of the form under which the control is published.\n   * @param {string=} ngChange Angular expression to be executed when input changes due to user\n   *    interaction with the input element.\n   *\n   * @example\n      <doc:example>\n        <doc:source>\n         <script>\n           function Ctrl($scope) {\n             $scope.color = 'blue';\n           }\n         </script>\n         <form name=\"myForm\" ng-controller=\"Ctrl\">\n           <input type=\"radio\" ng-model=\"color\" value=\"red\">  Red <br/>\n           <input type=\"radio\" ng-model=\"color\" value=\"green\"> Green <br/>\n           <input type=\"radio\" ng-model=\"color\" value=\"blue\"> Blue <br/>\n           <tt>color = {{color}}</tt><br/>\n          </form>\n        </doc:source>\n        <doc:scenario>\n          it('should change state', function() {\n            expect(binding('color')).toEqual('blue');\n\n            input('color').select('red');\n            expect(binding('color')).toEqual('red');\n          });\n        </doc:scenario>\n      </doc:example>\n   */\n  'radio': radioInputType,\n\n\n  /**\n   * @ngdoc inputType\n   * @name ng.directive:input.checkbox\n   *\n   * @description\n   * HTML checkbox.\n   *\n   * @param {string} ngModel Assignable angular expression to data-bind to.\n   * @param {string=} name Property name of the form under which the control is published.\n   * @param {string=} ngTrueValue The value to which the expression should be set when selected.\n   * @param {string=} ngFalseValue The value to which the expression should be set when not selected.\n   * @param {string=} ngChange Angular expression to be executed when input changes due to user\n   *    interaction with the input element.\n   *\n   * @example\n      <doc:example>\n        <doc:source>\n         <script>\n           function Ctrl($scope) {\n             $scope.value1 = true;\n             $scope.value2 = 'YES'\n           }\n         </script>\n         <form name=\"myForm\" ng-controller=\"Ctrl\">\n           Value1: <input type=\"checkbox\" ng-model=\"value1\"> <br/>\n           Value2: <input type=\"checkbox\" ng-model=\"value2\"\n                          ng-true-value=\"YES\" ng-false-value=\"NO\"> <br/>\n           <tt>value1 = {{value1}}</tt><br/>\n           <tt>value2 = {{value2}}</tt><br/>\n          </form>\n        </doc:source>\n        <doc:scenario>\n          it('should change state', function() {\n            expect(binding('value1')).toEqual('true');\n            expect(binding('value2')).toEqual('YES');\n\n            input('value1').check();\n            input('value2').check();\n            expect(binding('value1')).toEqual('false');\n            expect(binding('value2')).toEqual('NO');\n          });\n        </doc:scenario>\n      </doc:example>\n   */\n  'checkbox': checkboxInputType,\n\n  'hidden': noop,\n  'button': noop,\n  'submit': noop,\n  'reset': noop\n};\n\n\nfunction isEmpty(value) {\n  return isUndefined(value) || value === '' || value === null || value !== value;\n}\n\n\nfunction textInputType(scope, element, attr, ctrl, $sniffer, $browser) {\n\n  var listener = function() {\n    var value = element.val();\n\n    // By default we will trim the value\n    // If the attribute ng-trim exists we will avoid trimming\n    // e.g. <input ng-model=\"foo\" ng-trim=\"false\">\n    if (toBoolean(attr.ngTrim || 'T')) {\n      value = trim(value);\n    }\n\n    if (ctrl.$viewValue !== value) {\n      scope.$apply(function() {\n        ctrl.$setViewValue(value);\n      });\n    }\n  };\n\n  // if the browser does support \"input\" event, we are fine - except on IE9 which doesn't fire the\n  // input event on backspace, delete or cut\n  if ($sniffer.hasEvent('input')) {\n    element.on('input', listener);\n  } else {\n    var timeout;\n\n    var deferListener = function() {\n      if (!timeout) {\n        timeout = $browser.defer(function() {\n          listener();\n          timeout = null;\n        });\n      }\n    };\n\n    element.on('keydown', function(event) {\n      var key = event.keyCode;\n\n      // ignore\n      //    command            modifiers                   arrows\n      if (key === 91 || (15 < key && key < 19) || (37 <= key && key <= 40)) return;\n\n      deferListener();\n    });\n\n    // if user paste into input using mouse, we need \"change\" event to catch it\n    element.on('change', listener);\n\n    // if user modifies input value using context menu in IE, we need \"paste\" and \"cut\" events to catch it\n    if ($sniffer.hasEvent('paste')) {\n      element.on('paste cut', deferListener);\n    }\n  }\n\n\n  ctrl.$render = function() {\n    element.val(isEmpty(ctrl.$viewValue) ? '' : ctrl.$viewValue);\n  };\n\n  // pattern validator\n  var pattern = attr.ngPattern,\n      patternValidator,\n      match;\n\n  var validate = function(regexp, value) {\n    if (isEmpty(value) || regexp.test(value)) {\n      ctrl.$setValidity('pattern', true);\n      return value;\n    } else {\n      ctrl.$setValidity('pattern', false);\n      return undefined;\n    }\n  };\n\n  if (pattern) {\n    match = pattern.match(/^\\/(.*)\\/([gim]*)$/);\n    if (match) {\n      pattern = new RegExp(match[1], match[2]);\n      patternValidator = function(value) {\n        return validate(pattern, value)\n      };\n    } else {\n      patternValidator = function(value) {\n        var patternObj = scope.$eval(pattern);\n\n        if (!patternObj || !patternObj.test) {\n          throw minErr('ngPattern')('noregexp',\n            'Expected {0} to be a RegExp but was {1}. Element: {2}', pattern,\n            patternObj, startingTag(element));\n        }\n        return validate(patternObj, value);\n      };\n    }\n\n    ctrl.$formatters.push(patternValidator);\n    ctrl.$parsers.push(patternValidator);\n  }\n\n  // min length validator\n  if (attr.ngMinlength) {\n    var minlength = int(attr.ngMinlength);\n    var minLengthValidator = function(value) {\n      if (!isEmpty(value) && value.length < minlength) {\n        ctrl.$setValidity('minlength', false);\n        return undefined;\n      } else {\n        ctrl.$setValidity('minlength', true);\n        return value;\n      }\n    };\n\n    ctrl.$parsers.push(minLengthValidator);\n    ctrl.$formatters.push(minLengthValidator);\n  }\n\n  // max length validator\n  if (attr.ngMaxlength) {\n    var maxlength = int(attr.ngMaxlength);\n    var maxLengthValidator = function(value) {\n      if (!isEmpty(value) && value.length > maxlength) {\n        ctrl.$setValidity('maxlength', false);\n        return undefined;\n      } else {\n        ctrl.$setValidity('maxlength', true);\n        return value;\n      }\n    };\n\n    ctrl.$parsers.push(maxLengthValidator);\n    ctrl.$formatters.push(maxLengthValidator);\n  }\n}\n\nfunction numberInputType(scope, element, attr, ctrl, $sniffer, $browser) {\n  textInputType(scope, element, attr, ctrl, $sniffer, $browser);\n\n  ctrl.$parsers.push(function(value) {\n    var empty = isEmpty(value);\n    if (empty || NUMBER_REGEXP.test(value)) {\n      ctrl.$setValidity('number', true);\n      return value === '' ? null : (empty ? value : parseFloat(value));\n    } else {\n      ctrl.$setValidity('number', false);\n      return undefined;\n    }\n  });\n\n  ctrl.$formatters.push(function(value) {\n    return isEmpty(value) ? '' : '' + value;\n  });\n\n  if (attr.min) {\n    var min = parseFloat(attr.min);\n    var minValidator = function(value) {\n      if (!isEmpty(value) && value < min) {\n        ctrl.$setValidity('min', false);\n        return undefined;\n      } else {\n        ctrl.$setValidity('min', true);\n        return value;\n      }\n    };\n\n    ctrl.$parsers.push(minValidator);\n    ctrl.$formatters.push(minValidator);\n  }\n\n  if (attr.max) {\n    var max = parseFloat(attr.max);\n    var maxValidator = function(value) {\n      if (!isEmpty(value) && value > max) {\n        ctrl.$setValidity('max', false);\n        return undefined;\n      } else {\n        ctrl.$setValidity('max', true);\n        return value;\n      }\n    };\n\n    ctrl.$parsers.push(maxValidator);\n    ctrl.$formatters.push(maxValidator);\n  }\n\n  ctrl.$formatters.push(function(value) {\n\n    if (isEmpty(value) || isNumber(value)) {\n      ctrl.$setValidity('number', true);\n      return value;\n    } else {\n      ctrl.$setValidity('number', false);\n      return undefined;\n    }\n  });\n}\n\nfunction urlInputType(scope, element, attr, ctrl, $sniffer, $browser) {\n  textInputType(scope, element, attr, ctrl, $sniffer, $browser);\n\n  var urlValidator = function(value) {\n    if (isEmpty(value) || URL_REGEXP.test(value)) {\n      ctrl.$setValidity('url', true);\n      return value;\n    } else {\n      ctrl.$setValidity('url', false);\n      return undefined;\n    }\n  };\n\n  ctrl.$formatters.push(urlValidator);\n  ctrl.$parsers.push(urlValidator);\n}\n\nfunction emailInputType(scope, element, attr, ctrl, $sniffer, $browser) {\n  textInputType(scope, element, attr, ctrl, $sniffer, $browser);\n\n  var emailValidator = function(value) {\n    if (isEmpty(value) || EMAIL_REGEXP.test(value)) {\n      ctrl.$setValidity('email', true);\n      return value;\n    } else {\n      ctrl.$setValidity('email', false);\n      return undefined;\n    }\n  };\n\n  ctrl.$formatters.push(emailValidator);\n  ctrl.$parsers.push(emailValidator);\n}\n\nfunction radioInputType(scope, element, attr, ctrl) {\n  // make the name unique, if not defined\n  if (isUndefined(attr.name)) {\n    element.attr('name', nextUid());\n  }\n\n  element.on('click', function() {\n    if (element[0].checked) {\n      scope.$apply(function() {\n        ctrl.$setViewValue(attr.value);\n      });\n    }\n  });\n\n  ctrl.$render = function() {\n    var value = attr.value;\n    element[0].checked = (value == ctrl.$viewValue);\n  };\n\n  attr.$observe('value', ctrl.$render);\n}\n\nfunction checkboxInputType(scope, element, attr, ctrl) {\n  var trueValue = attr.ngTrueValue,\n      falseValue = attr.ngFalseValue;\n\n  if (!isString(trueValue)) trueValue = true;\n  if (!isString(falseValue)) falseValue = false;\n\n  element.on('click', function() {\n    scope.$apply(function() {\n      ctrl.$setViewValue(element[0].checked);\n    });\n  });\n\n  ctrl.$render = function() {\n    element[0].checked = ctrl.$viewValue;\n  };\n\n  ctrl.$formatters.push(function(value) {\n    return value === trueValue;\n  });\n\n  ctrl.$parsers.push(function(value) {\n    return value ? trueValue : falseValue;\n  });\n}\n\n\n/**\n * @ngdoc directive\n * @name ng.directive:textarea\n * @restrict E\n *\n * @description\n * HTML textarea element control with angular data-binding. The data-binding and validation\n * properties of this element are exactly the same as those of the\n * {@link ng.directive:input input element}.\n *\n * @param {string} ngModel Assignable angular expression to data-bind to.\n * @param {string=} name Property name of the form under which the control is published.\n * @param {string=} required Sets `required` validation error key if the value is not entered.\n * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to\n *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of\n *    `required` when you want to data-bind to the `required` attribute.\n * @param {number=} ngMinlength Sets `minlength` validation error key if the value is shorter than\n *    minlength.\n * @param {number=} ngMaxlength Sets `maxlength` validation error key if the value is longer than\n *    maxlength.\n * @param {string=} ngPattern Sets `pattern` validation error key if the value does not match the\n *    RegExp pattern expression. Expected value is `/regexp/` for inline patterns or `regexp` for\n *    patterns defined as scope expressions.\n * @param {string=} ngChange Angular expression to be executed when input changes due to user\n *    interaction with the input element.\n */\n\n\n/**\n * @ngdoc directive\n * @name ng.directive:input\n * @restrict E\n *\n * @description\n * HTML input element control with angular data-binding. Input control follows HTML5 input types\n * and polyfills the HTML5 validation behavior for older browsers.\n *\n * @param {string} ngModel Assignable angular expression to data-bind to.\n * @param {string=} name Property name of the form under which the control is published.\n * @param {string=} required Sets `required` validation error key if the value is not entered.\n * @param {boolean=} ngRequired Sets `required` attribute if set to true\n * @param {number=} ngMinlength Sets `minlength` validation error key if the value is shorter than\n *    minlength.\n * @param {number=} ngMaxlength Sets `maxlength` validation error key if the value is longer than\n *    maxlength.\n * @param {string=} ngPattern Sets `pattern` validation error key if the value does not match the\n *    RegExp pattern expression. Expected value is `/regexp/` for inline patterns or `regexp` for\n *    patterns defined as scope expressions.\n * @param {string=} ngChange Angular expression to be executed when input changes due to user\n *    interaction with the input element.\n *\n * @example\n    <doc:example>\n      <doc:source>\n       <script>\n         function Ctrl($scope) {\n           $scope.user = {name: 'guest', last: 'visitor'};\n         }\n       </script>\n       <div ng-controller=\"Ctrl\">\n         <form name=\"myForm\">\n           User name: <input type=\"text\" name=\"userName\" ng-model=\"user.name\" required>\n           <span class=\"error\" ng-show=\"myForm.userName.$error.required\">\n             Required!</span><br>\n           Last name: <input type=\"text\" name=\"lastName\" ng-model=\"user.last\"\n             ng-minlength=\"3\" ng-maxlength=\"10\">\n           <span class=\"error\" ng-show=\"myForm.lastName.$error.minlength\">\n             Too short!</span>\n           <span class=\"error\" ng-show=\"myForm.lastName.$error.maxlength\">\n             Too long!</span><br>\n         </form>\n         <hr>\n         <tt>user = {{user}}</tt><br/>\n         <tt>myForm.userName.$valid = {{myForm.userName.$valid}}</tt><br>\n         <tt>myForm.userName.$error = {{myForm.userName.$error}}</tt><br>\n         <tt>myForm.lastName.$valid = {{myForm.lastName.$valid}}</tt><br>\n         <tt>myForm.lastName.$error = {{myForm.lastName.$error}}</tt><br>\n         <tt>myForm.$valid = {{myForm.$valid}}</tt><br>\n         <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br>\n         <tt>myForm.$error.minlength = {{!!myForm.$error.minlength}}</tt><br>\n         <tt>myForm.$error.maxlength = {{!!myForm.$error.maxlength}}</tt><br>\n       </div>\n      </doc:source>\n      <doc:scenario>\n        it('should initialize to model', function() {\n          expect(binding('user')).toEqual('{\"name\":\"guest\",\"last\":\"visitor\"}');\n          expect(binding('myForm.userName.$valid')).toEqual('true');\n          expect(binding('myForm.$valid')).toEqual('true');\n        });\n\n        it('should be invalid if empty when required', function() {\n          input('user.name').enter('');\n          expect(binding('user')).toEqual('{\"last\":\"visitor\"}');\n          expect(binding('myForm.userName.$valid')).toEqual('false');\n          expect(binding('myForm.$valid')).toEqual('false');\n        });\n\n        it('should be valid if empty when min length is set', function() {\n          input('user.last').enter('');\n          expect(binding('user')).toEqual('{\"name\":\"guest\",\"last\":\"\"}');\n          expect(binding('myForm.lastName.$valid')).toEqual('true');\n          expect(binding('myForm.$valid')).toEqual('true');\n        });\n\n        it('should be invalid if less than required min length', function() {\n          input('user.last').enter('xx');\n          expect(binding('user')).toEqual('{\"name\":\"guest\"}');\n          expect(binding('myForm.lastName.$valid')).toEqual('false');\n          expect(binding('myForm.lastName.$error')).toMatch(/minlength/);\n          expect(binding('myForm.$valid')).toEqual('false');\n        });\n\n        it('should be invalid if longer than max length', function() {\n          input('user.last').enter('some ridiculously long name');\n          expect(binding('user'))\n            .toEqual('{\"name\":\"guest\"}');\n          expect(binding('myForm.lastName.$valid')).toEqual('false');\n          expect(binding('myForm.lastName.$error')).toMatch(/maxlength/);\n          expect(binding('myForm.$valid')).toEqual('false');\n        });\n      </doc:scenario>\n    </doc:example>\n */\nvar inputDirective = ['$browser', '$sniffer', function($browser, $sniffer) {\n  return {\n    restrict: 'E',\n    require: '?ngModel',\n    link: function(scope, element, attr, ctrl) {\n      if (ctrl) {\n        (inputType[lowercase(attr.type)] || inputType.text)(scope, element, attr, ctrl, $sniffer,\n                                                            $browser);\n      }\n    }\n  };\n}];\n\nvar VALID_CLASS = 'ng-valid',\n    INVALID_CLASS = 'ng-invalid',\n    PRISTINE_CLASS = 'ng-pristine',\n    DIRTY_CLASS = 'ng-dirty';\n\n/**\n * @ngdoc object\n * @name ng.directive:ngModel.NgModelController\n *\n * @property {string} $viewValue Actual string value in the view.\n * @property {*} $modelValue The value in the model, that the control is bound to.\n * @property {Array.<Function>} $parsers Array of functions to execute, as a pipeline, whenever\n       the control reads value from the DOM.  Each function is called, in turn, passing the value\n       through to the next. Used to sanitize / convert the value as well as validation.\n       For validation, the parsers should update the validity state using\n       {@link ng.directive:ngModel.NgModelController#$setValidity $setValidity()},\n       and return `undefined` for invalid values.\n\n *\n * @property {Array.<Function>} $formatters Array of functions to execute, as a pipeline, whenever\n       the model value changes. Each function is called, in turn, passing the value through to the\n       next. Used to format / convert values for display in the control and validation.\n *      <pre>\n *      function formatter(value) {\n *        if (value) {\n *          return value.toUpperCase();\n *        }\n *      }\n *      ngModel.$formatters.push(formatter);\n *      </pre>\n * @property {Object} $error An object hash with all errors as keys.\n *\n * @property {boolean} $pristine True if user has not interacted with the control yet.\n * @property {boolean} $dirty True if user has already interacted with the control.\n * @property {boolean} $valid True if there is no error.\n * @property {boolean} $invalid True if at least one error on the control.\n *\n * @description\n *\n * `NgModelController` provides API for the `ng-model` directive. The controller contains\n * services for data-binding, validation, CSS update, value formatting and parsing. It\n * specifically does not contain any logic which deals with DOM rendering or listening to\n * DOM events. The `NgModelController` is meant to be extended by other directives where, the\n * directive provides DOM manipulation and the `NgModelController` provides the data-binding.\n * Note that you cannot use `NgModelController` in a directive with an isolated scope,\n * as, in that case, the `ng-model` value gets put into the isolated scope and does not get\n * propogated to the parent scope.\n *\n *\n * This example shows how to use `NgModelController` with a custom control to achieve\n * data-binding. Notice how different directives (`contenteditable`, `ng-model`, and `required`)\n * collaborate together to achieve the desired result.\n *\n * <example module=\"customControl\">\n    <file name=\"style.css\">\n      [contenteditable] {\n        border: 1px solid black;\n        background-color: white;\n        min-height: 20px;\n      }\n\n      .ng-invalid {\n        border: 1px solid red;\n      }\n\n    </file>\n    <file name=\"script.js\">\n      angular.module('customControl', []).\n        directive('contenteditable', function() {\n          return {\n            restrict: 'A', // only activate on element attribute\n            require: '?ngModel', // get a hold of NgModelController\n            link: function(scope, element, attrs, ngModel) {\n              if(!ngModel) return; // do nothing if no ng-model\n\n              // Specify how UI should be updated\n              ngModel.$render = function() {\n                element.html(ngModel.$viewValue || '');\n              };\n\n              // Listen for change events to enable binding\n              element.on('blur keyup change', function() {\n                scope.$apply(read);\n              });\n              read(); // initialize\n\n              // Write data to the model\n              function read() {\n                var html = element.html();\n                // When we clear the content editable the browser leaves a <br> behind\n                // If strip-br attribute is provided then we strip this out\n                if( attrs.stripBr && html == '<br>' ) {\n                  html = '';\n                }\n                ngModel.$setViewValue(html);\n              }\n            }\n          };\n        });\n    </file>\n    <file name=\"index.html\">\n      <form name=\"myForm\">\n       <div contenteditable\n            name=\"myWidget\" ng-model=\"userContent\"\n            strip-br=\"true\"\n            required>Change me!</div>\n        <span ng-show=\"myForm.myWidget.$error.required\">Required!</span>\n       <hr>\n       <textarea ng-model=\"userContent\"></textarea>\n      </form>\n    </file>\n    <file name=\"scenario.js\">\n      it('should data-bind and become invalid', function() {\n        var contentEditable = element('[contenteditable]');\n\n        expect(contentEditable.text()).toEqual('Change me!');\n        input('userContent').enter('');\n        expect(contentEditable.text()).toEqual('');\n        expect(contentEditable.prop('className')).toMatch(/ng-invalid-required/);\n      });\n    </file>\n * </example>\n *\n */\nvar NgModelController = ['$scope', '$exceptionHandler', '$attrs', '$element', '$parse',\n    function($scope, $exceptionHandler, $attr, $element, $parse) {\n  this.$viewValue = Number.NaN;\n  this.$modelValue = Number.NaN;\n  this.$parsers = [];\n  this.$formatters = [];\n  this.$viewChangeListeners = [];\n  this.$pristine = true;\n  this.$dirty = false;\n  this.$valid = true;\n  this.$invalid = false;\n  this.$name = $attr.name;\n\n  var ngModelGet = $parse($attr.ngModel),\n      ngModelSet = ngModelGet.assign;\n\n  if (!ngModelSet) {\n    throw minErr('ngModel')('nonassign', \"Expression '{0}' is non-assignable. Element: {1}\",\n        $attr.ngModel, startingTag($element));\n  }\n\n  /**\n   * @ngdoc function\n   * @name ng.directive:ngModel.NgModelController#$render\n   * @methodOf ng.directive:ngModel.NgModelController\n   *\n   * @description\n   * Called when the view needs to be updated. It is expected that the user of the ng-model\n   * directive will implement this method.\n   */\n  this.$render = noop;\n\n  var parentForm = $element.inheritedData('$formController') || nullFormCtrl,\n      invalidCount = 0, // used to easily determine if we are valid\n      $error = this.$error = {}; // keep invalid keys here\n\n\n  // Setup initial state of the control\n  $element.addClass(PRISTINE_CLASS);\n  toggleValidCss(true);\n\n  // convenience method for easy toggling of classes\n  function toggleValidCss(isValid, validationErrorKey) {\n    validationErrorKey = validationErrorKey ? '-' + snake_case(validationErrorKey, '-') : '';\n    $element.\n      removeClass((isValid ? INVALID_CLASS : VALID_CLASS) + validationErrorKey).\n      addClass((isValid ? VALID_CLASS : INVALID_CLASS) + validationErrorKey);\n  }\n\n  /**\n   * @ngdoc function\n   * @name ng.directive:ngModel.NgModelController#$setValidity\n   * @methodOf ng.directive:ngModel.NgModelController\n   *\n   * @description\n   * Change the validity state, and notifies the form when the control changes validity. (i.e. it\n   * does not notify form if given validator is already marked as invalid).\n   *\n   * This method should be called by validators - i.e. the parser or formatter functions.\n   *\n   * @param {string} validationErrorKey Name of the validator. the `validationErrorKey` will assign\n   *        to `$error[validationErrorKey]=isValid` so that it is available for data-binding.\n   *        The `validationErrorKey` should be in camelCase and will get converted into dash-case\n   *        for class name. Example: `myError` will result in `ng-valid-my-error` and `ng-invalid-my-error`\n   *        class and can be bound to as  `{{someForm.someControl.$error.myError}}` .\n   * @param {boolean} isValid Whether the current state is valid (true) or invalid (false).\n   */\n  this.$setValidity = function(validationErrorKey, isValid) {\n    if ($error[validationErrorKey] === !isValid) return;\n\n    if (isValid) {\n      if ($error[validationErrorKey]) invalidCount--;\n      if (!invalidCount) {\n        toggleValidCss(true);\n        this.$valid = true;\n        this.$invalid = false;\n      }\n    } else {\n      toggleValidCss(false);\n      this.$invalid = true;\n      this.$valid = false;\n      invalidCount++;\n    }\n\n    $error[validationErrorKey] = !isValid;\n    toggleValidCss(isValid, validationErrorKey);\n\n    parentForm.$setValidity(validationErrorKey, isValid, this);\n  };\n\n  /**\n   * @ngdoc function\n   * @name ng.directive:ngModel.NgModelController#$setPristine\n   * @methodOf ng.directive:ngModel.NgModelController\n   *\n   * @description\n   * Sets the control to its pristine state.\n   *\n   * This method can be called to remove the 'ng-dirty' class and set the control to its pristine\n   * state (ng-pristine class).\n   */\n  this.$setPristine = function () {\n    this.$dirty = false;\n    this.$pristine = true;\n    $element.removeClass(DIRTY_CLASS).addClass(PRISTINE_CLASS);\n  };\n\n  /**\n   * @ngdoc function\n   * @name ng.directive:ngModel.NgModelController#$setViewValue\n   * @methodOf ng.directive:ngModel.NgModelController\n   *\n   * @description\n   * Read a value from view.\n   *\n   * This method should be called from within a DOM event handler.\n   * For example {@link ng.directive:input input} or\n   * {@link ng.directive:select select} directives call it.\n   *\n   * It internally calls all `$parsers` (including validators) and updates the `$modelValue` and the actual model path.\n   * Lastly it calls all registered change listeners.\n   *\n   * @param {string} value Value from the view.\n   */\n  this.$setViewValue = function(value) {\n    this.$viewValue = value;\n\n    // change to dirty\n    if (this.$pristine) {\n      this.$dirty = true;\n      this.$pristine = false;\n      $element.removeClass(PRISTINE_CLASS).addClass(DIRTY_CLASS);\n      parentForm.$setDirty();\n    }\n\n    forEach(this.$parsers, function(fn) {\n      value = fn(value);\n    });\n\n    if (this.$modelValue !== value) {\n      this.$modelValue = value;\n      ngModelSet($scope, value);\n      forEach(this.$viewChangeListeners, function(listener) {\n        try {\n          listener();\n        } catch(e) {\n          $exceptionHandler(e);\n        }\n      })\n    }\n  };\n\n  // model -> value\n  var ctrl = this;\n\n  $scope.$watch(function ngModelWatch() {\n    var value = ngModelGet($scope);\n\n    // if scope model value and ngModel value are out of sync\n    if (ctrl.$modelValue !== value) {\n\n      var formatters = ctrl.$formatters,\n          idx = formatters.length;\n\n      ctrl.$modelValue = value;\n      while(idx--) {\n        value = formatters[idx](value);\n      }\n\n      if (ctrl.$viewValue !== value) {\n        ctrl.$viewValue = value;\n        ctrl.$render();\n      }\n    }\n  });\n}];\n\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngModel\n *\n * @element input\n *\n * @description\n * Is a directive that tells Angular to do two-way data binding. It works together with `input`,\n * `select`, `textarea` and even custom form controls that use {@link ng.directive:ngModel.NgModelController\n * NgModelController} exposed by this directive.\n *\n * `ngModel` is responsible for:\n *\n * - binding the view into the model, which other directives such as `input`, `textarea` or `select`\n *   require,\n * - providing validation behavior (i.e. required, number, email, url),\n * - keeping state of the control (valid/invalid, dirty/pristine, validation errors),\n * - setting related css class onto the element (`ng-valid`, `ng-invalid`, `ng-dirty`, `ng-pristine`),\n * - register the control with parent {@link ng.directive:form form}.\n *\n * Note: `ngModel` will try to bind to the property given by evaluating the expression on the\n * current scope. If the property doesn't already exist on this scope, it will be created\n * implicitly and added to the scope.\n *\n * For basic examples, how to use `ngModel`, see:\n *\n *  - {@link ng.directive:input input}\n *    - {@link ng.directive:input.text text}\n *    - {@link ng.directive:input.checkbox checkbox}\n *    - {@link ng.directive:input.radio radio}\n *    - {@link ng.directive:input.number number}\n *    - {@link ng.directive:input.email email}\n *    - {@link ng.directive:input.url url}\n *  - {@link ng.directive:select select}\n *  - {@link ng.directive:textarea textarea}\n *\n */\nvar ngModelDirective = function() {\n  return {\n    require: ['ngModel', '^?form'],\n    controller: NgModelController,\n    link: function(scope, element, attr, ctrls) {\n      // notify others, especially parent forms\n\n      var modelCtrl = ctrls[0],\n          formCtrl = ctrls[1] || nullFormCtrl;\n\n      formCtrl.$addControl(modelCtrl);\n\n      element.on('$destroy', function() {\n        formCtrl.$removeControl(modelCtrl);\n      });\n    }\n  };\n};\n\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngChange\n * @restrict E\n *\n * @description\n * Evaluate given expression when user changes the input.\n * The expression is not evaluated when the value change is coming from the model.\n *\n * Note, this directive requires `ngModel` to be present.\n *\n * @element input\n *\n * @example\n * <doc:example>\n *   <doc:source>\n *     <script>\n *       function Controller($scope) {\n *         $scope.counter = 0;\n *         $scope.change = function() {\n *           $scope.counter++;\n *         };\n *       }\n *     </script>\n *     <div ng-controller=\"Controller\">\n *       <input type=\"checkbox\" ng-model=\"confirmed\" ng-change=\"change()\" id=\"ng-change-example1\" />\n *       <input type=\"checkbox\" ng-model=\"confirmed\" id=\"ng-change-example2\" />\n *       <label for=\"ng-change-example2\">Confirmed</label><br />\n *       debug = {{confirmed}}<br />\n *       counter = {{counter}}\n *     </div>\n *   </doc:source>\n *   <doc:scenario>\n *     it('should evaluate the expression if changing from view', function() {\n *       expect(binding('counter')).toEqual('0');\n *       element('#ng-change-example1').click();\n *       expect(binding('counter')).toEqual('1');\n *       expect(binding('confirmed')).toEqual('true');\n *     });\n *\n *     it('should not evaluate the expression if changing from model', function() {\n *       element('#ng-change-example2').click();\n *       expect(binding('counter')).toEqual('0');\n *       expect(binding('confirmed')).toEqual('true');\n *     });\n *   </doc:scenario>\n * </doc:example>\n */\nvar ngChangeDirective = valueFn({\n  require: 'ngModel',\n  link: function(scope, element, attr, ctrl) {\n    ctrl.$viewChangeListeners.push(function() {\n      scope.$eval(attr.ngChange);\n    });\n  }\n});\n\n\nvar requiredDirective = function() {\n  return {\n    require: '?ngModel',\n    link: function(scope, elm, attr, ctrl) {\n      if (!ctrl) return;\n      attr.required = true; // force truthy in case we are on non input element\n\n      var validator = function(value) {\n        if (attr.required && (isEmpty(value) || value === false)) {\n          ctrl.$setValidity('required', false);\n          return;\n        } else {\n          ctrl.$setValidity('required', true);\n          return value;\n        }\n      };\n\n      ctrl.$formatters.push(validator);\n      ctrl.$parsers.unshift(validator);\n\n      attr.$observe('required', function() {\n        validator(ctrl.$viewValue);\n      });\n    }\n  };\n};\n\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngList\n *\n * @description\n * Text input that converts between comma-separated string into an array of strings.\n *\n * @element input\n * @param {string=} ngList optional delimiter that should be used to split the value. If\n *   specified in form `/something/` then the value will be converted into a regular expression.\n *\n * @example\n    <doc:example>\n      <doc:source>\n       <script>\n         function Ctrl($scope) {\n           $scope.names = ['igor', 'misko', 'vojta'];\n         }\n       </script>\n       <form name=\"myForm\" ng-controller=\"Ctrl\">\n         List: <input name=\"namesInput\" ng-model=\"names\" ng-list required>\n         <span class=\"error\" ng-show=\"myForm.namesInput.$error.required\">\n           Required!</span>\n         <br>\n         <tt>names = {{names}}</tt><br/>\n         <tt>myForm.namesInput.$valid = {{myForm.namesInput.$valid}}</tt><br/>\n         <tt>myForm.namesInput.$error = {{myForm.namesInput.$error}}</tt><br/>\n         <tt>myForm.$valid = {{myForm.$valid}}</tt><br/>\n         <tt>myForm.$error.required = {{!!myForm.$error.required}}</tt><br/>\n        </form>\n      </doc:source>\n      <doc:scenario>\n        it('should initialize to model', function() {\n          expect(binding('names')).toEqual('[\"igor\",\"misko\",\"vojta\"]');\n          expect(binding('myForm.namesInput.$valid')).toEqual('true');\n          expect(element('span.error').css('display')).toBe('none');\n        });\n\n        it('should be invalid if empty', function() {\n          input('names').enter('');\n          expect(binding('names')).toEqual('[]');\n          expect(binding('myForm.namesInput.$valid')).toEqual('false');\n          expect(element('span.error').css('display')).not().toBe('none');\n        });\n      </doc:scenario>\n    </doc:example>\n */\nvar ngListDirective = function() {\n  return {\n    require: 'ngModel',\n    link: function(scope, element, attr, ctrl) {\n      var match = /\\/(.*)\\//.exec(attr.ngList),\n          separator = match && new RegExp(match[1]) || attr.ngList || ',';\n\n      var parse = function(viewValue) {\n        var list = [];\n\n        if (viewValue) {\n          forEach(viewValue.split(separator), function(value) {\n            if (value) list.push(trim(value));\n          });\n        }\n\n        return list;\n      };\n\n      ctrl.$parsers.push(parse);\n      ctrl.$formatters.push(function(value) {\n        if (isArray(value)) {\n          return value.join(', ');\n        }\n\n        return undefined;\n      });\n    }\n  };\n};\n\n\nvar CONSTANT_VALUE_REGEXP = /^(true|false|\\d+)$/;\n\nvar ngValueDirective = function() {\n  return {\n    priority: 100,\n    compile: function(tpl, tplAttr) {\n      if (CONSTANT_VALUE_REGEXP.test(tplAttr.ngValue)) {\n        return function(scope, elm, attr) {\n          attr.$set('value', scope.$eval(attr.ngValue));\n        };\n      } else {\n        return function(scope, elm, attr) {\n          scope.$watch(attr.ngValue, function valueWatchAction(value) {\n            attr.$set('value', value);\n          });\n        };\n      }\n    }\n  };\n};\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngBind\n *\n * @description\n * The `ngBind` attribute tells Angular to replace the text content of the specified HTML element\n * with the value of a given expression, and to update the text content when the value of that\n * expression changes.\n *\n * Typically, you don't use `ngBind` directly, but instead you use the double curly markup like\n * `{{ expression }}` which is similar but less verbose.\n *\n * It is preferrable to use `ngBind` instead of `{{ expression }}` when a template is momentarily \n * displayed by the browser in its raw state before Angular compiles it. Since `ngBind` is an \n * element attribute, it makes the bindings invisible to the user while the page is loading.\n *\n * An alternative solution to this problem would be using the\n * {@link ng.directive:ngCloak ngCloak} directive.\n *\n *\n * @element ANY\n * @param {expression} ngBind {@link guide/expression Expression} to evaluate.\n *\n * @example\n * Enter a name in the Live Preview text box; the greeting below the text box changes instantly.\n   <doc:example>\n     <doc:source>\n       <script>\n         function Ctrl($scope) {\n           $scope.name = 'Whirled';\n         }\n       </script>\n       <div ng-controller=\"Ctrl\">\n         Enter name: <input type=\"text\" ng-model=\"name\"><br>\n         Hello <span ng-bind=\"name\"></span>!\n       </div>\n     </doc:source>\n     <doc:scenario>\n       it('should check ng-bind', function() {\n         expect(using('.doc-example-live').binding('name')).toBe('Whirled');\n         using('.doc-example-live').input('name').enter('world');\n         expect(using('.doc-example-live').binding('name')).toBe('world');\n       });\n     </doc:scenario>\n   </doc:example>\n */\nvar ngBindDirective = ngDirective(function(scope, element, attr) {\n  element.addClass('ng-binding').data('$binding', attr.ngBind);\n  scope.$watch(attr.ngBind, function ngBindWatchAction(value) {\n    element.text(value == undefined ? '' : value);\n  });\n});\n\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngBindTemplate\n *\n * @description\n * The `ngBindTemplate` directive specifies that the element\n * text content should be replaced with the interpolation of the template\n * in the `ngBindTemplate` attribute.\n * Unlike `ngBind`, the `ngBindTemplate` can contain multiple `{{` `}}`\n * expressions. This directive is needed since some HTML elements\n * (such as TITLE and OPTION) cannot contain SPAN elements.\n *\n * @element ANY\n * @param {string} ngBindTemplate template of form\n *   <tt>{{</tt> <tt>expression</tt> <tt>}}</tt> to eval.\n *\n * @example\n * Try it here: enter text in text box and watch the greeting change.\n   <doc:example>\n     <doc:source>\n       <script>\n         function Ctrl($scope) {\n           $scope.salutation = 'Hello';\n           $scope.name = 'World';\n         }\n       </script>\n       <div ng-controller=\"Ctrl\">\n        Salutation: <input type=\"text\" ng-model=\"salutation\"><br>\n        Name: <input type=\"text\" ng-model=\"name\"><br>\n        <pre ng-bind-template=\"{{salutation}} {{name}}!\"></pre>\n       </div>\n     </doc:source>\n     <doc:scenario>\n       it('should check ng-bind', function() {\n         expect(using('.doc-example-live').binding('salutation')).\n           toBe('Hello');\n         expect(using('.doc-example-live').binding('name')).\n           toBe('World');\n         using('.doc-example-live').input('salutation').enter('Greetings');\n         using('.doc-example-live').input('name').enter('user');\n         expect(using('.doc-example-live').binding('salutation')).\n           toBe('Greetings');\n         expect(using('.doc-example-live').binding('name')).\n           toBe('user');\n       });\n     </doc:scenario>\n   </doc:example>\n */\nvar ngBindTemplateDirective = ['$interpolate', function($interpolate) {\n  return function(scope, element, attr) {\n    // TODO: move this to scenario runner\n    var interpolateFn = $interpolate(element.attr(attr.$attr.ngBindTemplate));\n    element.addClass('ng-binding').data('$binding', interpolateFn);\n    attr.$observe('ngBindTemplate', function(value) {\n      element.text(value);\n    });\n  }\n}];\n\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngBindHtml\n *\n * @description\n * Creates a binding that will innerHTML the result of evaluating the `expression` into the current\n * element in a secure way.  By default, the innerHTML-ed content will be sanitized using the {@link\n * ngSanitize.$sanitize $sanitize} service.  To utilize this functionality, ensure that `$sanitize`\n * is available, for example, by including {@link ngSanitize} in your module's dependencies (not in\n * core Angular.)  You may also bypass sanitization for values you know are safe. To do so, bind to\n * an explicitly trusted value via {@link ng.$sce#trustAsHtml $sce.trustAsHtml}.  See the example\n * under {@link ng.$sce#Example Strict Contextual Escaping (SCE)}.\n *\n * Note: If a `$sanitize` service is unavailable and the bound value isn't explicitly trusted, you\n * will have an exception (instead of an exploit.)\n *\n * @element ANY\n * @param {expression} ngBindHtml {@link guide/expression Expression} to evaluate.\n */\nvar ngBindHtmlDirective = ['$sce', function($sce) {\n  return function(scope, element, attr) {\n    element.addClass('ng-binding').data('$binding', attr.ngBindHtml);\n    scope.$watch(attr.ngBindHtml, function ngBindHtmlWatchAction(value) {\n      element.html($sce.getTrustedHtml(value) || '');\n    });\n  };\n}];\n\nfunction classDirective(name, selector) {\n  name = 'ngClass' + name;\n  return function() {\n    return {\n      restrict: 'AC',\n      link: function(scope, element, attr) {\n        var oldVal = undefined;\n\n        scope.$watch(attr[name], ngClassWatchAction, true);\n\n        attr.$observe('class', function(value) {\n          ngClassWatchAction(scope.$eval(attr[name]));\n        });\n\n\n        if (name !== 'ngClass') {\n          scope.$watch('$index', function($index, old$index) {\n            var mod = $index & 1;\n            if (mod !== old$index & 1) {\n              if (mod === selector) {\n                addClass(scope.$eval(attr[name]));\n              } else {\n                removeClass(scope.$eval(attr[name]));\n              }\n            }\n          });\n        }\n\n\n        function ngClassWatchAction(newVal) {\n          if (selector === true || scope.$index % 2 === selector) {\n            if (oldVal && !equals(newVal,oldVal)) {\n              removeClass(oldVal);\n            }\n            addClass(newVal);\n          }\n          oldVal = copy(newVal);\n        }\n\n\n        function removeClass(classVal) {\n          attr.$removeClass(flattenClasses(classVal));\n        }\n\n\n        function addClass(classVal) {\n          attr.$addClass(flattenClasses(classVal));\n        }\n\n        function flattenClasses(classVal) {\n          if(isArray(classVal)) {\n            return classVal.join(' ');\n          } else if (isObject(classVal)) {\n            var classes = [], i = 0;\n            forEach(classVal, function(v, k) {\n              if (v) {\n                classes.push(k);\n              }\n            });\n            return classes.join(' ');\n          }\n\n          return classVal;\n        };\n      }\n    };\n  };\n}\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngClass\n *\n * @description\n * The `ngClass` allows you to set CSS classes on HTML an element, dynamically, by databinding\n * an expression that represents all classes to be added.\n *\n * The directive won't add duplicate classes if a particular class was already set.\n *\n * When the expression changes, the previously added classes are removed and only then the\n * new classes are added.\n *\n * @animations\n * add - happens just before the class is applied to the element\n * remove - happens just before the class is removed from the element\n *\n * @element ANY\n * @param {expression} ngClass {@link guide/expression Expression} to eval. The result\n *   of the evaluation can be a string representing space delimited class\n *   names, an array, or a map of class names to boolean values. In the case of a map, the\n *   names of the properties whose values are truthy will be added as css classes to the\n *   element.\n *\n * @example Example that demostrates basic bindings via ngClass directive.\n   <example>\n     <file name=\"index.html\">\n       <p ng-class=\"{strike: strike, bold: bold, red: red}\">Map Syntax Example</p>\n       <input type=\"checkbox\" ng-model=\"bold\"> bold\n       <input type=\"checkbox\" ng-model=\"strike\"> strike\n       <input type=\"checkbox\" ng-model=\"red\"> red\n       <hr>\n       <p ng-class=\"style\">Using String Syntax</p>\n       <input type=\"text\" ng-model=\"style\" placeholder=\"Type: bold strike red\">\n       <hr>\n       <p ng-class=\"[style1, style2, style3]\">Using Array Syntax</p>\n       <input ng-model=\"style1\" placeholder=\"Type: bold\"><br>\n       <input ng-model=\"style2\" placeholder=\"Type: strike\"><br>\n       <input ng-model=\"style3\" placeholder=\"Type: red\"><br>\n     </file>\n     <file name=\"style.css\">\n       .strike {\n         text-decoration: line-through;\n       }\n       .bold {\n           font-weight: bold;\n       }\n       .red {\n           color: red;\n       }\n     </file>\n     <file name=\"scenario.js\">\n       it('should let you toggle the class', function() {\n\n         expect(element('.doc-example-live p:first').prop('className')).not().toMatch(/bold/);\n         expect(element('.doc-example-live p:first').prop('className')).not().toMatch(/red/);\n\n         input('bold').check();\n         expect(element('.doc-example-live p:first').prop('className')).toMatch(/bold/);\n\n         input('red').check();\n         expect(element('.doc-example-live p:first').prop('className')).toMatch(/red/);\n       });\n\n       it('should let you toggle string example', function() {\n         expect(element('.doc-example-live p:nth-of-type(2)').prop('className')).toBe('');\n         input('style').enter('red');\n         expect(element('.doc-example-live p:nth-of-type(2)').prop('className')).toBe('red');\n       });\n\n       it('array example should have 3 classes', function() {\n         expect(element('.doc-example-live p:last').prop('className')).toBe('');\n         input('style1').enter('bold');\n         input('style2').enter('strike');\n         input('style3').enter('red');\n         expect(element('.doc-example-live p:last').prop('className')).toBe('bold strike red');\n       });\n     </file>\n   </example>\n\n   ## Animations\n\n   The example below demonstrates how to perform animations using ngClass.\n\n   <example animations=\"true\">\n     <file name=\"index.html\">\n      <input type=\"button\" value=\"set\" ng-click=\"myVar='my-class'\">\n      <input type=\"button\" value=\"clear\" ng-click=\"myVar=''\">\n      <br>\n      <span ng-class=\"myVar\">Sample Text</span>\n     </file>\n     <file name=\"style.css\">\n       .my-class-add, .my-class-remove {\n         -webkit-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;\n         -moz-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;\n         -o-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;\n         transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;\n       }\n\n       .my-class,\n       .my-class-add.my-class-add-active {\n         color: red;\n         font-size:3em;\n       }\n\n       .my-class-remove.my-class-remove-active {\n         font-size:1.0em;\n         color:black;\n       }\n     </file>\n     <file name=\"scenario.js\">\n       it('should check ng-class', function() {\n         expect(element('.doc-example-live span').prop('className')).not().\n           toMatch(/my-class/);\n\n         using('.doc-example-live').element(':button:first').click();\n\n         expect(element('.doc-example-live span').prop('className')).\n           toMatch(/my-class/);\n\n         using('.doc-example-live').element(':button:last').click();\n\n         expect(element('.doc-example-live span').prop('className')).not().\n           toMatch(/my-class/);\n       });\n     </file>\n   </example>\n\n\n   ## ngClass and pre-existing CSS3 Transitions/Animations\n   The ngClass directive still supports CSS3 Transitions/Animations even if they do not follow the ngAnimate CSS naming structure.\n   Therefore, if any CSS3 Transition/Animation styles (outside of ngAnimate) are set on the element, then, if a ngClass animation\n   is triggered, the ngClass animation will be skipped so that ngAnimate can allow for the pre-existing transition or animation to\n   take over. This restriction allows for ngClass to still work with standard CSS3 Transitions/Animations that are defined\n   outside of ngAnimate.\n */\nvar ngClassDirective = classDirective('', true);\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngClassOdd\n *\n * @description\n * The `ngClassOdd` and `ngClassEven` directives work exactly as\n * {@link ng.directive:ngClass ngClass}, except it works in\n * conjunction with `ngRepeat` and takes affect only on odd (even) rows.\n *\n * This directive can be applied only within a scope of an\n * {@link ng.directive:ngRepeat ngRepeat}.\n *\n * @element ANY\n * @param {expression} ngClassOdd {@link guide/expression Expression} to eval. The result\n *   of the evaluation can be a string representing space delimited class names or an array.\n *\n * @example\n   <example>\n     <file name=\"index.html\">\n        <ol ng-init=\"names=['John', 'Mary', 'Cate', 'Suz']\">\n          <li ng-repeat=\"name in names\">\n           <span ng-class-odd=\"'odd'\" ng-class-even=\"'even'\">\n             {{name}}\n           </span>\n          </li>\n        </ol>\n     </file>\n     <file name=\"style.css\">\n       .odd {\n         color: red;\n       }\n       .even {\n         color: blue;\n       }\n     </file>\n     <file name=\"scenario.js\">\n       it('should check ng-class-odd and ng-class-even', function() {\n         expect(element('.doc-example-live li:first span').prop('className')).\n           toMatch(/odd/);\n         expect(element('.doc-example-live li:last span').prop('className')).\n           toMatch(/even/);\n       });\n     </file>\n   </example>\n */\nvar ngClassOddDirective = classDirective('Odd', 0);\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngClassEven\n *\n * @description\n * The `ngClassOdd` and `ngClassEven` directives work exactly as\n * {@link ng.directive:ngClass ngClass}, except it works in\n * conjunction with `ngRepeat` and takes affect only on odd (even) rows.\n *\n * This directive can be applied only within a scope of an\n * {@link ng.directive:ngRepeat ngRepeat}.\n *\n * @element ANY\n * @param {expression} ngClassEven {@link guide/expression Expression} to eval. The\n *   result of the evaluation can be a string representing space delimited class names or an array.\n *\n * @example\n   <example>\n     <file name=\"index.html\">\n        <ol ng-init=\"names=['John', 'Mary', 'Cate', 'Suz']\">\n          <li ng-repeat=\"name in names\">\n           <span ng-class-odd=\"'odd'\" ng-class-even=\"'even'\">\n             {{name}} &nbsp; &nbsp; &nbsp;\n           </span>\n          </li>\n        </ol>\n     </file>\n     <file name=\"style.css\">\n       .odd {\n         color: red;\n       }\n       .even {\n         color: blue;\n       }\n     </file>\n     <file name=\"scenario.js\">\n       it('should check ng-class-odd and ng-class-even', function() {\n         expect(element('.doc-example-live li:first span').prop('className')).\n           toMatch(/odd/);\n         expect(element('.doc-example-live li:last span').prop('className')).\n           toMatch(/even/);\n       });\n     </file>\n   </example>\n */\nvar ngClassEvenDirective = classDirective('Even', 1);\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngCloak\n *\n * @description\n * The `ngCloak` directive is used to prevent the Angular html template from being briefly\n * displayed by the browser in its raw (uncompiled) form while your application is loading. Use this\n * directive to avoid the undesirable flicker effect caused by the html template display.\n *\n * The directive can be applied to the `<body>` element, but typically a fine-grained application is\n * preferred in order to benefit from progressive rendering of the browser view.\n *\n * `ngCloak` works in cooperation with a css rule that is embedded within `angular.js` and\n *  `angular.min.js` files. Following is the css rule:\n *\n * <pre>\n * [ng\\:cloak], [ng-cloak], [data-ng-cloak], [x-ng-cloak], .ng-cloak, .x-ng-cloak {\n *   display: none !important;\n * }\n * </pre>\n *\n * When this css rule is loaded by the browser, all html elements (including their children) that\n * are tagged with the `ng-cloak` directive are hidden. When Angular comes across this directive\n * during the compilation of the template it deletes the `ngCloak` element attribute, which\n * makes the compiled element visible.\n *\n * For the best result, `angular.js` script must be loaded in the head section of the html file;\n * alternatively, the css rule (above) must be included in the external stylesheet of the\n * application.\n *\n * Legacy browsers, like IE7, do not provide attribute selector support (added in CSS 2.1) so they\n * cannot match the `[ng\\:cloak]` selector. To work around this limitation, you must add the css\n * class `ngCloak` in addition to `ngCloak` directive as shown in the example below.\n *\n * @element ANY\n *\n * @example\n   <doc:example>\n     <doc:source>\n        <div id=\"template1\" ng-cloak>{{ 'hello' }}</div>\n        <div id=\"template2\" ng-cloak class=\"ng-cloak\">{{ 'hello IE7' }}</div>\n     </doc:source>\n     <doc:scenario>\n       it('should remove the template directive and css class', function() {\n         expect(element('.doc-example-live #template1').attr('ng-cloak')).\n           not().toBeDefined();\n         expect(element('.doc-example-live #template2').attr('ng-cloak')).\n           not().toBeDefined();\n       });\n     </doc:scenario>\n   </doc:example>\n *\n */\nvar ngCloakDirective = ngDirective({\n  compile: function(element, attr) {\n    attr.$set('ngCloak', undefined);\n    element.removeClass('ng-cloak');\n  }\n});\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngController\n *\n * @description\n * The `ngController` directive assigns behavior to a scope. This is a key aspect of how angular\n * supports the principles behind the Model-View-Controller design pattern.\n *\n * MVC components in angular:\n *\n * * Model — The Model is data in scope properties; scopes are attached to the DOM.\n * * View — The template (HTML with data bindings) is rendered into the View.\n * * Controller — The `ngController` directive specifies a Controller class; the class has\n *   methods that typically express the business logic behind the application.\n *\n * Note that an alternative way to define controllers is via the {@link ngRoute.$route $route} service.\n *\n * @element ANY\n * @scope\n * @param {expression} ngController Name of a globally accessible constructor function or an\n *     {@link guide/expression expression} that on the current scope evaluates to a\n *     constructor function. The controller instance can further be published into the scope\n *     by adding `as localName` the controller name attribute.\n *\n * @example\n * Here is a simple form for editing user contact information. Adding, removing, clearing, and\n * greeting are methods declared on the controller (see source tab). These methods can\n * easily be called from the angular markup. Notice that the scope becomes the `this` for the\n * controller's instance. This allows for easy access to the view data from the controller. Also\n * notice that any changes to the data are automatically reflected in the View without the need\n * for a manual update. The example is included in two different declaration styles based on\n * your style preferences.\n   <doc:example>\n     <doc:source>\n      <script>\n        function SettingsController1() {\n          this.name = \"John Smith\";\n          this.contacts = [\n            {type: 'phone', value: '408 555 1212'},\n            {type: 'email', value: 'john.smith@example.org'} ];\n          };\n\n        SettingsController1.prototype.greet = function() {\n          alert(this.name);\n        };\n\n        SettingsController1.prototype.addContact = function() {\n          this.contacts.push({type: 'email', value: 'yourname@example.org'});\n        };\n\n        SettingsController1.prototype.removeContact = function(contactToRemove) {\n         var index = this.contacts.indexOf(contactToRemove);\n          this.contacts.splice(index, 1);\n        };\n\n        SettingsController1.prototype.clearContact = function(contact) {\n          contact.type = 'phone';\n          contact.value = '';\n        };\n      </script>\n      <div id=\"ctrl-as-exmpl\" ng-controller=\"SettingsController1 as settings\">\n        Name: <input type=\"text\" ng-model=\"settings.name\"/>\n        [ <a href=\"\" ng-click=\"settings.greet()\">greet</a> ]<br/>\n        Contact:\n        <ul>\n          <li ng-repeat=\"contact in settings.contacts\">\n            <select ng-model=\"contact.type\">\n               <option>phone</option>\n               <option>email</option>\n            </select>\n            <input type=\"text\" ng-model=\"contact.value\"/>\n            [ <a href=\"\" ng-click=\"settings.clearContact(contact)\">clear</a>\n            | <a href=\"\" ng-click=\"settings.removeContact(contact)\">X</a> ]\n          </li>\n          <li>[ <a href=\"\" ng-click=\"settings.addContact()\">add</a> ]</li>\n       </ul>\n      </div>\n     </doc:source>\n     <doc:scenario>\n       it('should check controller as', function() {\n         expect(element('#ctrl-as-exmpl>:input').val()).toBe('John Smith');\n         expect(element('#ctrl-as-exmpl li:nth-child(1) input').val())\n           .toBe('408 555 1212');\n         expect(element('#ctrl-as-exmpl li:nth-child(2) input').val())\n           .toBe('john.smith@example.org');\n\n         element('#ctrl-as-exmpl li:first a:contains(\"clear\")').click();\n         expect(element('#ctrl-as-exmpl li:first input').val()).toBe('');\n\n         element('#ctrl-as-exmpl li:last a:contains(\"add\")').click();\n         expect(element('#ctrl-as-exmpl li:nth-child(3) input').val())\n           .toBe('yourname@example.org');\n       });\n     </doc:scenario>\n   </doc:example>\n    <doc:example>\n     <doc:source>\n      <script>\n        function SettingsController2($scope) {\n          $scope.name = \"John Smith\";\n          $scope.contacts = [\n            {type:'phone', value:'408 555 1212'},\n            {type:'email', value:'john.smith@example.org'} ];\n\n          $scope.greet = function() {\n           alert(this.name);\n          };\n\n          $scope.addContact = function() {\n           this.contacts.push({type:'email', value:'yourname@example.org'});\n          };\n\n          $scope.removeContact = function(contactToRemove) {\n           var index = this.contacts.indexOf(contactToRemove);\n           this.contacts.splice(index, 1);\n          };\n\n          $scope.clearContact = function(contact) {\n           contact.type = 'phone';\n           contact.value = '';\n          };\n        }\n      </script>\n      <div id=\"ctrl-exmpl\" ng-controller=\"SettingsController2\">\n        Name: <input type=\"text\" ng-model=\"name\"/>\n        [ <a href=\"\" ng-click=\"greet()\">greet</a> ]<br/>\n        Contact:\n        <ul>\n          <li ng-repeat=\"contact in contacts\">\n            <select ng-model=\"contact.type\">\n               <option>phone</option>\n               <option>email</option>\n            </select>\n            <input type=\"text\" ng-model=\"contact.value\"/>\n            [ <a href=\"\" ng-click=\"clearContact(contact)\">clear</a>\n            | <a href=\"\" ng-click=\"removeContact(contact)\">X</a> ]\n          </li>\n          <li>[ <a href=\"\" ng-click=\"addContact()\">add</a> ]</li>\n       </ul>\n      </div>\n     </doc:source>\n     <doc:scenario>\n       it('should check controller', function() {\n         expect(element('#ctrl-exmpl>:input').val()).toBe('John Smith');\n         expect(element('#ctrl-exmpl li:nth-child(1) input').val())\n           .toBe('408 555 1212');\n         expect(element('#ctrl-exmpl li:nth-child(2) input').val())\n           .toBe('john.smith@example.org');\n\n         element('#ctrl-exmpl li:first a:contains(\"clear\")').click();\n         expect(element('#ctrl-exmpl li:first input').val()).toBe('');\n\n         element('#ctrl-exmpl li:last a:contains(\"add\")').click();\n         expect(element('#ctrl-exmpl li:nth-child(3) input').val())\n           .toBe('yourname@example.org');\n       });\n     </doc:scenario>\n   </doc:example>\n\n */\nvar ngControllerDirective = [function() {\n  return {\n    scope: true,\n    controller: '@'\n  };\n}];\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngCsp\n * @priority 1000\n *\n * @element html\n * @description\n * Enables [CSP (Content Security Policy)](https://developer.mozilla.org/en/Security/CSP) support.\n * \n * This is necessary when developing things like Google Chrome Extensions.\n * \n * CSP forbids apps to use `eval` or `Function(string)` generated functions (among other things).\n * For us to be compatible, we just need to implement the \"getterFn\" in $parse without violating\n * any of these restrictions.\n * \n * AngularJS uses `Function(string)` generated functions as a speed optimization. By applying `ngCsp`\n * it is be possible to opt into the CSP compatible mode. When this mode is on AngularJS will\n * evaluate all expressions up to 30% slower than in non-CSP mode, but no security violations will\n * be raised.\n * \n * In order to use this feature put `ngCsp` directive on the root element of the application.\n * \n * @example\n * This example shows how to apply the `ngCsp` directive to the `html` tag.\n   <pre>\n     <!doctype html>\n     <html ng-app ng-csp>\n     ...\n     ...\n     </html>\n   </pre>\n */\n\nvar ngCspDirective = ['$sniffer', function($sniffer) {\n  return {\n    priority: 1000,\n    compile: function() {\n      $sniffer.csp = true;\n    }\n  };\n}];\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngClick\n *\n * @description\n * The ngClick allows you to specify custom behavior when\n * element is clicked.\n *\n * @element ANY\n * @param {expression} ngClick {@link guide/expression Expression} to evaluate upon\n * click. (Event object is available as `$event`)\n *\n * @example\n   <doc:example>\n     <doc:source>\n      <button ng-click=\"count = count + 1\" ng-init=\"count=0\">\n        Increment\n      </button>\n      count: {{count}}\n     </doc:source>\n     <doc:scenario>\n       it('should check ng-click', function() {\n         expect(binding('count')).toBe('0');\n         element('.doc-example-live :button').click();\n         expect(binding('count')).toBe('1');\n       });\n     </doc:scenario>\n   </doc:example>\n */\n/*\n * A directive that allows creation of custom onclick handlers that are defined as angular\n * expressions and are compiled and executed within the current scope.\n *\n * Events that are handled via these handler are always configured not to propagate further.\n */\nvar ngEventDirectives = {};\nforEach(\n  'click dblclick mousedown mouseup mouseover mouseout mousemove mouseenter mouseleave keydown keyup keypress submit focus blur'.split(' '),\n  function(name) {\n    var directiveName = directiveNormalize('ng-' + name);\n    ngEventDirectives[directiveName] = ['$parse', function($parse) {\n      return function(scope, element, attr) {\n        var fn = $parse(attr[directiveName]);\n        element.on(lowercase(name), function(event) {\n          scope.$apply(function() {\n            fn(scope, {$event:event});\n          });\n        });\n      };\n    }];\n  }\n);\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngDblclick\n *\n * @description\n * The `ngDblclick` directive allows you to specify custom behavior on dblclick event.\n *\n * @element ANY\n * @param {expression} ngDblclick {@link guide/expression Expression} to evaluate upon\n * dblclick. (Event object is available as `$event`)\n *\n * @example\n * See {@link ng.directive:ngClick ngClick}\n */\n\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngMousedown\n *\n * @description\n * The ngMousedown directive allows you to specify custom behavior on mousedown event.\n *\n * @element ANY\n * @param {expression} ngMousedown {@link guide/expression Expression} to evaluate upon\n * mousedown. (Event object is available as `$event`)\n *\n * @example\n * See {@link ng.directive:ngClick ngClick}\n */\n\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngMouseup\n *\n * @description\n * Specify custom behavior on mouseup event.\n *\n * @element ANY\n * @param {expression} ngMouseup {@link guide/expression Expression} to evaluate upon\n * mouseup. (Event object is available as `$event`)\n *\n * @example\n * See {@link ng.directive:ngClick ngClick}\n */\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngMouseover\n *\n * @description\n * Specify custom behavior on mouseover event.\n *\n * @element ANY\n * @param {expression} ngMouseover {@link guide/expression Expression} to evaluate upon\n * mouseover. (Event object is available as `$event`)\n *\n * @example\n * See {@link ng.directive:ngClick ngClick}\n */\n\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngMouseenter\n *\n * @description\n * Specify custom behavior on mouseenter event.\n *\n * @element ANY\n * @param {expression} ngMouseenter {@link guide/expression Expression} to evaluate upon\n * mouseenter. (Event object is available as `$event`)\n *\n * @example\n * See {@link ng.directive:ngClick ngClick}\n */\n\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngMouseleave\n *\n * @description\n * Specify custom behavior on mouseleave event.\n *\n * @element ANY\n * @param {expression} ngMouseleave {@link guide/expression Expression} to evaluate upon\n * mouseleave. (Event object is available as `$event`)\n *\n * @example\n * See {@link ng.directive:ngClick ngClick}\n */\n\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngMousemove\n *\n * @description\n * Specify custom behavior on mousemove event.\n *\n * @element ANY\n * @param {expression} ngMousemove {@link guide/expression Expression} to evaluate upon\n * mousemove. (Event object is available as `$event`)\n *\n * @example\n * See {@link ng.directive:ngClick ngClick}\n */\n\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngKeydown\n *\n * @description\n * Specify custom behavior on keydown event.\n *\n * @element ANY\n * @param {expression} ngKeydown {@link guide/expression Expression} to evaluate upon\n * keydown. (Event object is available as `$event` and can be interrogated for keyCode, altKey, etc.)\n *\n * @example\n * See {@link ng.directive:ngClick ngClick}\n */\n\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngKeyup\n *\n * @description\n * Specify custom behavior on keyup event.\n *\n * @element ANY\n * @param {expression} ngKeyup {@link guide/expression Expression} to evaluate upon\n * keyup. (Event object is available as `$event` and can be interrogated for keyCode, altKey, etc.)\n *\n * @example\n * See {@link ng.directive:ngClick ngClick}\n */\n\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngKeypress\n *\n * @description\n * Specify custom behavior on keypress event.\n *\n * @element ANY\n * @param {expression} ngKeypress {@link guide/expression Expression} to evaluate upon\n * keypress. (Event object is available as `$event` and can be interrogated for keyCode, altKey, etc.)\n *\n * @example\n * See {@link ng.directive:ngClick ngClick}\n */\n\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngSubmit\n *\n * @description\n * Enables binding angular expressions to onsubmit events.\n *\n * Additionally it prevents the default action (which for form means sending the request to the\n * server and reloading the current page) **but only if the form does not contain an `action`\n * attribute**.\n *\n * @element form\n * @param {expression} ngSubmit {@link guide/expression Expression} to eval. (Event object is available as `$event`)\n *\n * @example\n   <doc:example>\n     <doc:source>\n      <script>\n        function Ctrl($scope) {\n          $scope.list = [];\n          $scope.text = 'hello';\n          $scope.submit = function() {\n            if (this.text) {\n              this.list.push(this.text);\n              this.text = '';\n            }\n          };\n        }\n      </script>\n      <form ng-submit=\"submit()\" ng-controller=\"Ctrl\">\n        Enter text and hit enter:\n        <input type=\"text\" ng-model=\"text\" name=\"text\" />\n        <input type=\"submit\" id=\"submit\" value=\"Submit\" />\n        <pre>list={{list}}</pre>\n      </form>\n     </doc:source>\n     <doc:scenario>\n       it('should check ng-submit', function() {\n         expect(binding('list')).toBe('[]');\n         element('.doc-example-live #submit').click();\n         expect(binding('list')).toBe('[\"hello\"]');\n         expect(input('text').val()).toBe('');\n       });\n       it('should ignore empty strings', function() {\n         expect(binding('list')).toBe('[]');\n         element('.doc-example-live #submit').click();\n         element('.doc-example-live #submit').click();\n         expect(binding('list')).toBe('[\"hello\"]');\n       });\n     </doc:scenario>\n   </doc:example>\n */\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngFocus\n *\n * @description\n * Specify custom behavior on focus event.\n *\n * @element window, input, select, textarea, a\n * @param {expression} ngFocus {@link guide/expression Expression} to evaluate upon\n * focus. (Event object is available as `$event`)\n *\n * @example\n * See {@link ng.directive:ngClick ngClick}\n */\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngBlur\n *\n * @description\n * Specify custom behavior on blur event.\n *\n * @element window, input, select, textarea, a\n * @param {expression} ngBlur {@link guide/expression Expression} to evaluate upon\n * blur. (Event object is available as `$event`)\n *\n * @example\n * See {@link ng.directive:ngClick ngClick}\n */\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngIf\n * @restrict A\n *\n * @description\n * The `ngIf` directive removes and recreates a portion of the DOM tree (HTML)\n * conditionally based on **\"falsy\"** and **\"truthy\"** values, respectively, evaluated within\n * an {expression}. In other words, if the expression assigned to **ngIf evaluates to a false\n * value** then **the element is removed from the DOM** and **if true** then **a clone of the\n * element is reinserted into the DOM**.\n *\n * `ngIf` differs from `ngShow` and `ngHide` in that `ngIf` completely removes and recreates the\n * element in the DOM rather than changing its visibility via the `display` css property.  A common\n * case when this difference is significant is when using css selectors that rely on an element's\n * position within the DOM (HTML), such as the `:first-child` or `:last-child` pseudo-classes.\n *\n * Note that **when an element is removed using ngIf its scope is destroyed** and **a new scope\n * is created when the element is restored**.  The scope created within `ngIf` inherits from \n * its parent scope using\n * {@link https://github.com/angular/angular.js/wiki/The-Nuances-of-Scope-Prototypal-Inheritance prototypal inheritance}.\n * An important implication of this is if `ngModel` is used within `ngIf` to bind to\n * a javascript primitive defined in the parent scope. In this case any modifications made to the\n * variable within the child scope will override (hide) the value in the parent scope.\n *\n * Also, `ngIf` recreates elements using their compiled state. An example scenario of this behavior\n * is if an element's class attribute is directly modified after it's compiled, using something like \n * jQuery's `.addClass()` method, and the element is later removed. When `ngIf` recreates the element\n * the added class will be lost because the original compiled state is used to regenerate the element.\n *\n * Additionally, you can provide animations via the ngAnimate module to animate the **enter**\n * and **leave** effects.\n *\n * @animations\n * enter - happens just after the ngIf contents change and a new DOM element is created and injected into the ngIf container\n * leave - happens just before the ngIf contents are removed from the DOM\n *\n * @element ANY\n * @scope\n * @param {expression} ngIf If the {@link guide/expression expression} is falsy then\n *     the element is removed from the DOM tree (HTML).\n *\n * @example\n  <example animations=\"true\">\n    <file name=\"index.html\">\n      Click me: <input type=\"checkbox\" ng-model=\"checked\" ng-init=\"checked=true\" /><br/>\n      Show when checked:\n      <span ng-if=\"checked\" class=\"animate-if\">\n        I'm removed when the checkbox is unchecked.\n      </span>\n    </file>\n    <file name=\"animations.css\">\n      .animate-if {\n        background:white;\n        border:1px solid black;\n        padding:10px;\n      }\n\n      .animate-if.ng-enter, .animate-if.ng-leave {\n        -webkit-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;\n        -moz-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;\n        -o-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;\n        transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;\n      }\n\n      .animate-if.ng-enter,\n      .animate-if.ng-leave.ng-leave-active {\n        opacity:0;\n      }\n\n      .animate-if.ng-enter.ng-enter-active,\n      .animate-if.ng-leave {\n        opacity:1;\n      }\n    </file>\n  </example>\n */\nvar ngIfDirective = ['$animate', function($animate) {\n  return {\n    transclude: 'element',\n    priority: 1000,\n    terminal: true,\n    restrict: 'A',\n    compile: function (element, attr, transclude) {\n      return function ($scope, $element, $attr) {\n        var childElement, childScope;\n        $scope.$watch($attr.ngIf, function ngIfWatchAction(value) {\n          if (childElement) {\n            $animate.leave(childElement);\n            childElement = undefined;\n          }\n          if (childScope) {\n            childScope.$destroy();\n            childScope = undefined;\n          }\n          if (toBoolean(value)) {\n            childScope = $scope.$new();\n            transclude(childScope, function (clone) {\n              childElement = clone;\n              $animate.enter(clone, $element.parent(), $element);\n            });\n          }\n        });\n      }\n    }\n  }\n}];\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngInclude\n * @restrict ECA\n *\n * @description\n * Fetches, compiles and includes an external HTML fragment.\n *\n * Keep in mind that:\n *\n * -    by default, the template URL is restricted to the same domain and protocol as the\n *      application document.  This is done by calling {@link ng.$sce#getTrustedResourceUrl\n *      $sce.getTrustedResourceUrl} on it.  To load templates from other domains and/or protocols,\n *      you may either either {@link ng.$sceDelegateProvider#resourceUrlWhitelist whitelist them} or\n *      {@link ng.$sce#trustAsResourceUrl wrap it} into a trusted value.  Refer Angular's {@link\n *      ng.$sce Strict Contextual Escaping}.\n * -    in addition, the browser's\n *      {@link https://code.google.com/p/browsersec/wiki/Part2#Same-origin_policy_for_XMLHttpRequest\n *      Same Origin Policy} and {@link http://www.w3.org/TR/cors/ Cross-Origin Resource Sharing\n *      (CORS)} policy apply that may further restrict whether the template is successfully loaded.\n *      (e.g.  ngInclude won't work for cross-domain requests on all browsers and for `file://`\n *      access on some browsers)\n *\n * @animations\n * enter - animation is used to bring new content into the browser.\n * leave - animation is used to animate existing content away.\n *\n * The enter and leave animation occur concurrently.\n *\n * @scope\n *\n * @param {string} ngInclude|src angular expression evaluating to URL. If the source is a string constant,\n *                 make sure you wrap it in quotes, e.g. `src=\"'myPartialTemplate.html'\"`.\n * @param {string=} onload Expression to evaluate when a new partial is loaded.\n *\n * @param {string=} autoscroll Whether `ngInclude` should call {@link ng.$anchorScroll\n *                  $anchorScroll} to scroll the viewport after the content is loaded.\n *\n *                  - If the attribute is not set, disable scrolling.\n *                  - If the attribute is set without value, enable scrolling.\n *                  - Otherwise enable scrolling only if the expression evaluates to truthy value.\n *\n * @example\n  <example animations=\"true\">\n    <file name=\"index.html\">\n     <div ng-controller=\"Ctrl\">\n       <select ng-model=\"template\" ng-options=\"t.name for t in templates\">\n        <option value=\"\">(blank)</option>\n       </select>\n       url of the template: <tt>{{template.url}}</tt>\n       <hr/>\n       <div class=\"example-animate-container\">\n         <div class=\"include-example\" ng-include=\"template.url\"></div>\n       </div>\n     </div>\n    </file>\n    <file name=\"script.js\">\n      function Ctrl($scope) {\n        $scope.templates =\n          [ { name: 'template1.html', url: 'template1.html'}\n          , { name: 'template2.html', url: 'template2.html'} ];\n        $scope.template = $scope.templates[0];\n      }\n     </file>\n    <file name=\"template1.html\">\n      Content of template1.html\n    </file>\n    <file name=\"template2.html\">\n      Content of template2.html\n    </file>\n    <file name=\"animations.css\">\n      .example-animate-container {\n        position:relative;\n        background:white;\n        border:1px solid black;\n        height:40px;\n        overflow:hidden;\n      }\n\n      .example-animate-container > div {\n        padding:10px;\n      }\n\n      .include-example.ng-enter, .include-example.ng-leave {\n        -webkit-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;\n        -moz-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;\n        -o-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;\n        transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;\n\n        position:absolute;\n        top:0;\n        left:0;\n        right:0;\n        bottom:0;\n        display:block;\n        padding:10px;\n      }\n\n      .include-example.ng-enter {\n        top:-50px;\n      }\n      .include-example.ng-enter.ng-enter-active {\n        top:0;\n      }\n\n      .include-example.ng-leave {\n        top:0;\n      }\n      .include-example.ng-leave.ng-leave-active {\n        top:50px;\n      }\n    </file>\n    <file name=\"scenario.js\">\n      it('should load template1.html', function() {\n       expect(element('.doc-example-live [ng-include]').text()).\n         toMatch(/Content of template1.html/);\n      });\n      it('should load template2.html', function() {\n       select('template').option('1');\n       expect(element('.doc-example-live [ng-include]').text()).\n         toMatch(/Content of template2.html/);\n      });\n      it('should change to blank', function() {\n       select('template').option('');\n       expect(element('.doc-example-live [ng-include]')).toBe(undefined);\n      });\n    </file>\n  </example>\n */\n\n\n/**\n * @ngdoc event\n * @name ng.directive:ngInclude#$includeContentRequested\n * @eventOf ng.directive:ngInclude\n * @eventType emit on the scope ngInclude was declared in\n * @description\n * Emitted every time the ngInclude content is requested.\n */\n\n\n/**\n * @ngdoc event\n * @name ng.directive:ngInclude#$includeContentLoaded\n * @eventOf ng.directive:ngInclude\n * @eventType emit on the current ngInclude scope\n * @description\n * Emitted every time the ngInclude content is reloaded.\n */\nvar ngIncludeDirective = ['$http', '$templateCache', '$anchorScroll', '$compile', '$animate', '$sce',\n                  function($http,   $templateCache,   $anchorScroll,   $compile,   $animate,   $sce) {\n  return {\n    restrict: 'ECA',\n    terminal: true,\n    transclude: 'element',\n    compile: function(element, attr, transclusion) {\n      var srcExp = attr.ngInclude || attr.src,\n          onloadExp = attr.onload || '',\n          autoScrollExp = attr.autoscroll;\n\n      return function(scope, $element) {\n        var changeCounter = 0,\n            currentScope,\n            currentElement;\n\n        var cleanupLastIncludeContent = function() {\n          if (currentScope) {\n            currentScope.$destroy();\n            currentScope = null;\n          }\n          if(currentElement) {\n            $animate.leave(currentElement);\n            currentElement = null;\n          }\n        };\n\n        scope.$watch($sce.parseAsResourceUrl(srcExp), function ngIncludeWatchAction(src) {\n          var thisChangeId = ++changeCounter;\n\n          if (src) {\n            $http.get(src, {cache: $templateCache}).success(function(response) {\n              if (thisChangeId !== changeCounter) return;\n              var newScope = scope.$new();\n\n              transclusion(newScope, function(clone) {\n                cleanupLastIncludeContent();\n\n                currentScope = newScope;\n                currentElement = clone;\n\n                currentElement.html(response);\n                $animate.enter(currentElement, null, $element);\n                $compile(currentElement.contents())(currentScope);\n\n                if (isDefined(autoScrollExp) && (!autoScrollExp || scope.$eval(autoScrollExp))) {\n                  $anchorScroll();\n                }\n\n                currentScope.$emit('$includeContentLoaded');\n                scope.$eval(onloadExp);\n              });\n            }).error(function() {\n              if (thisChangeId === changeCounter) cleanupLastIncludeContent();\n            });\n            scope.$emit('$includeContentRequested');\n          } else {\n            cleanupLastIncludeContent();\n          }\n        });\n      };\n    }\n  };\n}];\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngInit\n *\n * @description\n * The `ngInit` directive specifies initialization tasks to be executed\n *  before the template enters execution mode during bootstrap.\n *\n * @element ANY\n * @param {expression} ngInit {@link guide/expression Expression} to eval.\n *\n * @example\n   <doc:example>\n     <doc:source>\n    <div ng-init=\"greeting='Hello'; person='World'\">\n      {{greeting}} {{person}}!\n    </div>\n     </doc:source>\n     <doc:scenario>\n       it('should check greeting', function() {\n         expect(binding('greeting')).toBe('Hello');\n         expect(binding('person')).toBe('World');\n       });\n     </doc:scenario>\n   </doc:example>\n */\nvar ngInitDirective = ngDirective({\n  compile: function() {\n    return {\n      pre: function(scope, element, attrs) {\n        scope.$eval(attrs.ngInit);\n      }\n    }\n  }\n});\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngNonBindable\n * @priority 1000\n *\n * @description\n * Sometimes it is necessary to write code which looks like bindings but which should be left alone\n * by angular. Use `ngNonBindable` to make angular ignore a chunk of HTML.\n *\n * @element ANY\n *\n * @example\n * In this example there are two location where a simple binding (`{{}}`) is present, but the one\n * wrapped in `ngNonBindable` is left alone.\n *\n * @example\n    <doc:example>\n      <doc:source>\n        <div>Normal: {{1 + 2}}</div>\n        <div ng-non-bindable>Ignored: {{1 + 2}}</div>\n      </doc:source>\n      <doc:scenario>\n       it('should check ng-non-bindable', function() {\n         expect(using('.doc-example-live').binding('1 + 2')).toBe('3');\n         expect(using('.doc-example-live').element('div:last').text()).\n           toMatch(/1 \\+ 2/);\n       });\n      </doc:scenario>\n    </doc:example>\n */\nvar ngNonBindableDirective = ngDirective({ terminal: true, priority: 1000 });\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngPluralize\n * @restrict EA\n *\n * @description\n * # Overview\n * `ngPluralize` is a directive that displays messages according to en-US localization rules.\n * These rules are bundled with angular.js, but can be overridden\n * (see {@link guide/i18n Angular i18n} dev guide). You configure ngPluralize directive\n * by specifying the mappings between\n * {@link http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/language_plural_rules.html\n * plural categories} and the strings to be displayed.\n *\n * # Plural categories and explicit number rules\n * There are two\n * {@link http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/language_plural_rules.html\n * plural categories} in Angular's default en-US locale: \"one\" and \"other\".\n *\n * While a plural category may match many numbers (for example, in en-US locale, \"other\" can match\n * any number that is not 1), an explicit number rule can only match one number. For example, the\n * explicit number rule for \"3\" matches the number 3. There are examples of plural categories\n * and explicit number rules throughout the rest of this documentation.\n *\n * # Configuring ngPluralize\n * You configure ngPluralize by providing 2 attributes: `count` and `when`.\n * You can also provide an optional attribute, `offset`.\n *\n * The value of the `count` attribute can be either a string or an {@link guide/expression\n * Angular expression}; these are evaluated on the current scope for its bound value.\n *\n * The `when` attribute specifies the mappings between plural categories and the actual\n * string to be displayed. The value of the attribute should be a JSON object.\n *\n * The following example shows how to configure ngPluralize:\n *\n * <pre>\n * <ng-pluralize count=\"personCount\"\n                 when=\"{'0': 'Nobody is viewing.',\n *                      'one': '1 person is viewing.',\n *                      'other': '{} people are viewing.'}\">\n * </ng-pluralize>\n *</pre>\n *\n * In the example, `\"0: Nobody is viewing.\"` is an explicit number rule. If you did not\n * specify this rule, 0 would be matched to the \"other\" category and \"0 people are viewing\"\n * would be shown instead of \"Nobody is viewing\". You can specify an explicit number rule for\n * other numbers, for example 12, so that instead of showing \"12 people are viewing\", you can\n * show \"a dozen people are viewing\".\n *\n * You can use a set of closed braces(`{}`) as a placeholder for the number that you want substituted\n * into pluralized strings. In the previous example, Angular will replace `{}` with\n * <span ng-non-bindable>`{{personCount}}`</span>. The closed braces `{}` is a placeholder\n * for <span ng-non-bindable>{{numberExpression}}</span>.\n *\n * # Configuring ngPluralize with offset\n * The `offset` attribute allows further customization of pluralized text, which can result in\n * a better user experience. For example, instead of the message \"4 people are viewing this document\",\n * you might display \"John, Kate and 2 others are viewing this document\".\n * The offset attribute allows you to offset a number by any desired value.\n * Let's take a look at an example:\n *\n * <pre>\n * <ng-pluralize count=\"personCount\" offset=2\n *               when=\"{'0': 'Nobody is viewing.',\n *                      '1': '{{person1}} is viewing.',\n *                      '2': '{{person1}} and {{person2}} are viewing.',\n *                      'one': '{{person1}}, {{person2}} and one other person are viewing.',\n *                      'other': '{{person1}}, {{person2}} and {} other people are viewing.'}\">\n * </ng-pluralize>\n * </pre>\n *\n * Notice that we are still using two plural categories(one, other), but we added\n * three explicit number rules 0, 1 and 2.\n * When one person, perhaps John, views the document, \"John is viewing\" will be shown.\n * When three people view the document, no explicit number rule is found, so\n * an offset of 2 is taken off 3, and Angular uses 1 to decide the plural category.\n * In this case, plural category 'one' is matched and \"John, Marry and one other person are viewing\"\n * is shown.\n *\n * Note that when you specify offsets, you must provide explicit number rules for\n * numbers from 0 up to and including the offset. If you use an offset of 3, for example,\n * you must provide explicit number rules for 0, 1, 2 and 3. You must also provide plural strings for\n * plural categories \"one\" and \"other\".\n *\n * @param {string|expression} count The variable to be bounded to.\n * @param {string} when The mapping between plural category to its corresponding strings.\n * @param {number=} offset Offset to deduct from the total number.\n *\n * @example\n    <doc:example>\n      <doc:source>\n        <script>\n          function Ctrl($scope) {\n            $scope.person1 = 'Igor';\n            $scope.person2 = 'Misko';\n            $scope.personCount = 1;\n          }\n        </script>\n        <div ng-controller=\"Ctrl\">\n          Person 1:<input type=\"text\" ng-model=\"person1\" value=\"Igor\" /><br/>\n          Person 2:<input type=\"text\" ng-model=\"person2\" value=\"Misko\" /><br/>\n          Number of People:<input type=\"text\" ng-model=\"personCount\" value=\"1\" /><br/>\n\n          <!--- Example with simple pluralization rules for en locale --->\n          Without Offset:\n          <ng-pluralize count=\"personCount\"\n                        when=\"{'0': 'Nobody is viewing.',\n                               'one': '1 person is viewing.',\n                               'other': '{} people are viewing.'}\">\n          </ng-pluralize><br>\n\n          <!--- Example with offset --->\n          With Offset(2):\n          <ng-pluralize count=\"personCount\" offset=2\n                        when=\"{'0': 'Nobody is viewing.',\n                               '1': '{{person1}} is viewing.',\n                               '2': '{{person1}} and {{person2}} are viewing.',\n                               'one': '{{person1}}, {{person2}} and one other person are viewing.',\n                               'other': '{{person1}}, {{person2}} and {} other people are viewing.'}\">\n          </ng-pluralize>\n        </div>\n      </doc:source>\n      <doc:scenario>\n        it('should show correct pluralized string', function() {\n          expect(element('.doc-example-live ng-pluralize:first').text()).\n                                             toBe('1 person is viewing.');\n          expect(element('.doc-example-live ng-pluralize:last').text()).\n                                                toBe('Igor is viewing.');\n\n          using('.doc-example-live').input('personCount').enter('0');\n          expect(element('.doc-example-live ng-pluralize:first').text()).\n                                               toBe('Nobody is viewing.');\n          expect(element('.doc-example-live ng-pluralize:last').text()).\n                                              toBe('Nobody is viewing.');\n\n          using('.doc-example-live').input('personCount').enter('2');\n          expect(element('.doc-example-live ng-pluralize:first').text()).\n                                            toBe('2 people are viewing.');\n          expect(element('.doc-example-live ng-pluralize:last').text()).\n                              toBe('Igor and Misko are viewing.');\n\n          using('.doc-example-live').input('personCount').enter('3');\n          expect(element('.doc-example-live ng-pluralize:first').text()).\n                                            toBe('3 people are viewing.');\n          expect(element('.doc-example-live ng-pluralize:last').text()).\n                              toBe('Igor, Misko and one other person are viewing.');\n\n          using('.doc-example-live').input('personCount').enter('4');\n          expect(element('.doc-example-live ng-pluralize:first').text()).\n                                            toBe('4 people are viewing.');\n          expect(element('.doc-example-live ng-pluralize:last').text()).\n                              toBe('Igor, Misko and 2 other people are viewing.');\n        });\n\n        it('should show data-binded names', function() {\n          using('.doc-example-live').input('personCount').enter('4');\n          expect(element('.doc-example-live ng-pluralize:last').text()).\n              toBe('Igor, Misko and 2 other people are viewing.');\n\n          using('.doc-example-live').input('person1').enter('Di');\n          using('.doc-example-live').input('person2').enter('Vojta');\n          expect(element('.doc-example-live ng-pluralize:last').text()).\n              toBe('Di, Vojta and 2 other people are viewing.');\n        });\n      </doc:scenario>\n    </doc:example>\n */\nvar ngPluralizeDirective = ['$locale', '$interpolate', function($locale, $interpolate) {\n  var BRACE = /{}/g;\n  return {\n    restrict: 'EA',\n    link: function(scope, element, attr) {\n      var numberExp = attr.count,\n          whenExp = attr.$attr.when && element.attr(attr.$attr.when), // we have {{}} in attrs\n          offset = attr.offset || 0,\n          whens = scope.$eval(whenExp) || {},\n          whensExpFns = {},\n          startSymbol = $interpolate.startSymbol(),\n          endSymbol = $interpolate.endSymbol(),\n          isWhen = /^when(Minus)?(.+)$/;\n\n      forEach(attr, function(expression, attributeName) {\n        if (isWhen.test(attributeName)) {\n          whens[lowercase(attributeName.replace('when', '').replace('Minus', '-'))] =\n            element.attr(attr.$attr[attributeName]);\n        }\n      });\n      forEach(whens, function(expression, key) {\n        whensExpFns[key] =\n          $interpolate(expression.replace(BRACE, startSymbol + numberExp + '-' +\n            offset + endSymbol));\n      });\n\n      scope.$watch(function ngPluralizeWatch() {\n        var value = parseFloat(scope.$eval(numberExp));\n\n        if (!isNaN(value)) {\n          //if explicit number rule such as 1, 2, 3... is defined, just use it. Otherwise,\n          //check it against pluralization rules in $locale service\n          if (!(value in whens)) value = $locale.pluralCat(value - offset);\n           return whensExpFns[value](scope, element, true);\n        } else {\n          return '';\n        }\n      }, function ngPluralizeWatchAction(newVal) {\n        element.text(newVal);\n      });\n    }\n  };\n}];\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngRepeat\n *\n * @description\n * The `ngRepeat` directive instantiates a template once per item from a collection. Each template\n * instance gets its own scope, where the given loop variable is set to the current collection item,\n * and `$index` is set to the item index or key.\n *\n * Special properties are exposed on the local scope of each template instance, including:\n *\n * | Variable  | Type            | Details                                                                     |\n * |-----------|-----------------|-----------------------------------------------------------------------------|\n * | `$index`  | {@type number}  | iterator offset of the repeated element (0..length-1)                       |\n * | `$first`  | {@type boolean} | true if the repeated element is first in the iterator.                      |\n * | `$middle` | {@type boolean} | true if the repeated element is between the first and last in the iterator. |\n * | `$last`   | {@type boolean} | true if the repeated element is last in the iterator.                       |\n * | `$even`   | {@type boolean} | true if the iterator position `$index` is even (otherwise false).           |\n * | `$odd`    | {@type boolean} | true if the iterator position `$index` is odd (otherwise false).            |\n *\n *\n * # Special repeat start and end points\n * To repeat a series of elements instead of just one parent element, ngRepeat (as well as other ng directives) supports extending\n * the range of the repeater by defining explicit start and end points by using **ng-repeat-start** and **ng-repeat-end** respectively.\n * The **ng-repeat-start** directive works the same as **ng-repeat**, but will repeat all the HTML code (including the tag it's defined on)\n * up to and including the ending HTML tag where **ng-repeat-end** is placed.\n *\n * The example below makes use of this feature:\n * <pre>\n *   <header ng-repeat-start=\"item in items\">\n *     Header {{ item }}\n *   </header>\n *   <div class=\"body\">\n *     Body {{ item }}\n *   </div>\n *   <footer ng-repeat-end>\n *     Footer {{ item }}\n *   </footer>\n * </pre>\n *\n * And with an input of {@type ['A','B']} for the items variable in the example above, the output will evaluate to:\n * <pre>\n *   <header>\n *     Header A\n *   </header>\n *   <div class=\"body\">\n *     Body A\n *   </div>\n *   <footer>\n *     Footer A\n *   </footer>\n *   <header>\n *     Header B\n *   </header>\n *   <div class=\"body\">\n *     Body B\n *   </div>\n *   <footer>\n *     Footer B\n *   </footer>\n * </pre>\n *\n * The custom start and end points for ngRepeat also support all other HTML directive syntax flavors provided in AngularJS (such\n * as **data-ng-repeat-start**, **x-ng-repeat-start** and **ng:repeat-start**).\n *\n * @animations\n * enter - when a new item is added to the list or when an item is revealed after a filter\n * leave - when an item is removed from the list or when an item is filtered out\n * move - when an adjacent item is filtered out causing a reorder or when the item contents are reordered\n *\n * @element ANY\n * @scope\n * @priority 1000\n * @param {repeat_expression} ngRepeat The expression indicating how to enumerate a collection. These\n *   formats are currently supported:\n *\n *   * `variable in expression` – where variable is the user defined loop variable and `expression`\n *     is a scope expression giving the collection to enumerate.\n *\n *     For example: `album in artist.albums`.\n *\n *   * `(key, value) in expression` – where `key` and `value` can be any user defined identifiers,\n *     and `expression` is the scope expression giving the collection to enumerate.\n *\n *     For example: `(name, age) in {'adam':10, 'amalie':12}`.\n *\n *   * `variable in expression track by tracking_expression` – You can also provide an optional tracking function\n *     which can be used to associate the objects in the collection with the DOM elements. If no tracking function\n *     is specified the ng-repeat associates elements by identity in the collection. It is an error to have\n *     more than one tracking function to resolve to the same key. (This would mean that two distinct objects are\n *     mapped to the same DOM element, which is not possible.)  Filters should be applied to the expression,\n *     before specifying a tracking expression.\n *\n *     For example: `item in items` is equivalent to `item in items track by $id(item)'. This implies that the DOM elements\n *     will be associated by item identity in the array.\n *\n *     For example: `item in items track by $id(item)`. A built in `$id()` function can be used to assign a unique\n *     `$$hashKey` property to each item in the array. This property is then used as a key to associated DOM elements\n *     with the corresponding item in the array by identity. Moving the same object in array would move the DOM\n *     element in the same way ian the DOM.\n *\n *     For example: `item in items track by item.id` is a typical pattern when the items come from the database. In this\n *     case the object identity does not matter. Two objects are considered equivalent as long as their `id`\n *     property is same.\n *\n *     For example: `item in items | filter:searchText track by item.id` is a pattern that might be used to apply a filter\n *     to items in conjunction with a tracking expression.\n *\n * @example\n * This example initializes the scope to a list of names and\n * then uses `ngRepeat` to display every person:\n  <example animations=\"true\">\n    <file name=\"index.html\">\n      <div ng-init=\"friends = [\n        {name:'John', age:25, gender:'boy'},\n        {name:'Jessie', age:30, gender:'girl'},\n        {name:'Johanna', age:28, gender:'girl'},\n        {name:'Joy', age:15, gender:'girl'},\n        {name:'Mary', age:28, gender:'girl'},\n        {name:'Peter', age:95, gender:'boy'},\n        {name:'Sebastian', age:50, gender:'boy'},\n        {name:'Erika', age:27, gender:'girl'},\n        {name:'Patrick', age:40, gender:'boy'},\n        {name:'Samantha', age:60, gender:'girl'}\n      ]\">\n        I have {{friends.length}} friends. They are:\n        <input type=\"search\" ng-model=\"q\" placeholder=\"filter friends...\" />\n        <ul class=\"example-animate-container\">\n          <li class=\"animate-repeat\" ng-repeat=\"friend in friends | filter:q\">\n            [{{$index + 1}}] {{friend.name}} who is {{friend.age}} years old.\n          </li>\n        </ul>\n      </div>\n    </file>\n    <file name=\"animations.css\">\n      .example-animate-container {\n        background:white;\n        border:1px solid black;\n        list-style:none;\n        margin:0;\n        padding:0;\n      }\n\n      .example-animate-container > li {\n        padding:10px;\n        list-style:none;\n      }\n\n      .animate-repeat.ng-enter,\n      .animate-repeat.ng-leave,\n      .animate-repeat.ng-move {\n        -webkit-transition:all linear 0.5s;\n        -moz-transition:all linear 0.5s;\n        -o-transition:all linear 0.5s;\n        transition:all linear 0.5s;\n      }\n\n      .animate-repeat.ng-enter {\n        line-height:0;\n        opacity:0;\n        padding-top:0;\n        padding-bottom:0;\n      }\n      .animate-repeat.ng-enter.ng-enter-active {\n        line-height:20px;\n        opacity:1;\n        padding:10px;\n      }\n\n      .animate-repeat.ng-leave {\n        opacity:1;\n        line-height:20px;\n        padding:10px;\n      }\n      .animate-repeat.ng-leave.ng-leave-active {\n        opacity:0;\n        line-height:0;\n        padding-top:0;\n        padding-bottom:0;\n      }\n\n      .animate-repeat.ng-move { }\n      .animate-repeat.ng-move.ng-move-active { }\n    </file>\n    <file name=\"scenario.js\">\n       it('should render initial data set', function() {\n         var r = using('.doc-example-live').repeater('ul li');\n         expect(r.count()).toBe(10);\n         expect(r.row(0)).toEqual([\"1\",\"John\",\"25\"]);\n         expect(r.row(1)).toEqual([\"2\",\"Jessie\",\"30\"]);\n         expect(r.row(9)).toEqual([\"10\",\"Samantha\",\"60\"]);\n         expect(binding('friends.length')).toBe(\"10\");\n       });\n\n       it('should update repeater when filter predicate changes', function() {\n         var r = using('.doc-example-live').repeater('ul li');\n         expect(r.count()).toBe(10);\n\n         input('q').enter('ma');\n\n         expect(r.count()).toBe(2);\n         expect(r.row(0)).toEqual([\"1\",\"Mary\",\"28\"]);\n         expect(r.row(1)).toEqual([\"2\",\"Samantha\",\"60\"]);\n       });\n      </file>\n    </example>\n */\nvar ngRepeatDirective = ['$parse', '$animate', function($parse, $animate) {\n  var NG_REMOVED = '$$NG_REMOVED';\n  var ngRepeatMinErr = minErr('ngRepeat');\n  return {\n    transclude: 'element',\n    priority: 1000,\n    terminal: true,\n    compile: function(element, attr, linker) {\n      return function($scope, $element, $attr){\n        var expression = $attr.ngRepeat;\n        var match = expression.match(/^\\s*(.+)\\s+in\\s+(.*?)\\s*(\\s+track\\s+by\\s+(.+)\\s*)?$/),\n          trackByExp, trackByExpGetter, trackByIdFn, trackByIdArrayFn, trackByIdObjFn, lhs, rhs, valueIdentifier, keyIdentifier,\n          hashFnLocals = {$id: hashKey};\n\n        if (!match) {\n          throw ngRepeatMinErr('iexp', \"Expected expression in form of '_item_ in _collection_[ track by _id_]' but got '{0}'.\",\n            expression);\n        }\n\n        lhs = match[1];\n        rhs = match[2];\n        trackByExp = match[4];\n\n        if (trackByExp) {\n          trackByExpGetter = $parse(trackByExp);\n          trackByIdFn = function(key, value, index) {\n            // assign key, value, and $index to the locals so that they can be used in hash functions\n            if (keyIdentifier) hashFnLocals[keyIdentifier] = key;\n            hashFnLocals[valueIdentifier] = value;\n            hashFnLocals.$index = index;\n            return trackByExpGetter($scope, hashFnLocals);\n          };\n        } else {\n          trackByIdArrayFn = function(key, value) {\n            return hashKey(value);\n          }\n          trackByIdObjFn = function(key) {\n            return key;\n          }\n        }\n\n        match = lhs.match(/^(?:([\\$\\w]+)|\\(([\\$\\w]+)\\s*,\\s*([\\$\\w]+)\\))$/);\n        if (!match) {\n          throw ngRepeatMinErr('iidexp', \"'_item_' in '_item_ in _collection_' should be an identifier or '(_key_, _value_)' expression, but got '{0}'.\",\n                                                                    lhs);\n        }\n        valueIdentifier = match[3] || match[1];\n        keyIdentifier = match[2];\n\n        // Store a list of elements from previous run. This is a hash where key is the item from the\n        // iterator, and the value is objects with following properties.\n        //   - scope: bound scope\n        //   - element: previous element.\n        //   - index: position\n        var lastBlockMap = {};\n\n        //watch props\n        $scope.$watchCollection(rhs, function ngRepeatAction(collection){\n          var index, length,\n              previousNode = $element[0],     // current position of the node\n              nextNode,\n              // Same as lastBlockMap but it has the current state. It will become the\n              // lastBlockMap on the next iteration.\n              nextBlockMap = {},\n              arrayLength,\n              childScope,\n              key, value, // key/value of iteration\n              trackById,\n              collectionKeys,\n              block,       // last object information {scope, element, id}\n              nextBlockOrder = [];\n\n\n          if (isArrayLike(collection)) {\n            collectionKeys = collection;\n            trackByIdFn = trackByIdFn || trackByIdArrayFn;\n          } else {\n            trackByIdFn = trackByIdFn || trackByIdObjFn;\n            // if object, extract keys, sort them and use to determine order of iteration over obj props\n            collectionKeys = [];\n            for (key in collection) {\n              if (collection.hasOwnProperty(key) && key.charAt(0) != '$') {\n                collectionKeys.push(key);\n              }\n            }\n            collectionKeys.sort();\n          }\n\n          arrayLength = collectionKeys.length;\n\n          // locate existing items\n          length = nextBlockOrder.length = collectionKeys.length;\n          for(index = 0; index < length; index++) {\n           key = (collection === collectionKeys) ? index : collectionKeys[index];\n           value = collection[key];\n           trackById = trackByIdFn(key, value, index);\n           if(lastBlockMap.hasOwnProperty(trackById)) {\n             block = lastBlockMap[trackById]\n             delete lastBlockMap[trackById];\n             nextBlockMap[trackById] = block;\n             nextBlockOrder[index] = block;\n           } else if (nextBlockMap.hasOwnProperty(trackById)) {\n             // restore lastBlockMap\n             forEach(nextBlockOrder, function(block) {\n               if (block && block.startNode) lastBlockMap[block.id] = block;\n             });\n             // This is a duplicate and we need to throw an error\n             throw ngRepeatMinErr('dupes', \"Duplicates in a repeater are not allowed. Use 'track by' expression to specify unique keys. Repeater: {0}, Duplicate key: {1}\",\n                                                                                                                                                    expression,       trackById);\n           } else {\n             // new never before seen block\n             nextBlockOrder[index] = { id: trackById };\n             nextBlockMap[trackById] = false;\n           }\n         }\n\n          // remove existing items\n          for (key in lastBlockMap) {\n            if (lastBlockMap.hasOwnProperty(key)) {\n              block = lastBlockMap[key];\n              $animate.leave(block.elements);\n              forEach(block.elements, function(element) { element[NG_REMOVED] = true});\n              block.scope.$destroy();\n            }\n          }\n\n          // we are not using forEach for perf reasons (trying to avoid #call)\n          for (index = 0, length = collectionKeys.length; index < length; index++) {\n            key = (collection === collectionKeys) ? index : collectionKeys[index];\n            value = collection[key];\n            block = nextBlockOrder[index];\n\n            if (block.startNode) {\n              // if we have already seen this object, then we need to reuse the\n              // associated scope/element\n              childScope = block.scope;\n\n              nextNode = previousNode;\n              do {\n                nextNode = nextNode.nextSibling;\n              } while(nextNode && nextNode[NG_REMOVED]);\n\n              if (block.startNode == nextNode) {\n                // do nothing\n              } else {\n                // existing item which got moved\n                $animate.move(block.elements, null, jqLite(previousNode));\n              }\n              previousNode = block.endNode;\n            } else {\n              // new item which we don't know about\n              childScope = $scope.$new();\n            }\n\n            childScope[valueIdentifier] = value;\n            if (keyIdentifier) childScope[keyIdentifier] = key;\n            childScope.$index = index;\n            childScope.$first = (index === 0);\n            childScope.$last = (index === (arrayLength - 1));\n            childScope.$middle = !(childScope.$first || childScope.$last);\n            childScope.$odd = !(childScope.$even = index%2==0);\n\n            if (!block.startNode) {\n              linker(childScope, function(clone) {\n                $animate.enter(clone, null, jqLite(previousNode));\n                previousNode = clone;\n                block.scope = childScope;\n                block.startNode = clone[0];\n                block.elements = clone;\n                block.endNode = clone[clone.length - 1];\n                nextBlockMap[block.id] = block;\n              });\n            }\n          }\n          lastBlockMap = nextBlockMap;\n        });\n      };\n    }\n  };\n}];\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngShow\n *\n * @description\n * The `ngShow` directive shows and hides the given HTML element conditionally based on the expression\n * provided to the ngShow attribute. The show and hide mechanism is a achieved by removing and adding\n * the `ng-hide` CSS class onto the element. The `.ng-hide` CSS class is a predefined CSS class present\n * in AngularJS which sets the display style to none (using an !important flag).\n *\n * <pre>\n * <!-- when $scope.myValue is truthy (element is visible) -->\n * <div ng-show=\"myValue\"></div>\n *\n * <!-- when $scope.myValue is falsy (element is hidden) -->\n * <div ng-show=\"myValue\" class=\"ng-hide\"></div>\n * </pre>\n *\n * When the ngShow expression evaluates to false then the ng-hide CSS class is added to the class attribute\n * on the element causing it to become hidden. When true, the ng-hide CSS class is removed\n * from the element causing the element not to appear hidden.\n *\n * ## Why is !important used?\n *\n * You may be wondering why !important is used for the .ng-hide CSS class. This is because the `.ng-hide` selector\n * can be easily overridden by heavier selectors. For example, something as simple\n * as changing the display style on a HTML list item would make hidden elements appear visible.\n * This also becomes a bigger issue when dealing with CSS frameworks.\n *\n * By using !important, the show and hide behavior will work as expected despite any clash between CSS selector\n * specificity (when !important isn't used with any conflicting styles). If a developer chooses to override the\n * styling to change how to hide an element then it is just a matter of using !important in their own CSS code.\n *\n * ### Overriding .ng-hide\n *\n * If you wish to change the hide behavior with ngShow/ngHide then this can be achieved by\n * restating the styles for the .ng-hide class in CSS:\n * <pre>\n * .ng-hide {\n *   //!annotate CSS Specificity|Not to worry, this will override the AngularJS default...\n *   display:block!important;\n *\n *   //this is just another form of hiding an element\n *   position:absolute;\n *   top:-9999px;\n *   left:-9999px;\n * }\n * </pre>\n *\n * Just remember to include the important flag so the CSS override will function.\n *\n * ## A note about animations with ngShow\n *\n * Animations in ngShow/ngHide work with the show and hide events that are triggered when the directive expression\n * is true and false. This system works similar to the animation system present with ngClass, however, the\n * only difference is that you must also include the !important flag to override the display property so\n * that you can perform an animation when the element is hidden during the time of the animation.\n *\n * <pre>\n * //\n * //a working example can be found at the bottom of this page\n * //\n * .my-element.ng-hide-add, .my-element.ng-hide-remove {\n *   transition:0.5s linear all;\n *   display:block!important;\n * }\n *\n * .my-element.ng-hide-add { ... }\n * .my-element.ng-hide-add.ng-hide-add-active { ... }\n * .my-element.ng-hide-remove { ... }\n * .my-element.ng-hide-remove.ng-hide-remove-active { ... }\n * </pre>\n *\n * @animations\n * addClass: .ng-hide - happens after the ngShow expression evaluates to a truthy value and the just before contents are set to visible\n * removeClass: .ng-hide - happens after the ngShow expression evaluates to a non truthy value and just before the contents are set to hidden\n *\n * @element ANY\n * @param {expression} ngShow If the {@link guide/expression expression} is truthy\n *     then the element is shown or hidden respectively.\n *\n * @example\n  <example animations=\"true\">\n    <file name=\"index.html\">\n      Click me: <input type=\"checkbox\" ng-model=\"checked\"><br/>\n      <div>\n        Show:\n        <div class=\"check-element animate-show\" ng-show=\"checked\">\n          <span class=\"icon-thumbs-up\"></span> I show up when your checkbox is checked.\n        </div>\n      </div>\n      <div>\n        Hide:\n        <div class=\"check-element animate-show\" ng-hide=\"checked\">\n          <span class=\"icon-thumbs-down\"></span> I hide when your checkbox is checked.\n        </div>\n      </div>\n    </file>\n    <file name=\"animations.css\">\n      .animate-show.ng-hide-add, \n      .animate-show.ng-hide-remove {\n        -webkit-transition:all linear 0.5s;\n        -moz-transition:all linear 0.5s;\n        -o-transition:all linear 0.5s;\n        transition:all linear 0.5s;\n        display:block!important;\n      }\n\n      .animate-show.ng-hide-add.ng-hide-add-active,\n      .animate-show.ng-hide-remove {\n        line-height:0;\n        opacity:0;\n        padding:0 10px;\n      }\n\n      .animate-show.ng-hide-add,\n      .animate-show.ng-hide-remove.ng-hide-remove-active {\n        line-height:20px;\n        opacity:1;\n        padding:10px;\n        border:1px solid black;\n        background:white;\n      }\n\n      .check-element {\n        padding:10px;\n        border:1px solid black;\n        background:white;\n      }\n    </file>\n    <file name=\"scenario.js\">\n       it('should check ng-show / ng-hide', function() {\n         expect(element('.doc-example-live span:first:hidden').count()).toEqual(1);\n         expect(element('.doc-example-live span:last:visible').count()).toEqual(1);\n\n         input('checked').check();\n\n         expect(element('.doc-example-live span:first:visible').count()).toEqual(1);\n         expect(element('.doc-example-live span:last:hidden').count()).toEqual(1);\n       });\n    </file>\n  </example>\n */\nvar ngShowDirective = ['$animate', function($animate) {\n  return function(scope, element, attr) {\n    scope.$watch(attr.ngShow, function ngShowWatchAction(value){\n      $animate[toBoolean(value) ? 'removeClass' : 'addClass'](element, 'ng-hide');\n    });\n  };\n}];\n\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngHide\n *\n * @description\n * The `ngHide` directive shows and hides the given HTML element conditionally based on the expression\n * provided to the ngHide attribute. The show and hide mechanism is a achieved by removing and adding\n * the `ng-hide` CSS class onto the element. The `.ng-hide` CSS class is a predefined CSS class present\n * in AngularJS which sets the display style to none (using an !important flag).\n *\n * <pre>\n * <!-- when $scope.myValue is truthy (element is hidden) -->\n * <div ng-hide=\"myValue\"></div>\n *\n * <!-- when $scope.myValue is falsy (element is visible) -->\n * <div ng-hide=\"myValue\" class=\"ng-hide\"></div>\n * </pre>\n *\n * When the ngHide expression evaluates to true then the .ng-hide CSS class is added to the class attribute\n * on the element causing it to become hidden. When false, the ng-hide CSS class is removed\n * from the element causing the element not to appear hidden.\n *\n * ## Why is !important used?\n *\n * You may be wondering why !important is used for the .ng-hide CSS class. This is because the `.ng-hide` selector\n * can be easily overridden by heavier selectors. For example, something as simple\n * as changing the display style on a HTML list item would make hidden elements appear visible.\n * This also becomes a bigger issue when dealing with CSS frameworks.\n *\n * By using !important, the show and hide behavior will work as expected despite any clash between CSS selector\n * specificity (when !important isn't used with any conflicting styles). If a developer chooses to override the\n * styling to change how to hide an element then it is just a matter of using !important in their own CSS code.\n *\n * ### Overriding .ng-hide\n *\n * If you wish to change the hide behavior with ngShow/ngHide then this can be achieved by\n * restating the styles for the .ng-hide class in CSS:\n * <pre>\n * .ng-hide {\n *   //!annotate CSS Specificity|Not to worry, this will override the AngularJS default...\n *   display:block!important;\n *\n *   //this is just another form of hiding an element\n *   position:absolute;\n *   top:-9999px;\n *   left:-9999px;\n * }\n * </pre>\n *\n * Just remember to include the important flag so the CSS override will function.\n *\n * ## A note about animations with ngHide\n *\n * Animations in ngShow/ngHide work with the show and hide events that are triggered when the directive expression\n * is true and false. This system works similar to the animation system present with ngClass, however, the\n * only difference is that you must also include the !important flag to override the display property so\n * that you can perform an animation when the element is hidden during the time of the animation.\n *\n * <pre>\n * //\n * //a working example can be found at the bottom of this page\n * //\n * .my-element.ng-hide-add, .my-element.ng-hide-remove {\n *   transition:0.5s linear all;\n *   display:block!important;\n * }\n *\n * .my-element.ng-hide-add { ... }\n * .my-element.ng-hide-add.ng-hide-add-active { ... }\n * .my-element.ng-hide-remove { ... }\n * .my-element.ng-hide-remove.ng-hide-remove-active { ... }\n * </pre>\n *\n * @animations\n * removeClass: .ng-hide - happens after the ngHide expression evaluates to a truthy value and just before the contents are set to hidden\n * addClass: .ng-hide - happens after the ngHide expression evaluates to a non truthy value and just before the contents are set to visible\n *\n * @element ANY\n * @param {expression} ngHide If the {@link guide/expression expression} is truthy then\n *     the element is shown or hidden respectively.\n *\n * @example\n  <example animations=\"true\">\n    <file name=\"index.html\">\n      Click me: <input type=\"checkbox\" ng-model=\"checked\"><br/>\n      <div>\n        Show:\n        <div class=\"check-element animate-hide\" ng-show=\"checked\">\n          <span class=\"icon-thumbs-up\"></span> I show up when your checkbox is checked.\n        </div>\n      </div>\n      <div>\n        Hide:\n        <div class=\"check-element animate-hide\" ng-hide=\"checked\">\n          <span class=\"icon-thumbs-down\"></span> I hide when your checkbox is checked.\n        </div>\n      </div>\n    </file>\n    <file name=\"animations.css\">\n      .animate-hide.ng-hide-add, \n      .animate-hide.ng-hide-remove {\n        -webkit-transition:all linear 0.5s;\n        -moz-transition:all linear 0.5s;\n        -o-transition:all linear 0.5s;\n        transition:all linear 0.5s;\n        display:block!important;\n      }\n\n      .animate-hide.ng-hide-add.ng-hide-add-active,\n      .animate-hide.ng-hide-remove {\n        line-height:0;\n        opacity:0;\n        padding:0 10px;\n      }\n\n      .animate-hide.ng-hide-add,\n      .animate-hide.ng-hide-remove.ng-hide-remove-active {\n        line-height:20px;\n        opacity:1;\n        padding:10px;\n        border:1px solid black;\n        background:white;\n      }\n\n      .check-element {\n        padding:10px;\n        border:1px solid black;\n        background:white;\n      }\n    </file>\n    <file name=\"scenario.js\">\n       it('should check ng-show / ng-hide', function() {\n         expect(element('.doc-example-live .check-element:first:hidden').count()).toEqual(1);\n         expect(element('.doc-example-live .check-element:last:visible').count()).toEqual(1);\n\n         input('checked').check();\n\n         expect(element('.doc-example-live .check-element:first:visible').count()).toEqual(1);\n         expect(element('.doc-example-live .check-element:last:hidden').count()).toEqual(1);\n       });\n    </file>\n  </example>\n */\nvar ngHideDirective = ['$animate', function($animate) {\n  return function(scope, element, attr) {\n    scope.$watch(attr.ngHide, function ngHideWatchAction(value){\n      $animate[toBoolean(value) ? 'addClass' : 'removeClass'](element, 'ng-hide');\n    });\n  };\n}];\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngStyle\n *\n * @description\n * The `ngStyle` directive allows you to set CSS style on an HTML element conditionally.\n *\n * @element ANY\n * @param {expression} ngStyle {@link guide/expression Expression} which evals to an\n *      object whose keys are CSS style names and values are corresponding values for those CSS\n *      keys.\n *\n * @example\n   <example>\n     <file name=\"index.html\">\n        <input type=\"button\" value=\"set\" ng-click=\"myStyle={color:'red'}\">\n        <input type=\"button\" value=\"clear\" ng-click=\"myStyle={}\">\n        <br/>\n        <span ng-style=\"myStyle\">Sample Text</span>\n        <pre>myStyle={{myStyle}}</pre>\n     </file>\n     <file name=\"style.css\">\n       span {\n         color: black;\n       }\n     </file>\n     <file name=\"scenario.js\">\n       it('should check ng-style', function() {\n         expect(element('.doc-example-live span').css('color')).toBe('rgb(0, 0, 0)');\n         element('.doc-example-live :button[value=set]').click();\n         expect(element('.doc-example-live span').css('color')).toBe('rgb(255, 0, 0)');\n         element('.doc-example-live :button[value=clear]').click();\n         expect(element('.doc-example-live span').css('color')).toBe('rgb(0, 0, 0)');\n       });\n     </file>\n   </example>\n */\nvar ngStyleDirective = ngDirective(function(scope, element, attr) {\n  scope.$watch(attr.ngStyle, function ngStyleWatchAction(newStyles, oldStyles) {\n    if (oldStyles && (newStyles !== oldStyles)) {\n      forEach(oldStyles, function(val, style) { element.css(style, '');});\n    }\n    if (newStyles) element.css(newStyles);\n  }, true);\n});\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngSwitch\n * @restrict EA\n *\n * @description\n * The ngSwitch directive is used to conditionally swap DOM structure on your template based on a scope expression.\n * Elements within ngSwitch but without ngSwitchWhen or ngSwitchDefault directives will be preserved at the location\n * as specified in the template.\n *\n * The directive itself works similar to ngInclude, however, instead of downloading template code (or loading it\n * from the template cache), ngSwitch simply choses one of the nested elements and makes it visible based on which element\n * matches the value obtained from the evaluated expression. In other words, you define a container element\n * (where you place the directive), place an expression on the **on=\"...\" attribute**\n * (or the **ng-switch=\"...\" attribute**), define any inner elements inside of the directive and place\n * a when attribute per element. The when attribute is used to inform ngSwitch which element to display when the on\n * expression is evaluated. If a matching expression is not found via a when attribute then an element with the default\n * attribute is displayed.\n *\n * @animations\n * enter - happens after the ngSwtich contents change and the matched child element is placed inside the container\n * leave - happens just after the ngSwitch contents change and just before the former contents are removed from the DOM\n *\n * @usage\n * <ANY ng-switch=\"expression\">\n *   <ANY ng-switch-when=\"matchValue1\">...</ANY>\n *   <ANY ng-switch-when=\"matchValue2\">...</ANY>\n *   <ANY ng-switch-default>...</ANY>\n * </ANY>\n *\n * @scope\n * @param {*} ngSwitch|on expression to match against <tt>ng-switch-when</tt>.\n * @paramDescription\n * On child elements add:\n *\n * * `ngSwitchWhen`: the case statement to match against. If match then this\n *   case will be displayed. If the same match appears multiple times, all the\n *   elements will be displayed.\n * * `ngSwitchDefault`: the default case when no other case match. If there\n *   are multiple default cases, all of them will be displayed when no other\n *   case match.\n *\n *\n * @example\n  <example animations=\"true\">\n    <file name=\"index.html\">\n      <div ng-controller=\"Ctrl\">\n        <select ng-model=\"selection\" ng-options=\"item for item in items\">\n        </select>\n        <tt>selection={{selection}}</tt>\n        <hr/>\n        <div class=\"animate-switch-container\"\n          ng-switch on=\"selection\">\n            <div ng-switch-when=\"settings\">Settings Div</div>\n            <div ng-switch-when=\"home\">Home Span</div>\n            <div ng-switch-default>default</div>\n        </div>\n      </div>\n    </file>\n    <file name=\"script.js\">\n      function Ctrl($scope) {\n        $scope.items = ['settings', 'home', 'other'];\n        $scope.selection = $scope.items[0];\n      }\n    </file>\n    <file name=\"animations.css\">\n      .animate-switch-container {\n        position:relative;\n        background:white;\n        border:1px solid black;\n        height:40px;\n        overflow:hidden;\n      }\n\n      .animate-switch-container > div {\n        padding:10px;\n      }\n\n      .animate-switch-container > .ng-enter,\n      .animate-switch-container > .ng-leave {\n        -webkit-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;\n        -moz-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;\n        -o-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;\n        transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 0.5s;\n\n        position:absolute;\n        top:0;\n        left:0;\n        right:0;\n        bottom:0;\n      }\n\n      .animate-switch-container > .ng-enter {\n        top:-50px;\n      }\n      .animate-switch-container > .ng-enter.ng-enter-active {\n        top:0;\n      }\n\n      .animate-switch-container > .ng-leave {\n        top:0;\n      }\n      .animate-switch-container > .ng-leave.ng-leave-active {\n        top:50px;\n      }\n    </file>\n    <file name=\"scenario.js\">\n      it('should start in settings', function() {\n        expect(element('.doc-example-live [ng-switch]').text()).toMatch(/Settings Div/);\n      });\n      it('should change to home', function() {\n        select('selection').option('home');\n        expect(element('.doc-example-live [ng-switch]').text()).toMatch(/Home Span/);\n      });\n      it('should select default', function() {\n        select('selection').option('other');\n        expect(element('.doc-example-live [ng-switch]').text()).toMatch(/default/);\n      });\n    </file>\n  </example>\n */\nvar ngSwitchDirective = ['$animate', function($animate) {\n  return {\n    restrict: 'EA',\n    require: 'ngSwitch',\n\n    // asks for $scope to fool the BC controller module\n    controller: ['$scope', function ngSwitchController() {\n     this.cases = {};\n    }],\n    link: function(scope, element, attr, ngSwitchController) {\n      var watchExpr = attr.ngSwitch || attr.on,\n          selectedTranscludes,\n          selectedElements,\n          selectedScopes = [];\n\n      scope.$watch(watchExpr, function ngSwitchWatchAction(value) {\n        for (var i= 0, ii=selectedScopes.length; i<ii; i++) {\n          selectedScopes[i].$destroy();\n          $animate.leave(selectedElements[i]);\n        }\n\n        selectedElements = [];\n        selectedScopes = [];\n\n        if ((selectedTranscludes = ngSwitchController.cases['!' + value] || ngSwitchController.cases['?'])) {\n          scope.$eval(attr.change);\n          forEach(selectedTranscludes, function(selectedTransclude) {\n            var selectedScope = scope.$new();\n            selectedScopes.push(selectedScope);\n            selectedTransclude.transclude(selectedScope, function(caseElement) {\n              var anchor = selectedTransclude.element;\n\n              selectedElements.push(caseElement);\n              $animate.enter(caseElement, anchor.parent(), anchor);\n            });\n          });\n        }\n      });\n    }\n  }\n}];\n\nvar ngSwitchWhenDirective = ngDirective({\n  transclude: 'element',\n  priority: 500,\n  require: '^ngSwitch',\n  compile: function(element, attrs, transclude) {\n    return function(scope, element, attr, ctrl) {\n      ctrl.cases['!' + attrs.ngSwitchWhen] = (ctrl.cases['!' + attrs.ngSwitchWhen] || []);\n      ctrl.cases['!' + attrs.ngSwitchWhen].push({ transclude: transclude, element: element });\n    };\n  }\n});\n\nvar ngSwitchDefaultDirective = ngDirective({\n  transclude: 'element',\n  priority: 500,\n  require: '^ngSwitch',\n  compile: function(element, attrs, transclude) {\n    return function(scope, element, attr, ctrl) {\n      ctrl.cases['?'] = (ctrl.cases['?'] || []);\n      ctrl.cases['?'].push({ transclude: transclude, element: element });\n    };\n  }\n});\n\n/**\n * @ngdoc directive\n * @name ng.directive:ngTransclude\n *\n * @description\n * Directive that marks the insertion point for the transcluded DOM of the nearest parent directive that uses transclusion.\n *\n * Any existing content of the element that this directive is placed on will be removed before the transcluded content is inserted.\n *\n * @element ANY\n *\n * @example\n   <doc:example module=\"transclude\">\n     <doc:source>\n       <script>\n         function Ctrl($scope) {\n           $scope.title = 'Lorem Ipsum';\n           $scope.text = 'Neque porro quisquam est qui dolorem ipsum quia dolor...';\n         }\n\n         angular.module('transclude', [])\n          .directive('pane', function(){\n             return {\n               restrict: 'E',\n               transclude: true,\n               scope: { title:'@' },\n               template: '<div style=\"border: 1px solid black;\">' +\n                           '<div style=\"background-color: gray\">{{title}}</div>' +\n                           '<div ng-transclude></div>' +\n                         '</div>'\n             };\n         });\n       </script>\n       <div ng-controller=\"Ctrl\">\n         <input ng-model=\"title\"><br>\n         <textarea ng-model=\"text\"></textarea> <br/>\n         <pane title=\"{{title}}\">{{text}}</pane>\n       </div>\n     </doc:source>\n     <doc:scenario>\n        it('should have transcluded', function() {\n          input('title').enter('TITLE');\n          input('text').enter('TEXT');\n          expect(binding('title')).toEqual('TITLE');\n          expect(binding('text')).toEqual('TEXT');\n        });\n     </doc:scenario>\n   </doc:example>\n *\n */\nvar ngTranscludeDirective = ngDirective({\n  controller: ['$transclude', function($transclude) {\n    // remember the transclusion fn but call it during linking so that we don't process transclusion before directives on\n    // the parent element even when the transclusion replaces the current element. (we can't use priority here because\n    // that applies only to compile fns and not controllers\n    this.$transclude = $transclude;\n  }],\n\n  link: function($scope, $element, $attrs, controller) {\n    controller.$transclude(function(clone) {\n      $element.html('');\n      $element.append(clone);\n    });\n  }\n});\n\n/**\n * @ngdoc directive\n * @name ng.directive:script\n *\n * @description\n * Load content of a script tag, with type `text/ng-template`, into `$templateCache`, so that the\n * template can be used by `ngInclude`, `ngView` or directive templates.\n *\n * @restrict E\n * @param {'text/ng-template'} type must be set to `'text/ng-template'`\n *\n * @example\n  <doc:example>\n    <doc:source>\n      <script type=\"text/ng-template\" id=\"/tpl.html\">\n        Content of the template.\n      </script>\n\n      <a ng-click=\"currentTpl='/tpl.html'\" id=\"tpl-link\">Load inlined template</a>\n      <div id=\"tpl-content\" ng-include src=\"currentTpl\"></div>\n    </doc:source>\n    <doc:scenario>\n      it('should load template defined inside script tag', function() {\n        element('#tpl-link').click();\n        expect(element('#tpl-content').text()).toMatch(/Content of the template/);\n      });\n    </doc:scenario>\n  </doc:example>\n */\nvar scriptDirective = ['$templateCache', function($templateCache) {\n  return {\n    restrict: 'E',\n    terminal: true,\n    compile: function(element, attr) {\n      if (attr.type == 'text/ng-template') {\n        var templateUrl = attr.id,\n            // IE is not consistent, in scripts we have to read .text but in other nodes we have to read .textContent\n            text = element[0].text;\n\n        $templateCache.put(templateUrl, text);\n      }\n    }\n  };\n}];\n\n/**\n * @ngdoc directive\n * @name ng.directive:select\n * @restrict E\n *\n * @description\n * HTML `SELECT` element with angular data-binding.\n *\n * # `ngOptions`\n *\n * Optionally `ngOptions` attribute can be used to dynamically generate a list of `<option>`\n * elements for a `<select>` element using an array or an object obtained by evaluating the\n * `ngOptions` expression.\n *\n * When an item in the `<select>` menu is selected, the value of array element or object property\n * represented by the selected option will be bound to the model identified by the `ngModel`\n * directive of the parent select element.\n *\n * Optionally, a single hard-coded `<option>` element, with the value set to an empty string, can\n * be nested into the `<select>` element. This element will then represent `null` or \"not selected\"\n * option. See example below for demonstration.\n *\n * Note: `ngOptions` provides iterator facility for `<option>` element which should be used instead\n * of {@link ng.directive:ngRepeat ngRepeat} when you want the\n * `select` model to be bound to a non-string value. This is because an option element can currently\n * be bound to string values only.\n *\n * @param {string} ngModel Assignable angular expression to data-bind to.\n * @param {string=} name Property name of the form under which the control is published.\n * @param {string=} required The control is considered valid only if value is entered.\n * @param {string=} ngRequired Adds `required` attribute and `required` validation constraint to\n *    the element when the ngRequired expression evaluates to true. Use `ngRequired` instead of\n *    `required` when you want to data-bind to the `required` attribute.\n * @param {comprehension_expression=} ngOptions in one of the following forms:\n *\n *   * for array data sources:\n *     * `label` **`for`** `value` **`in`** `array`\n *     * `select` **`as`** `label` **`for`** `value` **`in`** `array`\n *     * `label`  **`group by`** `group` **`for`** `value` **`in`** `array`\n *     * `select` **`as`** `label` **`group by`** `group` **`for`** `value` **`in`** `array` **`track by`** `trackexpr`\n *   * for object data sources:\n *     * `label` **`for (`**`key` **`,`** `value`**`) in`** `object`\n *     * `select` **`as`** `label` **`for (`**`key` **`,`** `value`**`) in`** `object`\n *     * `label` **`group by`** `group` **`for (`**`key`**`,`** `value`**`) in`** `object`\n *     * `select` **`as`** `label` **`group by`** `group`\n *         **`for` `(`**`key`**`,`** `value`**`) in`** `object`\n *\n * Where:\n *\n *   * `array` / `object`: an expression which evaluates to an array / object to iterate over.\n *   * `value`: local variable which will refer to each item in the `array` or each property value\n *      of `object` during iteration.\n *   * `key`: local variable which will refer to a property name in `object` during iteration.\n *   * `label`: The result of this expression will be the label for `<option>` element. The\n *     `expression` will most likely refer to the `value` variable (e.g. `value.propertyName`).\n *   * `select`: The result of this expression will be bound to the model of the parent `<select>`\n *      element. If not specified, `select` expression will default to `value`.\n *   * `group`: The result of this expression will be used to group options using the `<optgroup>`\n *      DOM element.\n *   * `trackexpr`: Used when working with an array of objects. The result of this expression will be\n *      used to identify the objects in the array. The `trackexpr` will most likely refer to the\n *     `value` variable (e.g. `value.propertyName`).\n *\n * @example\n    <doc:example>\n      <doc:source>\n        <script>\n        function MyCntrl($scope) {\n          $scope.colors = [\n            {name:'black', shade:'dark'},\n            {name:'white', shade:'light'},\n            {name:'red', shade:'dark'},\n            {name:'blue', shade:'dark'},\n            {name:'yellow', shade:'light'}\n          ];\n          $scope.color = $scope.colors[2]; // red\n        }\n        </script>\n        <div ng-controller=\"MyCntrl\">\n          <ul>\n            <li ng-repeat=\"color in colors\">\n              Name: <input ng-model=\"color.name\">\n              [<a href ng-click=\"colors.splice($index, 1)\">X</a>]\n            </li>\n            <li>\n              [<a href ng-click=\"colors.push({})\">add</a>]\n            </li>\n          </ul>\n          <hr/>\n          Color (null not allowed):\n          <select ng-model=\"color\" ng-options=\"c.name for c in colors\"></select><br>\n\n          Color (null allowed):\n          <span  class=\"nullable\">\n            <select ng-model=\"color\" ng-options=\"c.name for c in colors\">\n              <option value=\"\">-- chose color --</option>\n            </select>\n          </span><br/>\n\n          Color grouped by shade:\n          <select ng-model=\"color\" ng-options=\"c.name group by c.shade for c in colors\">\n          </select><br/>\n\n\n          Select <a href ng-click=\"color={name:'not in list'}\">bogus</a>.<br>\n          <hr/>\n          Currently selected: {{ {selected_color:color}  }}\n          <div style=\"border:solid 1px black; height:20px\"\n               ng-style=\"{'background-color':color.name}\">\n          </div>\n        </div>\n      </doc:source>\n      <doc:scenario>\n         it('should check ng-options', function() {\n           expect(binding('{selected_color:color}')).toMatch('red');\n           select('color').option('0');\n           expect(binding('{selected_color:color}')).toMatch('black');\n           using('.nullable').select('color').option('');\n           expect(binding('{selected_color:color}')).toMatch('null');\n         });\n      </doc:scenario>\n    </doc:example>\n */\n\nvar ngOptionsDirective = valueFn({ terminal: true });\nvar selectDirective = ['$compile', '$parse', function($compile,   $parse) {\n                         //0000111110000000000022220000000000000000000000333300000000000000444444444444444440000000005555555555555555500000006666666666666666600000000000000007777000000000000000000088888\n  var NG_OPTIONS_REGEXP = /^\\s*(.*?)(?:\\s+as\\s+(.*?))?(?:\\s+group\\s+by\\s+(.*))?\\s+for\\s+(?:([\\$\\w][\\$\\w\\d]*)|(?:\\(\\s*([\\$\\w][\\$\\w\\d]*)\\s*,\\s*([\\$\\w][\\$\\w\\d]*)\\s*\\)))\\s+in\\s+(.*?)(?:\\s+track\\s+by\\s+(.*?))?$/,\n      nullModelCtrl = {$setViewValue: noop};\n\n  return {\n    restrict: 'E',\n    require: ['select', '?ngModel'],\n    controller: ['$element', '$scope', '$attrs', function($element, $scope, $attrs) {\n      var self = this,\n          optionsMap = {},\n          ngModelCtrl = nullModelCtrl,\n          nullOption,\n          unknownOption;\n\n\n      self.databound = $attrs.ngModel;\n\n\n      self.init = function(ngModelCtrl_, nullOption_, unknownOption_) {\n        ngModelCtrl = ngModelCtrl_;\n        nullOption = nullOption_;\n        unknownOption = unknownOption_;\n      }\n\n\n      self.addOption = function(value) {\n        optionsMap[value] = true;\n\n        if (ngModelCtrl.$viewValue == value) {\n          $element.val(value);\n          if (unknownOption.parent()) unknownOption.remove();\n        }\n      };\n\n\n      self.removeOption = function(value) {\n        if (this.hasOption(value)) {\n          delete optionsMap[value];\n          if (ngModelCtrl.$viewValue == value) {\n            this.renderUnknownOption(value);\n          }\n        }\n      };\n\n\n      self.renderUnknownOption = function(val) {\n        var unknownVal = '? ' + hashKey(val) + ' ?';\n        unknownOption.val(unknownVal);\n        $element.prepend(unknownOption);\n        $element.val(unknownVal);\n        unknownOption.prop('selected', true); // needed for IE\n      }\n\n\n      self.hasOption = function(value) {\n        return optionsMap.hasOwnProperty(value);\n      }\n\n      $scope.$on('$destroy', function() {\n        // disable unknown option so that we don't do work when the whole select is being destroyed\n        self.renderUnknownOption = noop;\n      });\n    }],\n\n    link: function(scope, element, attr, ctrls) {\n      // if ngModel is not defined, we don't need to do anything\n      if (!ctrls[1]) return;\n\n      var selectCtrl = ctrls[0],\n          ngModelCtrl = ctrls[1],\n          multiple = attr.multiple,\n          optionsExp = attr.ngOptions,\n          nullOption = false, // if false, user will not be able to select it (used by ngOptions)\n          emptyOption,\n          // we can't just jqLite('<option>') since jqLite is not smart enough\n          // to create it in <select> and IE barfs otherwise.\n          optionTemplate = jqLite(document.createElement('option')),\n          optGroupTemplate =jqLite(document.createElement('optgroup')),\n          unknownOption = optionTemplate.clone();\n\n      // find \"null\" option\n      for(var i = 0, children = element.children(), ii = children.length; i < ii; i++) {\n        if (children[i].value == '') {\n          emptyOption = nullOption = children.eq(i);\n          break;\n        }\n      }\n\n      selectCtrl.init(ngModelCtrl, nullOption, unknownOption);\n\n      // required validator\n      if (multiple && (attr.required || attr.ngRequired)) {\n        var requiredValidator = function(value) {\n          ngModelCtrl.$setValidity('required', !attr.required || (value && value.length));\n          return value;\n        };\n\n        ngModelCtrl.$parsers.push(requiredValidator);\n        ngModelCtrl.$formatters.unshift(requiredValidator);\n\n        attr.$observe('required', function() {\n          requiredValidator(ngModelCtrl.$viewValue);\n        });\n      }\n\n      if (optionsExp) Options(scope, element, ngModelCtrl);\n      else if (multiple) Multiple(scope, element, ngModelCtrl);\n      else Single(scope, element, ngModelCtrl, selectCtrl);\n\n\n      ////////////////////////////\n\n\n\n      function Single(scope, selectElement, ngModelCtrl, selectCtrl) {\n        ngModelCtrl.$render = function() {\n          var viewValue = ngModelCtrl.$viewValue;\n\n          if (selectCtrl.hasOption(viewValue)) {\n            if (unknownOption.parent()) unknownOption.remove();\n            selectElement.val(viewValue);\n            if (viewValue === '') emptyOption.prop('selected', true); // to make IE9 happy\n          } else {\n            if (isUndefined(viewValue) && emptyOption) {\n              selectElement.val('');\n            } else {\n              selectCtrl.renderUnknownOption(viewValue);\n            }\n          }\n        };\n\n        selectElement.on('change', function() {\n          scope.$apply(function() {\n            if (unknownOption.parent()) unknownOption.remove();\n            ngModelCtrl.$setViewValue(selectElement.val());\n          });\n        });\n      }\n\n      function Multiple(scope, selectElement, ctrl) {\n        var lastView;\n        ctrl.$render = function() {\n          var items = new HashMap(ctrl.$viewValue);\n          forEach(selectElement.find('option'), function(option) {\n            option.selected = isDefined(items.get(option.value));\n          });\n        };\n\n        // we have to do it on each watch since ngModel watches reference, but\n        // we need to work of an array, so we need to see if anything was inserted/removed\n        scope.$watch(function selectMultipleWatch() {\n          if (!equals(lastView, ctrl.$viewValue)) {\n            lastView = copy(ctrl.$viewValue);\n            ctrl.$render();\n          }\n        });\n\n        selectElement.on('change', function() {\n          scope.$apply(function() {\n            var array = [];\n            forEach(selectElement.find('option'), function(option) {\n              if (option.selected) {\n                array.push(option.value);\n              }\n            });\n            ctrl.$setViewValue(array);\n          });\n        });\n      }\n\n      function Options(scope, selectElement, ctrl) {\n        var match;\n\n        if (! (match = optionsExp.match(NG_OPTIONS_REGEXP))) {\n          throw minErr('ngOptions')('iexp',\n            \"Expected expression in form of '_select_ (as _label_)? for (_key_,)?_value_ in _collection_' but got '{0}'. Element: {1}\",\n            optionsExp, startingTag(selectElement));\n        }\n\n        var displayFn = $parse(match[2] || match[1]),\n            valueName = match[4] || match[6],\n            keyName = match[5],\n            groupByFn = $parse(match[3] || ''),\n            valueFn = $parse(match[2] ? match[1] : valueName),\n            valuesFn = $parse(match[7]),\n            track = match[8],\n            trackFn = track ? $parse(match[8]) : null,\n            // This is an array of array of existing option groups in DOM. We try to reuse these if possible\n            // optionGroupsCache[0] is the options with no option group\n            // optionGroupsCache[?][0] is the parent: either the SELECT or OPTGROUP element\n            optionGroupsCache = [[{element: selectElement, label:''}]];\n\n        if (nullOption) {\n          // compile the element since there might be bindings in it\n          $compile(nullOption)(scope);\n\n          // remove the class, which is added automatically because we recompile the element and it\n          // becomes the compilation root\n          nullOption.removeClass('ng-scope');\n\n          // we need to remove it before calling selectElement.html('') because otherwise IE will\n          // remove the label from the element. wtf?\n          nullOption.remove();\n        }\n\n        // clear contents, we'll add what's needed based on the model\n        selectElement.html('');\n\n        selectElement.on('change', function() {\n          scope.$apply(function() {\n            var optionGroup,\n                collection = valuesFn(scope) || [],\n                locals = {},\n                key, value, optionElement, index, groupIndex, length, groupLength;\n\n            if (multiple) {\n              value = [];\n              for (groupIndex = 0, groupLength = optionGroupsCache.length;\n                   groupIndex < groupLength;\n                   groupIndex++) {\n                // list of options for that group. (first item has the parent)\n                optionGroup = optionGroupsCache[groupIndex];\n\n                for(index = 1, length = optionGroup.length; index < length; index++) {\n                  if ((optionElement = optionGroup[index].element)[0].selected) {\n                    key = optionElement.val();\n                    if (keyName) locals[keyName] = key;\n                    if (trackFn) {\n                      for (var trackIndex = 0; trackIndex < collection.length; trackIndex++) {\n                        locals[valueName] = collection[trackIndex];\n                        if (trackFn(scope, locals) == key) break;\n                      }\n                    } else {\n                      locals[valueName] = collection[key];\n                    }\n                    value.push(valueFn(scope, locals));\n                  }\n                }\n              }\n            } else {\n              key = selectElement.val();\n              if (key == '?') {\n                value = undefined;\n              } else if (key == ''){\n                value = null;\n              } else {\n                if (trackFn) {\n                  for (var trackIndex = 0; trackIndex < collection.length; trackIndex++) {\n                    locals[valueName] = collection[trackIndex];\n                    if (trackFn(scope, locals) == key) {\n                      value = valueFn(scope, locals);\n                      break;\n                    }\n                  }\n                } else {\n                  locals[valueName] = collection[key];\n                  if (keyName) locals[keyName] = key;\n                  value = valueFn(scope, locals);\n                }\n              }\n            }\n            ctrl.$setViewValue(value);\n          });\n        });\n\n        ctrl.$render = render;\n\n        // TODO(vojta): can't we optimize this ?\n        scope.$watch(render);\n\n        function render() {\n          var optionGroups = {'':[]}, // Temporary location for the option groups before we render them\n              optionGroupNames = [''],\n              optionGroupName,\n              optionGroup,\n              option,\n              existingParent, existingOptions, existingOption,\n              modelValue = ctrl.$modelValue,\n              values = valuesFn(scope) || [],\n              keys = keyName ? sortedKeys(values) : values,\n              groupLength, length,\n              groupIndex, index,\n              locals = {},\n              selected,\n              selectedSet = false, // nothing is selected yet\n              lastElement,\n              element,\n              label;\n\n          if (multiple) {\n            if (trackFn && isArray(modelValue)) {\n              selectedSet = new HashMap([]);\n              for (var trackIndex = 0; trackIndex < modelValue.length; trackIndex++) {\n                locals[valueName] = modelValue[trackIndex];\n                selectedSet.put(trackFn(scope, locals), modelValue[trackIndex]);\n              }\n            } else {\n              selectedSet = new HashMap(modelValue);\n            }\n          }\n\n          // We now build up the list of options we need (we merge later)\n          for (index = 0; length = keys.length, index < length; index++) {\n               locals[valueName] = values[keyName ? locals[keyName]=keys[index]:index];\n               optionGroupName = groupByFn(scope, locals) || '';\n            if (!(optionGroup = optionGroups[optionGroupName])) {\n              optionGroup = optionGroups[optionGroupName] = [];\n              optionGroupNames.push(optionGroupName);\n            }\n            if (multiple) {\n              selected = selectedSet.remove(trackFn ? trackFn(scope, locals) : valueFn(scope, locals)) != undefined;\n            } else {\n              if (trackFn) {\n                var modelCast = {};\n                modelCast[valueName] = modelValue;\n                selected = trackFn(scope, modelCast) === trackFn(scope, locals);\n              } else {\n                selected = modelValue === valueFn(scope, locals);\n              }\n              selectedSet = selectedSet || selected; // see if at least one item is selected\n            }\n            label = displayFn(scope, locals); // what will be seen by the user\n            label = label === undefined ? '' : label; // doing displayFn(scope, locals) || '' overwrites zero values\n            optionGroup.push({\n              id: trackFn ? trackFn(scope, locals) : (keyName ? keys[index] : index),   // either the index into array or key from object\n              label: label,\n              selected: selected                   // determine if we should be selected\n            });\n          }\n          if (!multiple) {\n            if (nullOption || modelValue === null) {\n              // insert null option if we have a placeholder, or the model is null\n              optionGroups[''].unshift({id:'', label:'', selected:!selectedSet});\n            } else if (!selectedSet) {\n              // option could not be found, we have to insert the undefined item\n              optionGroups[''].unshift({id:'?', label:'', selected:true});\n            }\n          }\n\n          // Now we need to update the list of DOM nodes to match the optionGroups we computed above\n          for (groupIndex = 0, groupLength = optionGroupNames.length;\n               groupIndex < groupLength;\n               groupIndex++) {\n            // current option group name or '' if no group\n            optionGroupName = optionGroupNames[groupIndex];\n\n            // list of options for that group. (first item has the parent)\n            optionGroup = optionGroups[optionGroupName];\n\n            if (optionGroupsCache.length <= groupIndex) {\n              // we need to grow the optionGroups\n              existingParent = {\n                element: optGroupTemplate.clone().attr('label', optionGroupName),\n                label: optionGroup.label\n              };\n              existingOptions = [existingParent];\n              optionGroupsCache.push(existingOptions);\n              selectElement.append(existingParent.element);\n            } else {\n              existingOptions = optionGroupsCache[groupIndex];\n              existingParent = existingOptions[0];  // either SELECT (no group) or OPTGROUP element\n\n              // update the OPTGROUP label if not the same.\n              if (existingParent.label != optionGroupName) {\n                existingParent.element.attr('label', existingParent.label = optionGroupName);\n              }\n            }\n\n            lastElement = null;  // start at the beginning\n            for(index = 0, length = optionGroup.length; index < length; index++) {\n              option = optionGroup[index];\n              if ((existingOption = existingOptions[index+1])) {\n                // reuse elements\n                lastElement = existingOption.element;\n                if (existingOption.label !== option.label) {\n                  lastElement.text(existingOption.label = option.label);\n                }\n                if (existingOption.id !== option.id) {\n                  lastElement.val(existingOption.id = option.id);\n                }\n                // lastElement.prop('selected') provided by jQuery has side-effects\n                if (lastElement[0].selected !== option.selected) {\n                  lastElement.prop('selected', (existingOption.selected = option.selected));\n                }\n              } else {\n                // grow elements\n\n                // if it's a null option\n                if (option.id === '' && nullOption) {\n                  // put back the pre-compiled element\n                  element = nullOption;\n                } else {\n                  // jQuery(v1.4.2) Bug: We should be able to chain the method calls, but\n                  // in this version of jQuery on some browser the .text() returns a string\n                  // rather then the element.\n                  (element = optionTemplate.clone())\n                      .val(option.id)\n                      .attr('selected', option.selected)\n                      .text(option.label);\n                }\n\n                existingOptions.push(existingOption = {\n                    element: element,\n                    label: option.label,\n                    id: option.id,\n                    selected: option.selected\n                });\n                if (lastElement) {\n                  lastElement.after(element);\n                } else {\n                  existingParent.element.append(element);\n                }\n                lastElement = element;\n              }\n            }\n            // remove any excessive OPTIONs in a group\n            index++; // increment since the existingOptions[0] is parent element not OPTION\n            while(existingOptions.length > index) {\n              existingOptions.pop().element.remove();\n            }\n          }\n          // remove any excessive OPTGROUPs from select\n          while(optionGroupsCache.length > groupIndex) {\n            optionGroupsCache.pop()[0].element.remove();\n          }\n        }\n      }\n    }\n  }\n}];\n\nvar optionDirective = ['$interpolate', function($interpolate) {\n  var nullSelectCtrl = {\n    addOption: noop,\n    removeOption: noop\n  };\n\n  return {\n    restrict: 'E',\n    priority: 100,\n    compile: function(element, attr) {\n      if (isUndefined(attr.value)) {\n        var interpolateFn = $interpolate(element.text(), true);\n        if (!interpolateFn) {\n          attr.$set('value', element.text());\n        }\n      }\n\n      return function (scope, element, attr) {\n        var selectCtrlName = '$selectController',\n            parent = element.parent(),\n            selectCtrl = parent.data(selectCtrlName) ||\n              parent.parent().data(selectCtrlName); // in case we are in optgroup\n\n        if (selectCtrl && selectCtrl.databound) {\n          // For some reason Opera defaults to true and if not overridden this messes up the repeater.\n          // We don't want the view to drive the initialization of the model anyway.\n          element.prop('selected', false);\n        } else {\n          selectCtrl = nullSelectCtrl;\n        }\n\n        if (interpolateFn) {\n          scope.$watch(interpolateFn, function interpolateWatchAction(newVal, oldVal) {\n            attr.$set('value', newVal);\n            if (newVal !== oldVal) selectCtrl.removeOption(oldVal);\n            selectCtrl.addOption(newVal);\n          });\n        } else {\n          selectCtrl.addOption(attr.value);\n        }\n\n        element.on('$destroy', function() {\n          selectCtrl.removeOption(attr.value);\n        });\n      };\n    }\n  }\n}];\n\nvar styleDirective = valueFn({\n  restrict: 'E',\n  terminal: true\n});\n\n  //try to bind to jquery now so that one can write angular.element().read()\n  //but we will rebind on bootstrap again.\n  bindJQuery();\n\n  publishExternalAPI(angular);\n\n  jqLite(document).ready(function() {\n    angularInit(document, bootstrap);\n  });\n\n})(window, document);\nangular.element(document).find('head').prepend('<style type=\"text/css\">@charset \"UTF-8\";[ng\\\\:cloak],[ng-cloak],[data-ng-cloak],[x-ng-cloak],.ng-cloak,.x-ng-cloak,.ng-hide{display:none !important;}ng\\\\:form{display:block;}</style>');\ndefine(\"angular\", [\"jquery\"], (function (global) {\n    return function () {\n        var ret, fn;\n        return ret || global.angular;\n    };\n}(this)));\n","\n/**\n * @license AngularJS v1.2.0-rc.2\n * (c) 2010-2012 Google, Inc. http://angularjs.org\n * License: MIT\n */\n(function(window, angular, undefined) {'use strict';\n\nvar $resourceMinErr = angular.$$minErr('$resource');\n\n/**\n * @ngdoc overview\n * @name ngResource\n * @description\n *\n * # ngResource\n *\n * `ngResource` is the name of the optional Angular module that adds support for interacting with\n * [RESTful](http://en.wikipedia.org/wiki/Representational_State_Transfer) server-side data sources.\n * `ngReource` provides the {@link ngResource.$resource `$resource`} serivce.\n *\n * {@installModule resource}\n *\n * See {@link ngResource.$resource `$resource`} for usage.\n */\n\n/**\n * @ngdoc object\n * @name ngResource.$resource\n * @requires $http\n *\n * @description\n * A factory which creates a resource object that lets you interact with\n * [RESTful](http://en.wikipedia.org/wiki/Representational_State_Transfer) server-side data sources.\n *\n * The returned resource object has action methods which provide high-level behaviors without\n * the need to interact with the low level {@link ng.$http $http} service.\n *\n * Requires the {@link ngResource `ngResource`} module to be installed.\n *\n * @param {string} url A parametrized URL template with parameters prefixed by `:` as in\n *   `/user/:username`. If you are using a URL with a port number (e.g.\n *   `http://example.com:8080/api`), it will be respected.\n *\n *   If you are using a url with a suffix, just add the suffix, like this:\n *   `$resource('http://example.com/resource.json')` or `$resource('http://example.com/:id.json')`\n *   or even `$resource('http://example.com/resource/:resource_id.:format')`\n *   If the parameter before the suffix is empty, :resource_id in this case, then the `/.` will be\n *   collapsed down to a single `.`.  If you need this sequence to appear and not collapse then you\n *   can escape it with `/\\.`.\n *\n * @param {Object=} paramDefaults Default values for `url` parameters. These can be overridden in\n *   `actions` methods. If any of the parameter value is a function, it will be executed every time\n *   when a param value needs to be obtained for a request (unless the param was overridden).\n *\n *   Each key value in the parameter object is first bound to url template if present and then any\n *   excess keys are appended to the url search query after the `?`.\n *\n *   Given a template `/path/:verb` and parameter `{verb:'greet', salutation:'Hello'}` results in\n *   URL `/path/greet?salutation=Hello`.\n *\n *   If the parameter value is prefixed with `@` then the value of that parameter is extracted from\n *   the data object (useful for non-GET operations).\n *\n * @param {Object.<Object>=} actions Hash with declaration of custom action that should extend the\n *   default set of resource actions. The declaration should be created in the format of {@link\n *   ng.$http#Parameters $http.config}:\n *\n *       {action1: {method:?, params:?, isArray:?, headers:?, ...},\n *        action2: {method:?, params:?, isArray:?, headers:?, ...},\n *        ...}\n *\n *   Where:\n *\n *   - **`action`** – {string} – The name of action. This name becomes the name of the method on your\n *     resource object.\n *   - **`method`** – {string} – HTTP request method. Valid methods are: `GET`, `POST`, `PUT`, `DELETE`,\n *     and `JSONP`.\n *   - **`params`** – {Object=} – Optional set of pre-bound parameters for this action. If any of the\n *     parameter value is a function, it will be executed every time when a param value needs to be\n *     obtained for a request (unless the param was overridden).\n *   - **`url`** – {string} – action specific `url` override. The url templating is supported just like\n *     for the resource-level urls.\n *   - **`isArray`** – {boolean=} – If true then the returned object for this action is an array, see\n *     `returns` section.\n *   - **`transformRequest`** – `{function(data, headersGetter)|Array.<function(data, headersGetter)>}` –\n *     transform function or an array of such functions. The transform function takes the http\n *     request body and headers and returns its transformed (typically serialized) version.\n *   - **`transformResponse`** – `{function(data, headersGetter)|Array.<function(data, headersGetter)>}` –\n *     transform function or an array of such functions. The transform function takes the http\n *     response body and headers and returns its transformed (typically deserialized) version.\n *   - **`cache`** – `{boolean|Cache}` – If true, a default $http cache will be used to cache the\n *     GET request, otherwise if a cache instance built with\n *     {@link ng.$cacheFactory $cacheFactory}, this cache will be used for\n *     caching.\n *   - **`timeout`** – `{number|Promise}` – timeout in milliseconds, or {@link ng.$q promise} that\n *     should abort the request when resolved.\n *   - **`withCredentials`** - `{boolean}` - whether to to set the `withCredentials` flag on the\n *     XHR object. See {@link https://developer.mozilla.org/en/http_access_control#section_5\n *     requests with credentials} for more information.\n *   - **`responseType`** - `{string}` - see {@link\n *     https://developer.mozilla.org/en-US/docs/DOM/XMLHttpRequest#responseType requestType}.\n *   - **`interceptor`** - `{Object=}` - The interceptor object has two optional methods -\n *     `response` and `responseError`. Both `response` and `responseError` interceptors get called\n *     with `http response` object. See {@link ng.$http $http interceptors}.\n *\n * @returns {Object} A resource \"class\" object with methods for the default set of resource actions\n *   optionally extended with custom `actions`. The default set contains these actions:\n *\n *       { 'get':    {method:'GET'},\n *         'save':   {method:'POST'},\n *         'query':  {method:'GET', isArray:true},\n *         'remove': {method:'DELETE'},\n *         'delete': {method:'DELETE'} };\n *\n *   Calling these methods invoke an {@link ng.$http} with the specified http method,\n *   destination and parameters. When the data is returned from the server then the object is an\n *   instance of the resource class. The actions `save`, `remove` and `delete` are available on it\n *   as  methods with the `$` prefix. This allows you to easily perform CRUD operations (create,\n *   read, update, delete) on server-side data like this:\n *   <pre>\n        var User = $resource('/user/:userId', {userId:'@id'});\n        var user = User.get({userId:123}, function() {\n          user.abc = true;\n          user.$save();\n        });\n     </pre>\n *\n *   It is important to realize that invoking a $resource object method immediately returns an\n *   empty reference (object or array depending on `isArray`). Once the data is returned from the\n *   server the existing reference is populated with the actual data. This is a useful trick since\n *   usually the resource is assigned to a model which is then rendered by the view. Having an empty\n *   object results in no rendering, once the data arrives from the server then the object is\n *   populated with the data and the view automatically re-renders itself showing the new data. This\n *   means that in most case one never has to write a callback function for the action methods.\n *\n *   The action methods on the class object or instance object can be invoked with the following\n *   parameters:\n *\n *   - HTTP GET \"class\" actions: `Resource.action([parameters], [success], [error])`\n *   - non-GET \"class\" actions: `Resource.action([parameters], postData, [success], [error])`\n *   - non-GET instance actions:  `instance.$action([parameters], [success], [error])`\n *\n *   Success callback is called with (value, responseHeaders) arguments. Error callback is called\n *   with (httpResponse) argument.\n *\n *   Class actions return empty instance (with additional properties below).\n *   Instance actions return promise of the action.\n *\n *   The Resource instances and collection have these additional properties:\n *\n *   - `$promise`: the {@link ng.$q promise} of the original server interaction that created this\n *     instance or collection.\n *\n *     On success, the promise is resolved with the same resource instance or collection object,\n *     updated with data from server. This makes it easy to use in\n *     {@link ngRoute.$routeProvider resolve section of $routeProvider.when()} to defer view rendering\n *     until the resource(s) are loaded.\n *\n *     On failure, the promise is resolved with the {@link ng.$http http response} object,\n *     without the `resource` property.\n *\n *   - `$resolved`: `true` after first server interaction is completed (either with success or rejection),\n *     `false` before that. Knowing if the Resource has been resolved is useful in data-binding.\n *\n * @example\n *\n * # Credit card resource\n *\n * <pre>\n     // Define CreditCard class\n     var CreditCard = $resource('/user/:userId/card/:cardId',\n      {userId:123, cardId:'@id'}, {\n       charge: {method:'POST', params:{charge:true}}\n      });\n\n     // We can retrieve a collection from the server\n     var cards = CreditCard.query(function() {\n       // GET: /user/123/card\n       // server returns: [ {id:456, number:'1234', name:'Smith'} ];\n\n       var card = cards[0];\n       // each item is an instance of CreditCard\n       expect(card instanceof CreditCard).toEqual(true);\n       card.name = \"J. Smith\";\n       // non GET methods are mapped onto the instances\n       card.$save();\n       // POST: /user/123/card/456 {id:456, number:'1234', name:'J. Smith'}\n       // server returns: {id:456, number:'1234', name: 'J. Smith'};\n\n       // our custom method is mapped as well.\n       card.$charge({amount:9.99});\n       // POST: /user/123/card/456?amount=9.99&charge=true {id:456, number:'1234', name:'J. Smith'}\n     });\n\n     // we can create an instance as well\n     var newCard = new CreditCard({number:'0123'});\n     newCard.name = \"Mike Smith\";\n     newCard.$save();\n     // POST: /user/123/card {number:'0123', name:'Mike Smith'}\n     // server returns: {id:789, number:'01234', name: 'Mike Smith'};\n     expect(newCard.id).toEqual(789);\n * </pre>\n *\n * The object returned from this function execution is a resource \"class\" which has \"static\" method\n * for each action in the definition.\n *\n * Calling these methods invoke `$http` on the `url` template with the given `method`, `params` and `headers`.\n * When the data is returned from the server then the object is an instance of the resource type and\n * all of the non-GET methods are available with `$` prefix. This allows you to easily support CRUD\n * operations (create, read, update, delete) on server-side data.\n\n   <pre>\n     var User = $resource('/user/:userId', {userId:'@id'});\n     var user = User.get({userId:123}, function() {\n       user.abc = true;\n       user.$save();\n     });\n   </pre>\n *\n * It's worth noting that the success callback for `get`, `query` and other method gets passed\n * in the response that came from the server as well as $http header getter function, so one\n * could rewrite the above example and get access to http headers as:\n *\n   <pre>\n     var User = $resource('/user/:userId', {userId:'@id'});\n     User.get({userId:123}, function(u, getResponseHeaders){\n       u.abc = true;\n       u.$save(function(u, putResponseHeaders) {\n         //u => saved user object\n         //putResponseHeaders => $http header getter\n       });\n     });\n   </pre>\n\n * # Buzz client\n\n   Let's look at what a buzz client created with the `$resource` service looks like:\n    <doc:example>\n      <doc:source jsfiddle=\"false\">\n       <script>\n         function BuzzController($resource) {\n           this.userId = 'googlebuzz';\n           this.Activity = $resource(\n             'https://www.googleapis.com/buzz/v1/activities/:userId/:visibility/:activityId/:comments',\n             {alt:'json', callback:'JSON_CALLBACK'},\n             {get:{method:'JSONP', params:{visibility:'@self'}}, replies: {method:'JSONP', params:{visibility:'@self', comments:'@comments'}}}\n           );\n         }\n\n         BuzzController.prototype = {\n           fetch: function() {\n             this.activities = this.Activity.get({userId:this.userId});\n           },\n           expandReplies: function(activity) {\n             activity.replies = this.Activity.replies({userId:this.userId, activityId:activity.id});\n           }\n         };\n         BuzzController.$inject = ['$resource'];\n       </script>\n\n       <div ng-controller=\"BuzzController\">\n         <input ng-model=\"userId\"/>\n         <button ng-click=\"fetch()\">fetch</button>\n         <hr/>\n         <div ng-repeat=\"item in activities.data.items\">\n           <h1 style=\"font-size: 15px;\">\n             <img src=\"{{item.actor.thumbnailUrl}}\" style=\"max-height:30px;max-width:30px;\"/>\n             <a href=\"{{item.actor.profileUrl}}\">{{item.actor.name}}</a>\n             <a href ng-click=\"expandReplies(item)\" style=\"float: right;\">Expand replies: {{item.links.replies[0].count}}</a>\n           </h1>\n           {{item.object.content | html}}\n           <div ng-repeat=\"reply in item.replies.data.items\" style=\"margin-left: 20px;\">\n             <img src=\"{{reply.actor.thumbnailUrl}}\" style=\"max-height:30px;max-width:30px;\"/>\n             <a href=\"{{reply.actor.profileUrl}}\">{{reply.actor.name}}</a>: {{reply.content | html}}\n           </div>\n         </div>\n       </div>\n      </doc:source>\n      <doc:scenario>\n      </doc:scenario>\n    </doc:example>\n */\nangular.module('ngResource', ['ng']).\n  factory('$resource', ['$http', '$parse', '$q', function($http, $parse, $q) {\n    var DEFAULT_ACTIONS = {\n      'get':    {method:'GET'},\n      'save':   {method:'POST'},\n      'query':  {method:'GET', isArray:true},\n      'remove': {method:'DELETE'},\n      'delete': {method:'DELETE'}\n    };\n    var noop = angular.noop,\n        forEach = angular.forEach,\n        extend = angular.extend,\n        copy = angular.copy,\n        isFunction = angular.isFunction,\n        getter = function(obj, path) {\n          return $parse(path)(obj);\n        };\n\n    /**\n     * We need our custom method because encodeURIComponent is too aggressive and doesn't follow\n     * http://www.ietf.org/rfc/rfc3986.txt with regards to the character set (pchar) allowed in path\n     * segments:\n     *    segment       = *pchar\n     *    pchar         = unreserved / pct-encoded / sub-delims / \":\" / \"@\"\n     *    pct-encoded   = \"%\" HEXDIG HEXDIG\n     *    unreserved    = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n     *    sub-delims    = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\"\n     *                     / \"*\" / \"+\" / \",\" / \";\" / \"=\"\n     */\n    function encodeUriSegment(val) {\n      return encodeUriQuery(val, true).\n        replace(/%26/gi, '&').\n        replace(/%3D/gi, '=').\n        replace(/%2B/gi, '+');\n    }\n\n\n    /**\n     * This method is intended for encoding *key* or *value* parts of query component. We need a custom\n     * method because encodeURIComponent is too aggressive and encodes stuff that doesn't have to be\n     * encoded per http://tools.ietf.org/html/rfc3986:\n     *    query       = *( pchar / \"/\" / \"?\" )\n     *    pchar         = unreserved / pct-encoded / sub-delims / \":\" / \"@\"\n     *    unreserved    = ALPHA / DIGIT / \"-\" / \".\" / \"_\" / \"~\"\n     *    pct-encoded   = \"%\" HEXDIG HEXDIG\n     *    sub-delims    = \"!\" / \"$\" / \"&\" / \"'\" / \"(\" / \")\"\n     *                     / \"*\" / \"+\" / \",\" / \";\" / \"=\"\n     */\n    function encodeUriQuery(val, pctEncodeSpaces) {\n      return encodeURIComponent(val).\n        replace(/%40/gi, '@').\n        replace(/%3A/gi, ':').\n        replace(/%24/g, '$').\n        replace(/%2C/gi, ',').\n        replace(/%20/g, (pctEncodeSpaces ? '%20' : '+'));\n    }\n\n    function Route(template, defaults) {\n      this.template = template;\n      this.defaults = defaults || {};\n      this.urlParams = {};\n    }\n\n    Route.prototype = {\n      setUrlParams: function(config, params, actionUrl) {\n        var self = this,\n            url = actionUrl || self.template,\n            val,\n            encodedVal;\n\n        var urlParams = self.urlParams = {};\n        forEach(url.split(/\\W/), function(param){\n          if (!(new RegExp(\"^\\\\d+$\").test(param)) && param && (new RegExp(\"(^|[^\\\\\\\\]):\" + param + \"(\\\\W|$)\").test(url))) {\n              urlParams[param] = true;\n          }\n        });\n        url = url.replace(/\\\\:/g, ':');\n\n        params = params || {};\n        forEach(self.urlParams, function(_, urlParam){\n          val = params.hasOwnProperty(urlParam) ? params[urlParam] : self.defaults[urlParam];\n          if (angular.isDefined(val) && val !== null) {\n            encodedVal = encodeUriSegment(val);\n            url = url.replace(new RegExp(\":\" + urlParam + \"(\\\\W|$)\", \"g\"), encodedVal + \"$1\");\n          } else {\n            url = url.replace(new RegExp(\"(\\/?):\" + urlParam + \"(\\\\W|$)\", \"g\"), function(match,\n                leadingSlashes, tail) {\n              if (tail.charAt(0) == '/') {\n                return tail;\n              } else {\n                return leadingSlashes + tail;\n              }\n            });\n          }\n        });\n\n        // strip trailing slashes and set the url\n        url = url.replace(/\\/+$/, '');\n        // then replace collapse `/.` if found in the last URL path segment before the query\n        // E.g. `http://url.com/id./format?q=x` becomes `http://url.com/id.format?q=x`\n        url = url.replace(/\\/\\.(?=\\w+($|\\?))/, '.');\n        // replace escaped `/\\.` with `/.`\n        config.url = url.replace(/\\/\\\\\\./, '/.');\n\n\n        // set params - delegate param encoding to $http\n        forEach(params, function(value, key){\n          if (!self.urlParams[key]) {\n            config.params = config.params || {};\n            config.params[key] = value;\n          }\n        });\n      }\n    };\n\n\n    function ResourceFactory(url, paramDefaults, actions) {\n      var route = new Route(url);\n\n      actions = extend({}, DEFAULT_ACTIONS, actions);\n\n      function extractParams(data, actionParams){\n        var ids = {};\n        actionParams = extend({}, paramDefaults, actionParams);\n        forEach(actionParams, function(value, key){\n          if (isFunction(value)) { value = value(); }\n          ids[key] = value && value.charAt && value.charAt(0) == '@' ? getter(data, value.substr(1)) : value;\n        });\n        return ids;\n      }\n\n      function defaultResponseInterceptor(response) {\n        return response.resource;\n      }\n\n      function Resource(value){\n        copy(value || {}, this);\n      }\n\n      forEach(actions, function(action, name) {\n        var hasBody = /^(POST|PUT|PATCH)$/i.test(action.method);\n\n        Resource[name] = function(a1, a2, a3, a4) {\n          var params = {}, data, success, error;\n\n          switch(arguments.length) {\n          case 4:\n            error = a4;\n            success = a3;\n            //fallthrough\n          case 3:\n          case 2:\n            if (isFunction(a2)) {\n              if (isFunction(a1)) {\n                success = a1;\n                error = a2;\n                break;\n              }\n\n              success = a2;\n              error = a3;\n              //fallthrough\n            } else {\n              params = a1;\n              data = a2;\n              success = a3;\n              break;\n            }\n          case 1:\n            if (isFunction(a1)) success = a1;\n            else if (hasBody) data = a1;\n            else params = a1;\n            break;\n          case 0: break;\n          default:\n            throw $resourceMinErr('badargs',\n              \"Expected up to 4 arguments [params, data, success, error], got {0} arguments\", arguments.length);\n          }\n\n          var isInstanceCall = data instanceof Resource;\n          var value = isInstanceCall ? data : (action.isArray ? [] : new Resource(data));\n          var httpConfig = {};\n          var responseInterceptor = action.interceptor && action.interceptor.response || defaultResponseInterceptor;\n          var responseErrorInterceptor = action.interceptor && action.interceptor.responseError || undefined;\n\n          forEach(action, function(value, key) {\n            if (key != 'params' && key != 'isArray' && key != 'interceptor') {\n              httpConfig[key] = copy(value);\n            }\n          });\n\n          httpConfig.data = data;\n          route.setUrlParams(httpConfig, extend({}, extractParams(data, action.params || {}), params), action.url);\n\n          var promise = $http(httpConfig).then(function(response) {\n            var data = response.data,\n                promise = value.$promise;\n\n            if (data) {\n              if ( angular.isArray(data) != !!action.isArray ) {\n                throw $resourceMinErr('badcfg', 'Error in resource configuration. Expected response' +\n                  ' to contain an {0} but got an {1}',\n                  action.isArray?'array':'object', angular.isArray(data)?'array':'object');\n              }\n              if (action.isArray) {\n                value.length = 0;\n                forEach(data, function(item) {\n                  value.push(new Resource(item));\n                });\n              } else {\n                copy(data, value);\n                value.$promise = promise;\n              }\n            }\n\n            value.$resolved = true;\n\n            (success||noop)(value, response.headers);\n\n            response.resource = value;\n\n            return response;\n          }, function(response) {\n            value.$resolved = true;\n\n            (error||noop)(response);\n\n            return $q.reject(response);\n          }).then(responseInterceptor, responseErrorInterceptor);\n\n\n          if (!isInstanceCall) {\n            // we are creating instance / collection\n            // - set the initial promise\n            // - return the instance / collection\n            value.$promise = promise;\n            value.$resolved = false;\n\n            return value;\n          }\n\n          // instance call\n          return promise;\n        };\n\n\n        Resource.prototype['$' + name] = function(params, success, error) {\n          if (isFunction(params)) {\n            error = success; success = params; params = {};\n          }\n          var result = Resource[name](params, this, success, error);\n          return result.$promise || result;\n        };\n      });\n\n      Resource.bind = function(additionalParamDefaults){\n        return ResourceFactory(url, extend({}, paramDefaults, additionalParamDefaults), actions);\n      };\n\n      return Resource;\n    }\n\n    return ResourceFactory;\n  }]);\n\n\n})(window, window.angular);\n\ndefine(\"ngResource\", [\"angular\"], (function (global) {\n    return function () {\n        var ret, fn;\n        return ret || global.ngResource;\n    };\n}(this)));\n","\n/**\n * @license AngularJS v1.2.0-rc.2\n * (c) 2010-2012 Google, Inc. http://angularjs.org\n * License: MIT\n */\n(function(window, angular, undefined) {'use strict';\n\nvar copy = angular.copy,\n    equals = angular.equals,\n    extend = angular.extend,\n    forEach = angular.forEach,\n    isDefined = angular.isDefined,\n    isFunction = angular.isFunction,\n    isString = angular.isString,\n    jqLite = angular.element,\n    noop = angular.noop,\n    toJson = angular.toJson;\n\n\nfunction inherit(parent, extra) {\n  return extend(new (extend(function() {}, {prototype:parent}))(), extra);\n}\n\n/**\n * @ngdoc overview\n * @name ngRoute\n * @description\n *\n * # ngRoute\n *\n * The `ngRoute` module provides routing and deeplinking services and directives for angular apps.\n *\n * {@installModule route}\n *\n */\n\nvar ngRouteModule = angular.module('ngRoute', ['ng']).\n                        provider('$route', $RouteProvider);\n\n/**\n * @ngdoc object\n * @name ngRoute.$routeProvider\n * @function\n *\n * @description\n *\n * Used for configuring routes. See {@link ngRoute.$route $route} for an example.\n *\n * Requires the {@link ngRoute `ngRoute`} module to be installed.\n */\nfunction $RouteProvider(){\n  var routes = {};\n\n  /**\n   * @ngdoc method\n   * @name ngRoute.$routeProvider#when\n   * @methodOf ngRoute.$routeProvider\n   *\n   * @param {string} path Route path (matched against `$location.path`). If `$location.path`\n   *    contains redundant trailing slash or is missing one, the route will still match and the\n   *    `$location.path` will be updated to add or drop the trailing slash to exactly match the\n   *    route definition.\n   *\n   *      * `path` can contain named groups starting with a colon (`:name`). All characters up\n   *        to the next slash are matched and stored in `$routeParams` under the given `name`\n   *        when the route matches.\n   *      * `path` can contain named groups starting with a colon and ending with a star (`:name*`).\n   *        All characters are eagerly stored in `$routeParams` under the given `name`\n   *        when the route matches.\n   *      * `path` can contain optional named groups with a question mark (`:name?`).\n   *\n   *    For example, routes like `/color/:color/largecode/:largecode*\\/edit` will match\n   *    `/color/brown/largecode/code/with/slashs/edit` and extract:\n   *\n   *      * `color: brown`\n   *      * `largecode: code/with/slashs`.\n   *\n   *\n   * @param {Object} route Mapping information to be assigned to `$route.current` on route\n   *    match.\n   *\n   *    Object properties:\n   *\n   *    - `controller` – `{(string|function()=}` – Controller fn that should be associated with newly\n   *      created scope or the name of a {@link angular.Module#controller registered controller}\n   *      if passed as a string.\n   *    - `controllerAs` – `{string=}` – A controller alias name. If present the controller will be\n   *      published to scope under the `controllerAs` name.\n   *    - `template` – `{string=|function()=}` – html template as a string or a function that\n   *      returns an html template as a string which should be used by {@link\n   *      ngRoute.directive:ngView ngView} or {@link ng.directive:ngInclude ngInclude} directives.\n   *      This property takes precedence over `templateUrl`.\n   *\n   *      If `template` is a function, it will be called with the following parameters:\n   *\n   *      - `{Array.<Object>}` - route parameters extracted from the current\n   *        `$location.path()` by applying the current route\n   *\n   *    - `templateUrl` – `{string=|function()=}` – path or function that returns a path to an html\n   *      template that should be used by {@link ngRoute.directive:ngView ngView}.\n   *\n   *      If `templateUrl` is a function, it will be called with the following parameters:\n   *\n   *      - `{Array.<Object>}` - route parameters extracted from the current\n   *        `$location.path()` by applying the current route\n   *\n   *    - `resolve` - `{Object.<string, function>=}` - An optional map of dependencies which should\n   *      be injected into the controller. If any of these dependencies are promises, they will be\n   *      resolved and converted to a value before the controller is instantiated and the\n   *      `$routeChangeSuccess` event is fired. The map object is:\n   *\n   *      - `key` – `{string}`: a name of a dependency to be injected into the controller.\n   *      - `factory` - `{string|function}`: If `string` then it is an alias for a service.\n   *        Otherwise if function, then it is {@link api/AUTO.$injector#invoke injected}\n   *        and the return value is treated as the dependency. If the result is a promise, it is resolved\n   *        before its value is injected into the controller. Be aware that `ngRoute.$routeParams` will\n   *        still refer to the previous route within these resolve functions.  Use `$route.current.params`\n   *        to access the new route parameters, instead.\n   *\n   *    - `redirectTo` – {(string|function())=} – value to update\n   *      {@link ng.$location $location} path with and trigger route redirection.\n   *\n   *      If `redirectTo` is a function, it will be called with the following parameters:\n   *\n   *      - `{Object.<string>}` - route parameters extracted from the current\n   *        `$location.path()` by applying the current route templateUrl.\n   *      - `{string}` - current `$location.path()`\n   *      - `{Object}` - current `$location.search()`\n   *\n   *      The custom `redirectTo` function is expected to return a string which will be used\n   *      to update `$location.path()` and `$location.search()`.\n   *\n   *    - `[reloadOnSearch=true]` - {boolean=} - reload route when only $location.search()\n   *    changes.\n   *\n   *      If the option is set to `false` and url in the browser changes, then\n   *      `$routeUpdate` event is broadcasted on the root scope.\n   *\n   *    - `[caseInsensitiveMatch=false]` - {boolean=} - match routes without being case sensitive\n   *\n   *      If the option is set to `true`, then the particular route can be matched without being\n   *      case sensitive\n   *\n   * @returns {Object} self\n   *\n   * @description\n   * Adds a new route definition to the `$route` service.\n   */\n  this.when = function(path, route) {\n    routes[path] = extend(\n      {reloadOnSearch: true},\n      route,\n      path && pathRegExp(path, route)\n    );\n\n    // create redirection for trailing slashes\n    if (path) {\n      var redirectPath = (path[path.length-1] == '/')\n            ? path.substr(0, path.length-1)\n            : path +'/';\n\n      routes[redirectPath] = extend(\n        {redirectTo: path},\n        pathRegExp(redirectPath, route)\n      );\n    }\n\n    return this;\n  };\n\n   /**\n    * @param path {string} path\n    * @param opts {Object} options\n    * @return {?Object}\n    *\n    * @description\n    * Normalizes the given path, returning a regular expression\n    * and the original path.\n    *\n    * Inspired by pathRexp in visionmedia/express/lib/utils.js.\n    */\n  function pathRegExp(path, opts) {\n    var insensitive = opts.caseInsensitiveMatch,\n        ret = {\n          originalPath: path,\n          regexp: path\n        },\n        keys = ret.keys = [];\n\n    path = path\n      .replace(/([().])/g, '\\\\$1')\n      .replace(/(\\/)?:(\\w+)([\\?|\\*])?/g, function(_, slash, key, option){\n        var optional = option === '?' ? option : null;\n        var star = option === '*' ? option : null;\n        keys.push({ name: key, optional: !!optional });\n        slash = slash || '';\n        return ''\n          + (optional ? '' : slash)\n          + '(?:'\n          + (optional ? slash : '')\n          + (star && '(.+)?' || '([^/]+)?') + ')'\n          + (optional || '');\n      })\n      .replace(/([\\/$\\*])/g, '\\\\$1');\n\n    ret.regexp = new RegExp('^' + path + '$', insensitive ? 'i' : '');\n    return ret;\n  }\n\n  /**\n   * @ngdoc method\n   * @name ngRoute.$routeProvider#otherwise\n   * @methodOf ngRoute.$routeProvider\n   *\n   * @description\n   * Sets route definition that will be used on route change when no other route definition\n   * is matched.\n   *\n   * @param {Object} params Mapping information to be assigned to `$route.current`.\n   * @returns {Object} self\n   */\n  this.otherwise = function(params) {\n    this.when(null, params);\n    return this;\n  };\n\n\n  this.$get = ['$rootScope', '$location', '$routeParams', '$q', '$injector', '$http', '$templateCache', '$sce',\n      function( $rootScope,   $location,   $routeParams,   $q,   $injector,   $http,   $templateCache,   $sce) {\n\n    /**\n     * @ngdoc object\n     * @name ngRoute.$route\n     * @requires $location\n     * @requires $routeParams\n     *\n     * @property {Object} current Reference to the current route definition.\n     * The route definition contains:\n     *\n     *   - `controller`: The controller constructor as define in route definition.\n     *   - `locals`: A map of locals which is used by {@link ng.$controller $controller} service for\n     *     controller instantiation. The `locals` contain\n     *     the resolved values of the `resolve` map. Additionally the `locals` also contain:\n     *\n     *     - `$scope` - The current route scope.\n     *     - `$template` - The current route template HTML.\n     *\n     * @property {Array.<Object>} routes Array of all configured routes.\n     *\n     * @description\n     * `$route` is used for deep-linking URLs to controllers and views (HTML partials).\n     * It watches `$location.url()` and tries to map the path to an existing route definition.\n     *\n     * Requires the {@link ngRoute `ngRoute`} module to be installed.\n     *\n     * You can define routes through {@link ngRoute.$routeProvider $routeProvider}'s API.\n     *\n     * The `$route` service is typically used in conjunction with the {@link ngRoute.directive:ngView `ngView`}\n     * directive and the {@link ngRoute.$routeParams `$routeParams`} service.\n     *\n     * @example\n       This example shows how changing the URL hash causes the `$route` to match a route against the\n       URL, and the `ngView` pulls in the partial.\n\n       Note that this example is using {@link ng.directive:script inlined templates}\n       to get it working on jsfiddle as well.\n\n     <example module=\"ngView\" deps=\"angular-route.js\">\n       <file name=\"index.html\">\n         <div ng-controller=\"MainCntl\">\n           Choose:\n           <a href=\"Book/Moby\">Moby</a> |\n           <a href=\"Book/Moby/ch/1\">Moby: Ch1</a> |\n           <a href=\"Book/Gatsby\">Gatsby</a> |\n           <a href=\"Book/Gatsby/ch/4?key=value\">Gatsby: Ch4</a> |\n           <a href=\"Book/Scarlet\">Scarlet Letter</a><br/>\n\n           <div ng-view></div>\n           <hr />\n\n           <pre>$location.path() = {{$location.path()}}</pre>\n           <pre>$route.current.templateUrl = {{$route.current.templateUrl}}</pre>\n           <pre>$route.current.params = {{$route.current.params}}</pre>\n           <pre>$route.current.scope.name = {{$route.current.scope.name}}</pre>\n           <pre>$routeParams = {{$routeParams}}</pre>\n         </div>\n       </file>\n\n       <file name=\"book.html\">\n         controller: {{name}}<br />\n         Book Id: {{params.bookId}}<br />\n       </file>\n\n       <file name=\"chapter.html\">\n         controller: {{name}}<br />\n         Book Id: {{params.bookId}}<br />\n         Chapter Id: {{params.chapterId}}\n       </file>\n\n       <file name=\"script.js\">\n         angular.module('ngView', ['ngRoute']).config(function($routeProvider, $locationProvider) {\n           $routeProvider.when('/Book/:bookId', {\n             templateUrl: 'book.html',\n             controller: BookCntl,\n             resolve: {\n               // I will cause a 1 second delay\n               delay: function($q, $timeout) {\n                 var delay = $q.defer();\n                 $timeout(delay.resolve, 1000);\n                 return delay.promise;\n               }\n             }\n           });\n           $routeProvider.when('/Book/:bookId/ch/:chapterId', {\n             templateUrl: 'chapter.html',\n             controller: ChapterCntl\n           });\n\n           // configure html5 to get links working on jsfiddle\n           $locationProvider.html5Mode(true);\n         });\n\n         function MainCntl($scope, $route, $routeParams, $location) {\n           $scope.$route = $route;\n           $scope.$location = $location;\n           $scope.$routeParams = $routeParams;\n         }\n\n         function BookCntl($scope, $routeParams) {\n           $scope.name = \"BookCntl\";\n           $scope.params = $routeParams;\n         }\n\n         function ChapterCntl($scope, $routeParams) {\n           $scope.name = \"ChapterCntl\";\n           $scope.params = $routeParams;\n         }\n       </file>\n\n       <file name=\"scenario.js\">\n         it('should load and compile correct template', function() {\n           element('a:contains(\"Moby: Ch1\")').click();\n           var content = element('.doc-example-live [ng-view]').text();\n           expect(content).toMatch(/controller\\: ChapterCntl/);\n           expect(content).toMatch(/Book Id\\: Moby/);\n           expect(content).toMatch(/Chapter Id\\: 1/);\n\n           element('a:contains(\"Scarlet\")').click();\n           sleep(2); // promises are not part of scenario waiting\n           content = element('.doc-example-live [ng-view]').text();\n           expect(content).toMatch(/controller\\: BookCntl/);\n           expect(content).toMatch(/Book Id\\: Scarlet/);\n         });\n       </file>\n     </example>\n     */\n\n    /**\n     * @ngdoc event\n     * @name ngRoute.$route#$routeChangeStart\n     * @eventOf ngRoute.$route\n     * @eventType broadcast on root scope\n     * @description\n     * Broadcasted before a route change. At this  point the route services starts\n     * resolving all of the dependencies needed for the route change to occurs.\n     * Typically this involves fetching the view template as well as any dependencies\n     * defined in `resolve` route property. Once  all of the dependencies are resolved\n     * `$routeChangeSuccess` is fired.\n     *\n     * @param {Route} next Future route information.\n     * @param {Route} current Current route information.\n     */\n\n    /**\n     * @ngdoc event\n     * @name ngRoute.$route#$routeChangeSuccess\n     * @eventOf ngRoute.$route\n     * @eventType broadcast on root scope\n     * @description\n     * Broadcasted after a route dependencies are resolved.\n     * {@link ngRoute.directive:ngView ngView} listens for the directive\n     * to instantiate the controller and render the view.\n     *\n     * @param {Object} angularEvent Synthetic event object.\n     * @param {Route} current Current route information.\n     * @param {Route|Undefined} previous Previous route information, or undefined if current is first route entered.\n     */\n\n    /**\n     * @ngdoc event\n     * @name ngRoute.$route#$routeChangeError\n     * @eventOf ngRoute.$route\n     * @eventType broadcast on root scope\n     * @description\n     * Broadcasted if any of the resolve promises are rejected.\n     *\n     * @param {Route} current Current route information.\n     * @param {Route} previous Previous route information.\n     * @param {Route} rejection Rejection of the promise. Usually the error of the failed promise.\n     */\n\n    /**\n     * @ngdoc event\n     * @name ngRoute.$route#$routeUpdate\n     * @eventOf ngRoute.$route\n     * @eventType broadcast on root scope\n     * @description\n     *\n     * The `reloadOnSearch` property has been set to false, and we are reusing the same\n     * instance of the Controller.\n     */\n\n    var forceReload = false,\n        $route = {\n          routes: routes,\n\n          /**\n           * @ngdoc method\n           * @name ngRoute.$route#reload\n           * @methodOf ngRoute.$route\n           *\n           * @description\n           * Causes `$route` service to reload the current route even if\n           * {@link ng.$location $location} hasn't changed.\n           *\n           * As a result of that, {@link ngRoute.directive:ngView ngView}\n           * creates new scope, reinstantiates the controller.\n           */\n          reload: function() {\n            forceReload = true;\n            $rootScope.$evalAsync(updateRoute);\n          }\n        };\n\n    $rootScope.$on('$locationChangeSuccess', updateRoute);\n\n    return $route;\n\n    /////////////////////////////////////////////////////\n\n    /**\n     * @param on {string} current url\n     * @param route {Object} route regexp to match the url against\n     * @return {?Object}\n     *\n     * @description\n     * Check if the route matches the current url.\n     *\n     * Inspired by match in\n     * visionmedia/express/lib/router/router.js.\n     */\n    function switchRouteMatcher(on, route) {\n      var keys = route.keys,\n          params = {};\n\n      if (!route.regexp) return null;\n\n      var m = route.regexp.exec(on);\n      if (!m) return null;\n\n      for (var i = 1, len = m.length; i < len; ++i) {\n        var key = keys[i - 1];\n\n        var val = 'string' == typeof m[i]\n              ? decodeURIComponent(m[i])\n              : m[i];\n\n        if (key && val) {\n          params[key.name] = val;\n        }\n      }\n      return params;\n    }\n\n    function updateRoute() {\n      var next = parseRoute(),\n          last = $route.current;\n\n      if (next && last && next.$$route === last.$$route\n          && equals(next.pathParams, last.pathParams) && !next.reloadOnSearch && !forceReload) {\n        last.params = next.params;\n        copy(last.params, $routeParams);\n        $rootScope.$broadcast('$routeUpdate', last);\n      } else if (next || last) {\n        forceReload = false;\n        $rootScope.$broadcast('$routeChangeStart', next, last);\n        $route.current = next;\n        if (next) {\n          if (next.redirectTo) {\n            if (isString(next.redirectTo)) {\n              $location.path(interpolate(next.redirectTo, next.params)).search(next.params)\n                       .replace();\n            } else {\n              $location.url(next.redirectTo(next.pathParams, $location.path(), $location.search()))\n                       .replace();\n            }\n          }\n        }\n\n        $q.when(next).\n          then(function() {\n            if (next) {\n              var locals = extend({}, next.resolve),\n                  template, templateUrl;\n\n              forEach(locals, function(value, key) {\n                locals[key] = isString(value) ? $injector.get(value) : $injector.invoke(value);\n              });\n\n              if (isDefined(template = next.template)) {\n                if (isFunction(template)) {\n                  template = template(next.params);\n                }\n              } else if (isDefined(templateUrl = next.templateUrl)) {\n                if (isFunction(templateUrl)) {\n                  templateUrl = templateUrl(next.params);\n                }\n                templateUrl = $sce.getTrustedResourceUrl(templateUrl);\n                if (isDefined(templateUrl)) {\n                  next.loadedTemplateUrl = templateUrl;\n                  template = $http.get(templateUrl, {cache: $templateCache}).\n                      then(function(response) { return response.data; });\n                }\n              }\n              if (isDefined(template)) {\n                locals['$template'] = template;\n              }\n              return $q.all(locals);\n            }\n          }).\n          // after route change\n          then(function(locals) {\n            if (next == $route.current) {\n              if (next) {\n                next.locals = locals;\n                copy(next.params, $routeParams);\n              }\n              $rootScope.$broadcast('$routeChangeSuccess', next, last);\n            }\n          }, function(error) {\n            if (next == $route.current) {\n              $rootScope.$broadcast('$routeChangeError', next, last, error);\n            }\n          });\n      }\n    }\n\n\n    /**\n     * @returns the current active route, by matching it against the URL\n     */\n    function parseRoute() {\n      // Match a route\n      var params, match;\n      forEach(routes, function(route, path) {\n        if (!match && (params = switchRouteMatcher($location.path(), route))) {\n          match = inherit(route, {\n            params: extend({}, $location.search(), params),\n            pathParams: params});\n          match.$$route = route;\n        }\n      });\n      // No route matched; fallback to \"otherwise\" route\n      return match || routes[null] && inherit(routes[null], {params: {}, pathParams:{}});\n    }\n\n    /**\n     * @returns interpolation of the redirect path with the parameters\n     */\n    function interpolate(string, params) {\n      var result = [];\n      forEach((string||'').split(':'), function(segment, i) {\n        if (i === 0) {\n          result.push(segment);\n        } else {\n          var segmentMatch = segment.match(/(\\w+)(.*)/);\n          var key = segmentMatch[1];\n          result.push(params[key]);\n          result.push(segmentMatch[2] || '');\n          delete params[key];\n        }\n      });\n      return result.join('');\n    }\n  }];\n}\n\nngRouteModule.provider('$routeParams', $RouteParamsProvider);\n\n\n/**\n * @ngdoc object\n * @name ngRoute.$routeParams\n * @requires $route\n *\n * @description\n * The `$routeParams` service allows you to retrieve the current set of route parameters.\n *\n * Requires the {@link ngRoute `ngRoute`} module to be installed.\n *\n * The route parameters are a combination of {@link ng.$location `$location`}'s\n * {@link ng.$location#search `search()`} and {@link ng.$location#path `path()`}.\n * The `path` parameters are extracted when the {@link ngRoute.$route `$route`} path is matched.\n *\n * In case of parameter name collision, `path` params take precedence over `search` params.\n *\n * The service guarantees that the identity of the `$routeParams` object will remain unchanged\n * (but its properties will likely change) even when a route change occurs.\n *\n * Note that the `$routeParams` are only updated *after* a route change completes successfully.\n * This means that you cannot rely on `$routeParams` being correct in route resolve functions.\n * Instead you can use `$route.current.params` to access the new route's parameters.\n *\n * @example\n * <pre>\n *  // Given:\n *  // URL: http://server.com/index.html#/Chapter/1/Section/2?search=moby\n *  // Route: /Chapter/:chapterId/Section/:sectionId\n *  //\n *  // Then\n *  $routeParams ==> {chapterId:1, sectionId:2, search:'moby'}\n * </pre>\n */\nfunction $RouteParamsProvider() {\n  this.$get = function() { return {}; };\n}\n\nngRouteModule.directive('ngView', ngViewFactory);\n\n/**\n * @ngdoc directive\n * @name ngRoute.directive:ngView\n * @restrict ECA\n *\n * @description\n * # Overview\n * `ngView` is a directive that complements the {@link ngRoute.$route $route} service by\n * including the rendered template of the current route into the main layout (`index.html`) file.\n * Every time the current route changes, the included view changes with it according to the\n * configuration of the `$route` service.\n *\n * Requires the {@link ngRoute `ngRoute`} module to be installed.\n *\n * @animations\n * enter - animation is used to bring new content into the browser.\n * leave - animation is used to animate existing content away.\n *\n * The enter and leave animation occur concurrently.\n *\n * @scope\n * @example\n    <example module=\"ngViewExample\" deps=\"angular-route.js\" animations=\"true\">\n      <file name=\"index.html\">\n        <div ng-controller=\"MainCntl as main\">\n          Choose:\n          <a href=\"Book/Moby\">Moby</a> |\n          <a href=\"Book/Moby/ch/1\">Moby: Ch1</a> |\n          <a href=\"Book/Gatsby\">Gatsby</a> |\n          <a href=\"Book/Gatsby/ch/4?key=value\">Gatsby: Ch4</a> |\n          <a href=\"Book/Scarlet\">Scarlet Letter</a><br/>\n\n          <div class=\"example-animate-container\">\n            <div ng-view class=\"view-example\"></div>\n          </div>\n          <hr />\n\n          <pre>$location.path() = {{main.$location.path()}}</pre>\n          <pre>$route.current.templateUrl = {{main.$route.current.templateUrl}}</pre>\n          <pre>$route.current.params = {{main.$route.current.params}}</pre>\n          <pre>$route.current.scope.name = {{main.$route.current.scope.name}}</pre>\n          <pre>$routeParams = {{main.$routeParams}}</pre>\n        </div>\n      </file>\n\n      <file name=\"book.html\">\n        <div>\n          controller: {{book.name}}<br />\n          Book Id: {{book.params.bookId}}<br />\n        </div>\n      </file>\n\n      <file name=\"chapter.html\">\n        <div>\n          controller: {{chapter.name}}<br />\n          Book Id: {{chapter.params.bookId}}<br />\n          Chapter Id: {{chapter.params.chapterId}}\n        </div>\n      </file>\n\n      <file name=\"animations.css\">\n        .example-animate-container {\n          position:relative;\n          background:white;\n          border:1px solid black;\n          height:40px;\n          overflow:hidden;\n        }\n\n        .example-animate-container > div {\n          padding:10px;\n        }\n\n        .view-example.ng-enter, .view-example.ng-leave {\n          -webkit-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 1.5s;\n          -moz-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 1.5s;\n          -o-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 1.5s;\n          transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 1.5s;\n\n          display:block;\n          width:100%;\n          border-left:1px solid black;\n\n          position:absolute;\n          top:0;\n          left:0;\n          right:0;\n          bottom:0;\n          padding:10px;\n        }\n\n        .example-animate-container {\n          position:relative;\n          height:100px;\n        }\n\n        .view-example.ng-enter {\n          left:100%;\n        }\n        .view-example.ng-enter.ng-enter-active {\n          left:0;\n        }\n\n        .view-example.ng-leave { }\n        .view-example.ng-leave.ng-leave-active {\n          left:-100%;\n        }\n      </file>\n\n      <file name=\"script.js\">\n        angular.module('ngViewExample', ['ngRoute', 'ngAnimate'], function($routeProvider, $locationProvider) {\n          $routeProvider.when('/Book/:bookId', {\n            templateUrl: 'book.html',\n            controller: BookCntl,\n            controllerAs: 'book'\n          });\n          $routeProvider.when('/Book/:bookId/ch/:chapterId', {\n            templateUrl: 'chapter.html',\n            controller: ChapterCntl,\n            controllerAs: 'chapter'\n          });\n\n          // configure html5 to get links working on jsfiddle\n          $locationProvider.html5Mode(true);\n        });\n\n        function MainCntl($route, $routeParams, $location) {\n          this.$route = $route;\n          this.$location = $location;\n          this.$routeParams = $routeParams;\n        }\n\n        function BookCntl($routeParams) {\n          this.name = \"BookCntl\";\n          this.params = $routeParams;\n        }\n\n        function ChapterCntl($routeParams) {\n          this.name = \"ChapterCntl\";\n          this.params = $routeParams;\n        }\n      </file>\n\n      <file name=\"scenario.js\">\n        it('should load and compile correct template', function() {\n          element('a:contains(\"Moby: Ch1\")').click();\n          var content = element('.doc-example-live [ng-view]').text();\n          expect(content).toMatch(/controller\\: ChapterCntl/);\n          expect(content).toMatch(/Book Id\\: Moby/);\n          expect(content).toMatch(/Chapter Id\\: 1/);\n\n          element('a:contains(\"Scarlet\")').click();\n          content = element('.doc-example-live [ng-view]').text();\n          expect(content).toMatch(/controller\\: BookCntl/);\n          expect(content).toMatch(/Book Id\\: Scarlet/);\n        });\n      </file>\n    </example>\n */\n\n\n/**\n * @ngdoc event\n * @name ngRoute.directive:ngView#$viewContentLoaded\n * @eventOf ngRoute.directive:ngView\n * @eventType emit on the current ngView scope\n * @description\n * Emitted every time the ngView content is reloaded.\n */\nngViewFactory.$inject = ['$route', '$anchorScroll', '$compile', '$controller', '$animate'];\nfunction ngViewFactory(   $route,   $anchorScroll,   $compile,   $controller,   $animate) {\n  return {\n    restrict: 'ECA',\n    terminal: true,\n    priority: 1000,\n    transclude: 'element',\n    compile: function(element, attr, linker) {\n      return function(scope, $element, attr) {\n        var currentScope,\n            currentElement,\n            onloadExp = attr.onload || '';\n\n        scope.$on('$routeChangeSuccess', update);\n        update();\n\n        function cleanupLastView() {\n          if (currentScope) {\n            currentScope.$destroy();\n            currentScope = null;\n          }\n          if(currentElement) {\n            $animate.leave(currentElement);\n            currentElement = null;\n          }\n        }\n\n        function update() {\n          var locals = $route.current && $route.current.locals,\n              template = locals && locals.$template;\n\n          if (template) {\n            var newScope = scope.$new();\n            linker(newScope, function(clone) {\n              cleanupLastView();\n\n              clone.html(template);\n              $animate.enter(clone, null, $element);\n\n              var link = $compile(clone.contents()),\n                  current = $route.current;\n\n              currentScope = current.scope = newScope;\n              currentElement = clone;\n\n              if (current.controller) {\n                locals.$scope = currentScope;\n                var controller = $controller(current.controller, locals);\n                if (current.controllerAs) {\n                  currentScope[current.controllerAs] = controller;\n                }\n                clone.data('$ngControllerController', controller);\n                clone.contents().data('$ngControllerController', controller);\n              }\n\n              link(currentScope);\n              currentScope.$emit('$viewContentLoaded');\n              currentScope.$eval(onloadExp);\n\n              // $anchorScroll might listen on event...\n              $anchorScroll();\n            });\n          } else {\n            cleanupLastView();\n          }\n        }\n      }\n    }\n  };\n}\n\n\n})(window, window.angular);\n\ndefine(\"ngRoute\", [\"angular\"], (function (global) {\n    return function () {\n        var ret, fn;\n        return ret || global.ngRoute;\n    };\n}(this)));\n","\ndefine('RecentBlogPosts',['angular'], function(angular, ngResource) {\n    return function ($scope, blogData) {\n        \n        $scope.posts = [];\n\n        blogData.getRecent(5)\n            .success(function(data, status, headers, config) {\n                $scope.posts = _(data.rows).map(function(row) {\n                    return row.value;\n                });\n            })\n            .error(function(data, status, headers, config) {\n                $scope.status = status;\n            });    \n    }\n});","\ndefine('BlogAddPostController',[], function() {\n    return function ($scope, blogData, $sce) {\n\n        var self       = this;\n        var isPosting  = false;\n        \n        $scope.$on('setBlogPost', function(ev, post) {\n            $scope.post = post;\n        });\n\n        $scope.savePost = function(scope) {\n            if (!scope.addForm.$valid) { \n                scope.status = \"Form Invalid\"; \n                return; \n            }\n\n            if (isPosting === true) { return; } else { isPosting = true; } \n\n            scope.post.date = new Date().getTime();\n            scope.status = 'Submitting form ...';\n            \n            blogData.add(scope.post)\n                .success(function(data, status, headers, config) {\n                    scope.resetPost();\n                    scope.status = 'Post Successful!';\n                    isPosting = false;\n                })\n                .error(function(data, status, headers, config) {\n                    scope.status = status + ' - ' + data.error + \":\" + data.reason;\n                }); \n        };\n\n        $scope.resetPost = function() {\n            $scope.post = {};\n            $scope.post.date = new Date().getTime();\n            $scope.post.type = \"blogpost\";\n            $scope.status = '';\n        };\n\n        $scope.resetPost();\n    }\n});\n","\ndefine('BlogDeletePostController',['angular'], function(angular) {\n    return function($scope, blogData) {\n        $scope.posts = [];\n\n        blogData.getAllPosts()\n            .success(function(data, status, headers, config) {\n                $scope.posts = _(data.rows).map(function(row) {\n                    return row.value;\n                });\n            })\n            .error(function(data, status, headers, config) {\n                $scope.status = status;\n            });\n    }\n});","\ndefine('BlogAdminController',[], function() {\n    return function($scope) {\n        $scope.setPost = function(post) {\n            $scope.$broadcast('setBlogPost', post);\n        };\n    }\n});","\ndefine('AdminController',['angular'], function(angular) {\n    return function($scope, blogData) {\n        $scope.posts = [];\n\n        blogData.getAll()\n            .success(function(data, status, headers, config) {\n                $scope.posts = _(data.rows).map(function(row) {\n                    return row.value;\n                });\n            })\n            .error(function(data, status, headers, config) {\n                $scope.status = status;\n            });\n    }\n});","\n;\ndefine(\"CreationsController\", function(){});\n","\ndefine('ContactController',[], function() {\n    return function ($scope) {\n        $scope.hello = 'hi';\n    }\n});","\ndefine('Controllers',[\n    'RecentBlogPosts',\n    'BlogAddPostController',\n    'BlogDeletePostController',\n    'BlogAdminController',\n    'AdminController',\n    'CreationsController',\n    'ContactController'], \n\n    function(\n        RecentBlogPosts,\n        BlogAddPostController,\n        BlogDeletePostController,\n        BlogAdminController,\n        AdminController,\n        CreationsController,\n        ContactController) {\n        \n        return {\n            RecentBlogPosts: RecentBlogPosts,\n            BlogAddPostController: BlogAddPostController,\n            BlogDeletePostController: BlogDeletePostController,\n            BlogAdminController: BlogAdminController,\n            AdminController: AdminController,\n            CreationsController: CreationsController,\n            ContactController: ContactController\n        };\n});","\n//     Underscore.js 1.5.2\n//     http://underscorejs.org\n//     (c) 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\n//     Underscore may be freely distributed under the MIT license.\n(function(){var n=this,t=n._,r={},e=Array.prototype,u=Object.prototype,i=Function.prototype,a=e.push,o=e.slice,c=e.concat,l=u.toString,f=u.hasOwnProperty,s=e.forEach,p=e.map,h=e.reduce,v=e.reduceRight,g=e.filter,d=e.every,m=e.some,y=e.indexOf,b=e.lastIndexOf,x=Array.isArray,w=Object.keys,_=i.bind,j=function(n){return n instanceof j?n:this instanceof j?(this._wrapped=n,void 0):new j(n)};\"undefined\"!=typeof exports?(\"undefined\"!=typeof module&&module.exports&&(exports=module.exports=j),exports._=j):n._=j,j.VERSION=\"1.5.2\";var A=j.each=j.forEach=function(n,t,e){if(null!=n)if(s&&n.forEach===s)n.forEach(t,e);else if(n.length===+n.length){for(var u=0,i=n.length;i>u;u++)if(t.call(e,n[u],u,n)===r)return}else for(var a=j.keys(n),u=0,i=a.length;i>u;u++)if(t.call(e,n[a[u]],a[u],n)===r)return};j.map=j.collect=function(n,t,r){var e=[];return null==n?e:p&&n.map===p?n.map(t,r):(A(n,function(n,u,i){e.push(t.call(r,n,u,i))}),e)};var E=\"Reduce of empty array with no initial value\";j.reduce=j.foldl=j.inject=function(n,t,r,e){var u=arguments.length>2;if(null==n&&(n=[]),h&&n.reduce===h)return e&&(t=j.bind(t,e)),u?n.reduce(t,r):n.reduce(t);if(A(n,function(n,i,a){u?r=t.call(e,r,n,i,a):(r=n,u=!0)}),!u)throw new TypeError(E);return r},j.reduceRight=j.foldr=function(n,t,r,e){var u=arguments.length>2;if(null==n&&(n=[]),v&&n.reduceRight===v)return e&&(t=j.bind(t,e)),u?n.reduceRight(t,r):n.reduceRight(t);var i=n.length;if(i!==+i){var a=j.keys(n);i=a.length}if(A(n,function(o,c,l){c=a?a[--i]:--i,u?r=t.call(e,r,n[c],c,l):(r=n[c],u=!0)}),!u)throw new TypeError(E);return r},j.find=j.detect=function(n,t,r){var e;return O(n,function(n,u,i){return t.call(r,n,u,i)?(e=n,!0):void 0}),e},j.filter=j.select=function(n,t,r){var e=[];return null==n?e:g&&n.filter===g?n.filter(t,r):(A(n,function(n,u,i){t.call(r,n,u,i)&&e.push(n)}),e)},j.reject=function(n,t,r){return j.filter(n,function(n,e,u){return!t.call(r,n,e,u)},r)},j.every=j.all=function(n,t,e){t||(t=j.identity);var u=!0;return null==n?u:d&&n.every===d?n.every(t,e):(A(n,function(n,i,a){return(u=u&&t.call(e,n,i,a))?void 0:r}),!!u)};var O=j.some=j.any=function(n,t,e){t||(t=j.identity);var u=!1;return null==n?u:m&&n.some===m?n.some(t,e):(A(n,function(n,i,a){return u||(u=t.call(e,n,i,a))?r:void 0}),!!u)};j.contains=j.include=function(n,t){return null==n?!1:y&&n.indexOf===y?n.indexOf(t)!=-1:O(n,function(n){return n===t})},j.invoke=function(n,t){var r=o.call(arguments,2),e=j.isFunction(t);return j.map(n,function(n){return(e?t:n[t]).apply(n,r)})},j.pluck=function(n,t){return j.map(n,function(n){return n[t]})},j.where=function(n,t,r){return j.isEmpty(t)?r?void 0:[]:j[r?\"find\":\"filter\"](n,function(n){for(var r in t)if(t[r]!==n[r])return!1;return!0})},j.findWhere=function(n,t){return j.where(n,t,!0)},j.max=function(n,t,r){if(!t&&j.isArray(n)&&n[0]===+n[0]&&n.length<65535)return Math.max.apply(Math,n);if(!t&&j.isEmpty(n))return-1/0;var e={computed:-1/0,value:-1/0};return A(n,function(n,u,i){var a=t?t.call(r,n,u,i):n;a>e.computed&&(e={value:n,computed:a})}),e.value},j.min=function(n,t,r){if(!t&&j.isArray(n)&&n[0]===+n[0]&&n.length<65535)return Math.min.apply(Math,n);if(!t&&j.isEmpty(n))return 1/0;var e={computed:1/0,value:1/0};return A(n,function(n,u,i){var a=t?t.call(r,n,u,i):n;a<e.computed&&(e={value:n,computed:a})}),e.value},j.shuffle=function(n){var t,r=0,e=[];return A(n,function(n){t=j.random(r++),e[r-1]=e[t],e[t]=n}),e},j.sample=function(n,t,r){return arguments.length<2||r?n[j.random(n.length-1)]:j.shuffle(n).slice(0,Math.max(0,t))};var k=function(n){return j.isFunction(n)?n:function(t){return t[n]}};j.sortBy=function(n,t,r){var e=k(t);return j.pluck(j.map(n,function(n,t,u){return{value:n,index:t,criteria:e.call(r,n,t,u)}}).sort(function(n,t){var r=n.criteria,e=t.criteria;if(r!==e){if(r>e||r===void 0)return 1;if(e>r||e===void 0)return-1}return n.index-t.index}),\"value\")};var F=function(n){return function(t,r,e){var u={},i=null==r?j.identity:k(r);return A(t,function(r,a){var o=i.call(e,r,a,t);n(u,o,r)}),u}};j.groupBy=F(function(n,t,r){(j.has(n,t)?n[t]:n[t]=[]).push(r)}),j.indexBy=F(function(n,t,r){n[t]=r}),j.countBy=F(function(n,t){j.has(n,t)?n[t]++:n[t]=1}),j.sortedIndex=function(n,t,r,e){r=null==r?j.identity:k(r);for(var u=r.call(e,t),i=0,a=n.length;a>i;){var o=i+a>>>1;r.call(e,n[o])<u?i=o+1:a=o}return i},j.toArray=function(n){return n?j.isArray(n)?o.call(n):n.length===+n.length?j.map(n,j.identity):j.values(n):[]},j.size=function(n){return null==n?0:n.length===+n.length?n.length:j.keys(n).length},j.first=j.head=j.take=function(n,t,r){return null==n?void 0:null==t||r?n[0]:o.call(n,0,t)},j.initial=function(n,t,r){return o.call(n,0,n.length-(null==t||r?1:t))},j.last=function(n,t,r){return null==n?void 0:null==t||r?n[n.length-1]:o.call(n,Math.max(n.length-t,0))},j.rest=j.tail=j.drop=function(n,t,r){return o.call(n,null==t||r?1:t)},j.compact=function(n){return j.filter(n,j.identity)};var M=function(n,t,r){return t&&j.every(n,j.isArray)?c.apply(r,n):(A(n,function(n){j.isArray(n)||j.isArguments(n)?t?a.apply(r,n):M(n,t,r):r.push(n)}),r)};j.flatten=function(n,t){return M(n,t,[])},j.without=function(n){return j.difference(n,o.call(arguments,1))},j.uniq=j.unique=function(n,t,r,e){j.isFunction(t)&&(e=r,r=t,t=!1);var u=r?j.map(n,r,e):n,i=[],a=[];return A(u,function(r,e){(t?e&&a[a.length-1]===r:j.contains(a,r))||(a.push(r),i.push(n[e]))}),i},j.union=function(){return j.uniq(j.flatten(arguments,!0))},j.intersection=function(n){var t=o.call(arguments,1);return j.filter(j.uniq(n),function(n){return j.every(t,function(t){return j.indexOf(t,n)>=0})})},j.difference=function(n){var t=c.apply(e,o.call(arguments,1));return j.filter(n,function(n){return!j.contains(t,n)})},j.zip=function(){for(var n=j.max(j.pluck(arguments,\"length\").concat(0)),t=new Array(n),r=0;n>r;r++)t[r]=j.pluck(arguments,\"\"+r);return t},j.object=function(n,t){if(null==n)return{};for(var r={},e=0,u=n.length;u>e;e++)t?r[n[e]]=t[e]:r[n[e][0]]=n[e][1];return r},j.indexOf=function(n,t,r){if(null==n)return-1;var e=0,u=n.length;if(r){if(\"number\"!=typeof r)return e=j.sortedIndex(n,t),n[e]===t?e:-1;e=0>r?Math.max(0,u+r):r}if(y&&n.indexOf===y)return n.indexOf(t,r);for(;u>e;e++)if(n[e]===t)return e;return-1},j.lastIndexOf=function(n,t,r){if(null==n)return-1;var e=null!=r;if(b&&n.lastIndexOf===b)return e?n.lastIndexOf(t,r):n.lastIndexOf(t);for(var u=e?r:n.length;u--;)if(n[u]===t)return u;return-1},j.range=function(n,t,r){arguments.length<=1&&(t=n||0,n=0),r=arguments[2]||1;for(var e=Math.max(Math.ceil((t-n)/r),0),u=0,i=new Array(e);e>u;)i[u++]=n,n+=r;return i};var R=function(){};j.bind=function(n,t){var r,e;if(_&&n.bind===_)return _.apply(n,o.call(arguments,1));if(!j.isFunction(n))throw new TypeError;return r=o.call(arguments,2),e=function(){if(!(this instanceof e))return n.apply(t,r.concat(o.call(arguments)));R.prototype=n.prototype;var u=new R;R.prototype=null;var i=n.apply(u,r.concat(o.call(arguments)));return Object(i)===i?i:u}},j.partial=function(n){var t=o.call(arguments,1);return function(){return n.apply(this,t.concat(o.call(arguments)))}},j.bindAll=function(n){var t=o.call(arguments,1);if(0===t.length)throw new Error(\"bindAll must be passed function names\");return A(t,function(t){n[t]=j.bind(n[t],n)}),n},j.memoize=function(n,t){var r={};return t||(t=j.identity),function(){var e=t.apply(this,arguments);return j.has(r,e)?r[e]:r[e]=n.apply(this,arguments)}},j.delay=function(n,t){var r=o.call(arguments,2);return setTimeout(function(){return n.apply(null,r)},t)},j.defer=function(n){return j.delay.apply(j,[n,1].concat(o.call(arguments,1)))},j.throttle=function(n,t,r){var e,u,i,a=null,o=0;r||(r={});var c=function(){o=r.leading===!1?0:new Date,a=null,i=n.apply(e,u)};return function(){var l=new Date;o||r.leading!==!1||(o=l);var f=t-(l-o);return e=this,u=arguments,0>=f?(clearTimeout(a),a=null,o=l,i=n.apply(e,u)):a||r.trailing===!1||(a=setTimeout(c,f)),i}},j.debounce=function(n,t,r){var e,u,i,a,o;return function(){i=this,u=arguments,a=new Date;var c=function(){var l=new Date-a;t>l?e=setTimeout(c,t-l):(e=null,r||(o=n.apply(i,u)))},l=r&&!e;return e||(e=setTimeout(c,t)),l&&(o=n.apply(i,u)),o}},j.once=function(n){var t,r=!1;return function(){return r?t:(r=!0,t=n.apply(this,arguments),n=null,t)}},j.wrap=function(n,t){return function(){var r=[n];return a.apply(r,arguments),t.apply(this,r)}},j.compose=function(){var n=arguments;return function(){for(var t=arguments,r=n.length-1;r>=0;r--)t=[n[r].apply(this,t)];return t[0]}},j.after=function(n,t){return function(){return--n<1?t.apply(this,arguments):void 0}},j.keys=w||function(n){if(n!==Object(n))throw new TypeError(\"Invalid object\");var t=[];for(var r in n)j.has(n,r)&&t.push(r);return t},j.values=function(n){for(var t=j.keys(n),r=t.length,e=new Array(r),u=0;r>u;u++)e[u]=n[t[u]];return e},j.pairs=function(n){for(var t=j.keys(n),r=t.length,e=new Array(r),u=0;r>u;u++)e[u]=[t[u],n[t[u]]];return e},j.invert=function(n){for(var t={},r=j.keys(n),e=0,u=r.length;u>e;e++)t[n[r[e]]]=r[e];return t},j.functions=j.methods=function(n){var t=[];for(var r in n)j.isFunction(n[r])&&t.push(r);return t.sort()},j.extend=function(n){return A(o.call(arguments,1),function(t){if(t)for(var r in t)n[r]=t[r]}),n},j.pick=function(n){var t={},r=c.apply(e,o.call(arguments,1));return A(r,function(r){r in n&&(t[r]=n[r])}),t},j.omit=function(n){var t={},r=c.apply(e,o.call(arguments,1));for(var u in n)j.contains(r,u)||(t[u]=n[u]);return t},j.defaults=function(n){return A(o.call(arguments,1),function(t){if(t)for(var r in t)n[r]===void 0&&(n[r]=t[r])}),n},j.clone=function(n){return j.isObject(n)?j.isArray(n)?n.slice():j.extend({},n):n},j.tap=function(n,t){return t(n),n};var S=function(n,t,r,e){if(n===t)return 0!==n||1/n==1/t;if(null==n||null==t)return n===t;n instanceof j&&(n=n._wrapped),t instanceof j&&(t=t._wrapped);var u=l.call(n);if(u!=l.call(t))return!1;switch(u){case\"[object String]\":return n==String(t);case\"[object Number]\":return n!=+n?t!=+t:0==n?1/n==1/t:n==+t;case\"[object Date]\":case\"[object Boolean]\":return+n==+t;case\"[object RegExp]\":return n.source==t.source&&n.global==t.global&&n.multiline==t.multiline&&n.ignoreCase==t.ignoreCase}if(\"object\"!=typeof n||\"object\"!=typeof t)return!1;for(var i=r.length;i--;)if(r[i]==n)return e[i]==t;var a=n.constructor,o=t.constructor;if(a!==o&&!(j.isFunction(a)&&a instanceof a&&j.isFunction(o)&&o instanceof o))return!1;r.push(n),e.push(t);var c=0,f=!0;if(\"[object Array]\"==u){if(c=n.length,f=c==t.length)for(;c--&&(f=S(n[c],t[c],r,e)););}else{for(var s in n)if(j.has(n,s)&&(c++,!(f=j.has(t,s)&&S(n[s],t[s],r,e))))break;if(f){for(s in t)if(j.has(t,s)&&!c--)break;f=!c}}return r.pop(),e.pop(),f};j.isEqual=function(n,t){return S(n,t,[],[])},j.isEmpty=function(n){if(null==n)return!0;if(j.isArray(n)||j.isString(n))return 0===n.length;for(var t in n)if(j.has(n,t))return!1;return!0},j.isElement=function(n){return!(!n||1!==n.nodeType)},j.isArray=x||function(n){return\"[object Array]\"==l.call(n)},j.isObject=function(n){return n===Object(n)},A([\"Arguments\",\"Function\",\"String\",\"Number\",\"Date\",\"RegExp\"],function(n){j[\"is\"+n]=function(t){return l.call(t)==\"[object \"+n+\"]\"}}),j.isArguments(arguments)||(j.isArguments=function(n){return!(!n||!j.has(n,\"callee\"))}),\"function\"!=typeof/./&&(j.isFunction=function(n){return\"function\"==typeof n}),j.isFinite=function(n){return isFinite(n)&&!isNaN(parseFloat(n))},j.isNaN=function(n){return j.isNumber(n)&&n!=+n},j.isBoolean=function(n){return n===!0||n===!1||\"[object Boolean]\"==l.call(n)},j.isNull=function(n){return null===n},j.isUndefined=function(n){return n===void 0},j.has=function(n,t){return f.call(n,t)},j.noConflict=function(){return n._=t,this},j.identity=function(n){return n},j.times=function(n,t,r){for(var e=Array(Math.max(0,n)),u=0;n>u;u++)e[u]=t.call(r,u);return e},j.random=function(n,t){return null==t&&(t=n,n=0),n+Math.floor(Math.random()*(t-n+1))};var I={escape:{\"&\":\"&amp;\",\"<\":\"&lt;\",\">\":\"&gt;\",'\"':\"&quot;\",\"'\":\"&#x27;\"}};I.unescape=j.invert(I.escape);var T={escape:new RegExp(\"[\"+j.keys(I.escape).join(\"\")+\"]\",\"g\"),unescape:new RegExp(\"(\"+j.keys(I.unescape).join(\"|\")+\")\",\"g\")};j.each([\"escape\",\"unescape\"],function(n){j[n]=function(t){return null==t?\"\":(\"\"+t).replace(T[n],function(t){return I[n][t]})}}),j.result=function(n,t){if(null==n)return void 0;var r=n[t];return j.isFunction(r)?r.call(n):r},j.mixin=function(n){A(j.functions(n),function(t){var r=j[t]=n[t];j.prototype[t]=function(){var n=[this._wrapped];return a.apply(n,arguments),z.call(this,r.apply(j,n))}})};var N=0;j.uniqueId=function(n){var t=++N+\"\";return n?n+t:t},j.templateSettings={evaluate:/<%([\\s\\S]+?)%>/g,interpolate:/<%=([\\s\\S]+?)%>/g,escape:/<%-([\\s\\S]+?)%>/g};var q=/(.)^/,B={\"'\":\"'\",\"\\\\\":\"\\\\\",\"\\r\":\"r\",\"\\n\":\"n\",\"   \":\"t\",\"\\u2028\":\"u2028\",\"\\u2029\":\"u2029\"},D=/\\\\|'|\\r|\\n|\\t|\\u2028|\\u2029/g;j.template=function(n,t,r){var e;r=j.defaults({},r,j.templateSettings);var u=new RegExp([(r.escape||q).source,(r.interpolate||q).source,(r.evaluate||q).source].join(\"|\")+\"|$\",\"g\"),i=0,a=\"__p+='\";n.replace(u,function(t,r,e,u,o){return a+=n.slice(i,o).replace(D,function(n){return\"\\\\\"+B[n]}),r&&(a+=\"'+\\n((__t=(\"+r+\"))==null?'':_.escape(__t))+\\n'\"),e&&(a+=\"'+\\n((__t=(\"+e+\"))==null?'':__t)+\\n'\"),u&&(a+=\"';\\n\"+u+\"\\n__p+='\"),i=o+t.length,t}),a+=\"';\\n\",r.variable||(a=\"with(obj||{}){\\n\"+a+\"}\\n\"),a=\"var __t,__p='',__j=Array.prototype.join,\"+\"print=function(){__p+=__j.call(arguments,'');};\\n\"+a+\"return __p;\\n\";try{e=new Function(r.variable||\"obj\",\"_\",a)}catch(o){throw o.source=a,o}if(t)return e(t,j);var c=function(n){return e.call(this,n,j)};return c.source=\"function(\"+(r.variable||\"obj\")+\"){\\n\"+a+\"}\",c},j.chain=function(n){return j(n).chain()};var z=function(n){return this._chain?j(n).chain():n};j.mixin(j),A([\"pop\",\"push\",\"reverse\",\"shift\",\"sort\",\"splice\",\"unshift\"],function(n){var t=e[n];j.prototype[n]=function(){var r=this._wrapped;return t.apply(r,arguments),\"shift\"!=n&&\"splice\"!=n||0!==r.length||delete r[0],z.call(this,r)}}),A([\"concat\",\"join\",\"slice\"],function(n){var t=e[n];j.prototype[n]=function(){return z.call(this,t.apply(this._wrapped,arguments))}}),j.extend(j.prototype,{chain:function(){return this._chain=!0,this},value:function(){return this._wrapped}})}).call(this);\ndefine(\"underscore\", (function (global) {\n    return function () {\n        var ret, fn;\n        return ret || global._;\n    };\n}(this)));\n","\ndefine('DbTypeFactory',['underscore'], function() {\n    return function(type, host, dbName, designDoc) {\n\n        return function($http) {\n\n            var factory = {}\n            var dbLocation = host + \"/\" + dbName;\n            var docViewUri = dbLocation + \"/\" + designDoc + \"/_view/\" + type;\n        \n            factory.getRecent = function(num) {\n                var params = '?limit=' + num + '&descending=true';\n                return $http.get(docViewUri + params);\n            };\n\n            factory.getAll = function() {\n                var params = '?descending=true';\n                return $http.get(docViewUri + params);\n            };\n\n            factory.add = function(data) {\n                \n                return $http.post(dbLocation, data);\n            };\n\n            factory.delete = function(id) {\n                \n                console.log(id);\n            };\n\n            factory.getPage = function(pageNum, itemsPerPage) {\n                \n                var offset = (pageNum - 1) * itemsPerPage;\n                var params = '?skip=' + offset + \n                             '&limit='  + itemsPerPage + \n                             '&descending=true';\n\n                return $http.get(docViewUri + params);\n            }\n\n            return factory;\n        };\n    };\n});","\ndefine('MarkDownFilter',[], function() {\n    return function ($sce) {\n        var trusted = {};\n        return function(input) {\n            var converter = new Showdown.converter();\n            // trusted is a hack to get around current angular infinite \n            // digest loop problem.\n            // https://github.com/angular/angular.js/issues/3932\n            return trusted[input] || (trusted[input] = $sce.trustAsHtml(converter.makeHtml(input || ''))); \n        }\n    }\n});","\ndefine('BlogPostDateFilter',[], function() {\n    return function() {\n        return function(input) {\n            var date = new Date(input);\n            return date.toDateString() + ' - ' + date.toLocaleTimeString();\n        }\n    }\n});","\ndefine('RouteProvider',[\n    'RecentBlogPosts', \n    'BlogAdminController', \n    'BlogAddPostController', \n    'BlogDeletePostController', \n    'AdminController', \n    'CreationsController', \n    'ContactController'], \n\n    function(\n        RecentBlogPosts,\n        BlogAdminController,\n        BlogAddPostController,\n        BlogDeletePostController,\n        AdminController,\n        CreationsController,\n        ContactController) \n    {\n        return function($routeProvider) {\n            $routeProvider\n                .when('/blog', {\n                    templateUrl: 'partials/blog/recent-posts.html', \n                    controller: RecentBlogPosts\n                })\n                .when('/blog/admin', {\n                    templateUrl: 'partials/blog/admin.html',\n                    controller: BlogAdminController\n                })\n                .when ('/blog/add', {\n                    templateUrl: 'partials/blog/add-post.html',\n                    controller: BlogAddPostController\n                })\n                .when('/blog/delete', {\n                    templateUrl: 'partials/blog/delete-post.html',\n                    controller: BlogDeletePostController\n                })\n                .when('/admin', {\n                    templateUrl: 'partials/admin.html',\n                    controller: AdminController\n                })\n                .when('/creations', {\n                    templateUrl: 'partials/creations.html', \n                    controller: CreationsController\n                })\n                .when('/contact', {\n                    templateUrl: 'partials/contact.html', \n                    controller: ContactController\n                })\n                .otherwise({redirectTo: '/blog'});\n        };\n});","\n//\n// showdown.js -- A javascript port of Markdown.\n//\n// Copyright (c) 2007 John Fraser.\n//\n// Original Markdown Copyright (c) 2004-2005 John Gruber\n//   <http://daringfireball.net/projects/markdown/>\n//\n// Redistributable under a BSD-style open source license.\n// See license.txt for more information.\n//\n// The full source distribution is at:\n//\n//              A A L\n//              T C A\n//              T K B\n//\n//   <http://www.attacklab.net/>\n//\n\n//\n// Wherever possible, Showdown is a straight, line-by-line port\n// of the Perl version of Markdown.\n//\n// This is not a normal parser design; it's basically just a\n// series of string substitutions.  It's hard to read and\n// maintain this way,  but keeping Showdown close to the original\n// design makes it easier to port new features.\n//\n// More importantly, Showdown behaves like markdown.pl in most\n// edge cases.  So web applications can do client-side preview\n// in Javascript, and then build identical HTML on the server.\n//\n// This port needs the new RegExp functionality of ECMA 262,\n// 3rd Edition (i.e. Javascript 1.5).  Most modern web browsers\n// should do fine.  Even with the new regular expression features,\n// We do a lot of work to emulate Perl's regex functionality.\n// The tricky changes in this file mostly have the \"attacklab:\"\n// label.  Major or self-explanatory changes don't.\n//\n// Smart diff tools like Araxis Merge will be able to match up\n// this file with markdown.pl in a useful way.  A little tweaking\n// helps: in a copy of markdown.pl, replace \"#\" with \"//\" and\n// replace \"$text\" with \"text\".  Be sure to ignore whitespace\n// and line endings.\n//\n\n\n//\n// Showdown usage:\n//\n//   var text = \"Markdown *rocks*.\";\n//\n//   var converter = new Showdown.converter();\n//   var html = converter.makeHtml(text);\n//\n//   alert(html);\n//\n// Note: move the sample code to the bottom of this\n// file before uncommenting it.\n//\n\n\n//\n// Showdown namespace\n//\nvar Showdown = { extensions: {} };\n\n//\n// forEach\n//\nvar forEach = Showdown.forEach = function(obj, callback) {\n    if (typeof obj.forEach === 'function') {\n        obj.forEach(callback);\n    } else {\n        var i, len = obj.length;\n        for (i = 0; i < len; i++) {\n            callback(obj[i], i, obj);\n        }\n    }\n};\n\n//\n// Standard extension naming\n//\nvar stdExtName = function(s) {\n    return s.replace(/[_-]||\\s/g, '').toLowerCase();\n};\n\n//\n// converter\n//\n// Wraps all \"globals\" so that the only thing\n// exposed is makeHtml().\n//\nShowdown.converter = function(converter_options) {\n\n//\n// Globals:\n//\n\n// Global hashes, used by various utility routines\nvar g_urls;\nvar g_titles;\nvar g_html_blocks;\n\n// Used to track when we're inside an ordered or unordered list\n// (see _ProcessListItems() for details):\nvar g_list_level = 0;\n\n// Global extensions\nvar g_lang_extensions = [];\nvar g_output_modifiers = [];\n\n\n//\n// Automatic Extension Loading (node only):\n//\n\nif (typeof module !== 'undefind' && typeof exports !== 'undefined' && typeof require !== 'undefind') {\n    var fs = require('fs');\n\n    if (fs) {\n        // Search extensions folder\n        var extensions = fs.readdirSync((__dirname || '.')+'/extensions').filter(function(file){\n            return ~file.indexOf('.js');\n        }).map(function(file){\n            return file.replace(/\\.js$/, '');\n        });\n        // Load extensions into Showdown namespace\n        Showdown.forEach(extensions, function(ext){\n            var name = stdExtName(ext);\n            Showdown.extensions[name] = require('./extensions/' + ext);\n        });\n    }\n}\n\nthis.makeHtml = function(text) {\n//\n// Main function. The order in which other subs are called here is\n// essential. Link and image substitutions need to happen before\n// _EscapeSpecialCharsWithinTagAttributes(), so that any *'s or _'s in the <a>\n// and <img> tags get encoded.\n//\n\n    // Clear the global hashes. If we don't clear these, you get conflicts\n    // from other articles when generating a page which contains more than\n    // one article (e.g. an index page that shows the N most recent\n    // articles):\n    g_urls = {};\n    g_titles = {};\n    g_html_blocks = [];\n\n    // attacklab: Replace ~ with ~T\n    // This lets us use tilde as an escape char to avoid md5 hashes\n    // The choice of character is arbitray; anything that isn't\n    // magic in Markdown will work.\n    text = text.replace(/~/g,\"~T\");\n\n    // attacklab: Replace $ with ~D\n    // RegExp interprets $ as a special character\n    // when it's in a replacement string\n    text = text.replace(/\\$/g,\"~D\");\n\n    // Standardize line endings\n    text = text.replace(/\\r\\n/g,\"\\n\"); // DOS to Unix\n    text = text.replace(/\\r/g,\"\\n\"); // Mac to Unix\n\n    // Make sure text begins and ends with a couple of newlines:\n    text = \"\\n\\n\" + text + \"\\n\\n\";\n\n    // Convert all tabs to spaces.\n    text = _Detab(text);\n\n    // Strip any lines consisting only of spaces and tabs.\n    // This makes subsequent regexen easier to write, because we can\n    // match consecutive blank lines with /\\n+/ instead of something\n    // contorted like /[ \\t]*\\n+/ .\n    text = text.replace(/^[ \\t]+$/mg,\"\");\n\n    // Run language extensions\n    Showdown.forEach(g_lang_extensions, function(x){\n        text = _ExecuteExtension(x, text);\n    });\n\n    // Handle github codeblocks prior to running HashHTML so that\n    // HTML contained within the codeblock gets escaped propertly\n    text = _DoGithubCodeBlocks(text);\n\n    // Turn block-level HTML blocks into hash entries\n    text = _HashHTMLBlocks(text);\n\n    // Strip link definitions, store in hashes.\n    text = _StripLinkDefinitions(text);\n\n    text = _RunBlockGamut(text);\n\n    text = _UnescapeSpecialChars(text);\n\n    // attacklab: Restore dollar signs\n    text = text.replace(/~D/g,\"$$\");\n\n    // attacklab: Restore tildes\n    text = text.replace(/~T/g,\"~\");\n\n    // Run output modifiers\n    Showdown.forEach(g_output_modifiers, function(x){\n        text = _ExecuteExtension(x, text);\n    });\n\n    return text;\n};\n//\n// Options:\n//\n\n// Parse extensions options into separate arrays\nif (converter_options && converter_options.extensions) {\n\n  var self = this;\n\n    // Iterate over each plugin\n    Showdown.forEach(converter_options.extensions, function(plugin){\n\n        // Assume it's a bundled plugin if a string is given\n        if (typeof plugin === 'string') {\n            plugin = Showdown.extensions[stdExtName(plugin)];\n        }\n\n        if (typeof plugin === 'function') {\n            // Iterate over each extension within that plugin\n            Showdown.forEach(plugin(self), function(ext){\n                // Sort extensions by type\n                if (ext.type) {\n                    if (ext.type === 'language' || ext.type === 'lang') {\n                        g_lang_extensions.push(ext);\n                    } else if (ext.type === 'output' || ext.type === 'html') {\n                        g_output_modifiers.push(ext);\n                    }\n                } else {\n                    // Assume language extension\n                    g_output_modifiers.push(ext);\n                }\n            });\n        } else {\n            throw \"Extension '\" + plugin + \"' could not be loaded.  It was either not found or is not a valid extension.\";\n        }\n    });\n}\n\n\nvar _ExecuteExtension = function(ext, text) {\n    if (ext.regex) {\n        var re = new RegExp(ext.regex, 'g');\n        return text.replace(re, ext.replace);\n    } else if (ext.filter) {\n        return ext.filter(text);\n    }\n};\n\nvar _StripLinkDefinitions = function(text) {\n//\n// Strips link definitions from text, stores the URLs and titles in\n// hash references.\n//\n\n    // Link defs are in the form: ^[id]: url \"optional title\"\n\n    /*\n        var text = text.replace(/\n                ^[ ]{0,3}\\[(.+)\\]:  // id = $1  attacklab: g_tab_width - 1\n                  [ \\t]*\n                  \\n?               // maybe *one* newline\n                  [ \\t]*\n                <?(\\S+?)>?          // url = $2\n                  [ \\t]*\n                  \\n?               // maybe one newline\n                  [ \\t]*\n                (?:\n                  (\\n*)             // any lines skipped = $3 attacklab: lookbehind removed\n                  [\"(]\n                  (.+?)             // title = $4\n                  [\")]\n                  [ \\t]*\n                )?                  // title is optional\n                (?:\\n+|$)\n              /gm,\n              function(){...});\n    */\n\n    // attacklab: sentinel workarounds for lack of \\A and \\Z, safari\\khtml bug\n    text += \"~0\";\n\n    text = text.replace(/^[ ]{0,3}\\[(.+)\\]:[ \\t]*\\n?[ \\t]*<?(\\S+?)>?[ \\t]*\\n?[ \\t]*(?:(\\n*)[\"(](.+?)[\")][ \\t]*)?(?:\\n+|(?=~0))/gm,\n        function (wholeMatch,m1,m2,m3,m4) {\n            m1 = m1.toLowerCase();\n            g_urls[m1] = _EncodeAmpsAndAngles(m2);  // Link IDs are case-insensitive\n            if (m3) {\n                // Oops, found blank lines, so it's not a title.\n                // Put back the parenthetical statement we stole.\n                return m3+m4;\n            } else if (m4) {\n                g_titles[m1] = m4.replace(/\"/g,\"&quot;\");\n            }\n\n            // Completely remove the definition from the text\n            return \"\";\n        }\n    );\n\n    // attacklab: strip sentinel\n    text = text.replace(/~0/,\"\");\n\n    return text;\n}\n\n\nvar _HashHTMLBlocks = function(text) {\n    // attacklab: Double up blank lines to reduce lookaround\n    text = text.replace(/\\n/g,\"\\n\\n\");\n\n    // Hashify HTML blocks:\n    // We only want to do this for block-level HTML tags, such as headers,\n    // lists, and tables. That's because we still want to wrap <p>s around\n    // \"paragraphs\" that are wrapped in non-block-level tags, such as anchors,\n    // phrase emphasis, and spans. The list of tags we're looking for is\n    // hard-coded:\n    var block_tags_a = \"p|div|h[1-6]|blockquote|pre|table|dl|ol|ul|script|noscript|form|fieldset|iframe|math|ins|del|style|section|header|footer|nav|article|aside\";\n    var block_tags_b = \"p|div|h[1-6]|blockquote|pre|table|dl|ol|ul|script|noscript|form|fieldset|iframe|math|style|section|header|footer|nav|article|aside\";\n\n    // First, look for nested blocks, e.g.:\n    //   <div>\n    //     <div>\n    //     tags for inner block must be indented.\n    //     </div>\n    //   </div>\n    //\n    // The outermost tags must start at the left margin for this to match, and\n    // the inner nested divs must be indented.\n    // We need to do this before the next, more liberal match, because the next\n    // match will start at the first `<div>` and stop at the first `</div>`.\n\n    // attacklab: This regex can be expensive when it fails.\n    /*\n        var text = text.replace(/\n        (                       // save in $1\n            ^                   // start of line  (with /m)\n            <($block_tags_a)    // start tag = $2\n            \\b                  // word break\n                                // attacklab: hack around khtml/pcre bug...\n            [^\\r]*?\\n           // any number of lines, minimally matching\n            </\\2>               // the matching end tag\n            [ \\t]*              // trailing spaces/tabs\n            (?=\\n+)             // followed by a newline\n        )                       // attacklab: there are sentinel newlines at end of document\n        /gm,function(){...}};\n    */\n    text = text.replace(/^(<(p|div|h[1-6]|blockquote|pre|table|dl|ol|ul|script|noscript|form|fieldset|iframe|math|ins|del)\\b[^\\r]*?\\n<\\/\\2>[ \\t]*(?=\\n+))/gm,hashElement);\n\n    //\n    // Now match more liberally, simply from `\\n<tag>` to `</tag>\\n`\n    //\n\n    /*\n        var text = text.replace(/\n        (                       // save in $1\n            ^                   // start of line  (with /m)\n            <($block_tags_b)    // start tag = $2\n            \\b                  // word break\n                                // attacklab: hack around khtml/pcre bug...\n            [^\\r]*?             // any number of lines, minimally matching\n            </\\2>               // the matching end tag\n            [ \\t]*              // trailing spaces/tabs\n            (?=\\n+)             // followed by a newline\n        )                       // attacklab: there are sentinel newlines at end of document\n        /gm,function(){...}};\n    */\n    text = text.replace(/^(<(p|div|h[1-6]|blockquote|pre|table|dl|ol|ul|script|noscript|form|fieldset|iframe|math|style|section|header|footer|nav|article|aside)\\b[^\\r]*?<\\/\\2>[ \\t]*(?=\\n+)\\n)/gm,hashElement);\n\n    // Special case just for <hr />. It was easier to make a special case than\n    // to make the other regex more complicated.\n\n    /*\n        text = text.replace(/\n        (                       // save in $1\n            \\n\\n                // Starting after a blank line\n            [ ]{0,3}\n            (<(hr)              // start tag = $2\n            \\b                  // word break\n            ([^<>])*?           //\n            \\/?>)               // the matching end tag\n            [ \\t]*\n            (?=\\n{2,})          // followed by a blank line\n        )\n        /g,hashElement);\n    */\n    text = text.replace(/(\\n[ ]{0,3}(<(hr)\\b([^<>])*?\\/?>)[ \\t]*(?=\\n{2,}))/g,hashElement);\n\n    // Special case for standalone HTML comments:\n\n    /*\n        text = text.replace(/\n        (                       // save in $1\n            \\n\\n                // Starting after a blank line\n            [ ]{0,3}            // attacklab: g_tab_width - 1\n            <!\n            (--[^\\r]*?--\\s*)+\n            >\n            [ \\t]*\n            (?=\\n{2,})          // followed by a blank line\n        )\n        /g,hashElement);\n    */\n    text = text.replace(/(\\n\\n[ ]{0,3}<!(--[^\\r]*?--\\s*)+>[ \\t]*(?=\\n{2,}))/g,hashElement);\n\n    // PHP and ASP-style processor instructions (<?...?> and <%...%>)\n\n    /*\n        text = text.replace(/\n        (?:\n            \\n\\n                // Starting after a blank line\n        )\n        (                       // save in $1\n            [ ]{0,3}            // attacklab: g_tab_width - 1\n            (?:\n                <([?%])         // $2\n                [^\\r]*?\n                \\2>\n            )\n            [ \\t]*\n            (?=\\n{2,})          // followed by a blank line\n        )\n        /g,hashElement);\n    */\n    text = text.replace(/(?:\\n\\n)([ ]{0,3}(?:<([?%])[^\\r]*?\\2>)[ \\t]*(?=\\n{2,}))/g,hashElement);\n\n    // attacklab: Undo double lines (see comment at top of this function)\n    text = text.replace(/\\n\\n/g,\"\\n\");\n    return text;\n}\n\nvar hashElement = function(wholeMatch,m1) {\n    var blockText = m1;\n\n    // Undo double lines\n    blockText = blockText.replace(/\\n\\n/g,\"\\n\");\n    blockText = blockText.replace(/^\\n/,\"\");\n\n    // strip trailing blank lines\n    blockText = blockText.replace(/\\n+$/g,\"\");\n\n    // Replace the element text with a marker (\"~KxK\" where x is its key)\n    blockText = \"\\n\\n~K\" + (g_html_blocks.push(blockText)-1) + \"K\\n\\n\";\n\n    return blockText;\n};\n\nvar _RunBlockGamut = function(text) {\n//\n// These are all the transformations that form block-level\n// tags like paragraphs, headers, and list items.\n//\n    text = _DoHeaders(text);\n\n    // Do Horizontal Rules:\n    var key = hashBlock(\"<hr />\");\n    text = text.replace(/^[ ]{0,2}([ ]?\\*[ ]?){3,}[ \\t]*$/gm,key);\n    text = text.replace(/^[ ]{0,2}([ ]?\\-[ ]?){3,}[ \\t]*$/gm,key);\n    text = text.replace(/^[ ]{0,2}([ ]?\\_[ ]?){3,}[ \\t]*$/gm,key);\n\n    text = _DoLists(text);\n    text = _DoCodeBlocks(text);\n    text = _DoBlockQuotes(text);\n\n    // We already ran _HashHTMLBlocks() before, in Markdown(), but that\n    // was to escape raw HTML in the original Markdown source. This time,\n    // we're escaping the markup we've just created, so that we don't wrap\n    // <p> tags around block-level tags.\n    text = _HashHTMLBlocks(text);\n    text = _FormParagraphs(text);\n\n    return text;\n};\n\n\nvar _RunSpanGamut = function(text) {\n//\n// These are all the transformations that occur *within* block-level\n// tags like paragraphs, headers, and list items.\n//\n\n    text = _DoCodeSpans(text);\n    text = _EscapeSpecialCharsWithinTagAttributes(text);\n    text = _EncodeBackslashEscapes(text);\n\n    // Process anchor and image tags. Images must come first,\n    // because ![foo][f] looks like an anchor.\n    text = _DoImages(text);\n    text = _DoAnchors(text);\n\n    // Make links out of things like `<http://example.com/>`\n    // Must come after _DoAnchors(), because you can use < and >\n    // delimiters in inline links like [this](<url>).\n    text = _DoAutoLinks(text);\n    text = _EncodeAmpsAndAngles(text);\n    text = _DoItalicsAndBold(text);\n\n    // Do hard breaks:\n    text = text.replace(/  +\\n/g,\" <br />\\n\");\n\n    return text;\n}\n\nvar _EscapeSpecialCharsWithinTagAttributes = function(text) {\n//\n// Within tags -- meaning between < and > -- encode [\\ ` * _] so they\n// don't conflict with their use in Markdown for code, italics and strong.\n//\n\n    // Build a regex to find HTML tags and comments.  See Friedl's\n    // \"Mastering Regular Expressions\", 2nd Ed., pp. 200-201.\n    var regex = /(<[a-z\\/!$](\"[^\"]*\"|'[^']*'|[^'\">])*>|<!(--.*?--\\s*)+>)/gi;\n\n    text = text.replace(regex, function(wholeMatch) {\n        var tag = wholeMatch.replace(/(.)<\\/?code>(?=.)/g,\"$1`\");\n        tag = escapeCharacters(tag,\"\\\\`*_\");\n        return tag;\n    });\n\n    return text;\n}\n\nvar _DoAnchors = function(text) {\n//\n// Turn Markdown link shortcuts into XHTML <a> tags.\n//\n    //\n    // First, handle reference-style links: [link text] [id]\n    //\n\n    /*\n        text = text.replace(/\n        (                           // wrap whole match in $1\n            \\[\n            (\n                (?:\n                    \\[[^\\]]*\\]      // allow brackets nested one level\n                    |\n                    [^\\[]           // or anything else\n                )*\n            )\n            \\]\n\n            [ ]?                    // one optional space\n            (?:\\n[ ]*)?             // one optional newline followed by spaces\n\n            \\[\n            (.*?)                   // id = $3\n            \\]\n        )()()()()                   // pad remaining backreferences\n        /g,_DoAnchors_callback);\n    */\n    text = text.replace(/(\\[((?:\\[[^\\]]*\\]|[^\\[\\]])*)\\][ ]?(?:\\n[ ]*)?\\[(.*?)\\])()()()()/g,writeAnchorTag);\n\n    //\n    // Next, inline-style links: [link text](url \"optional title\")\n    //\n\n    /*\n        text = text.replace(/\n            (                       // wrap whole match in $1\n                \\[\n                (\n                    (?:\n                        \\[[^\\]]*\\]  // allow brackets nested one level\n                    |\n                    [^\\[\\]]         // or anything else\n                )\n            )\n            \\]\n            \\(                      // literal paren\n            [ \\t]*\n            ()                      // no id, so leave $3 empty\n            <?(.*?)>?               // href = $4\n            [ \\t]*\n            (                       // $5\n                (['\"])              // quote char = $6\n                (.*?)               // Title = $7\n                \\6                  // matching quote\n                [ \\t]*              // ignore any spaces/tabs between closing quote and )\n            )?                      // title is optional\n            \\)\n        )\n        /g,writeAnchorTag);\n    */\n    text = text.replace(/(\\[((?:\\[[^\\]]*\\]|[^\\[\\]])*)\\]\\([ \\t]*()<?(.*?(?:\\(.*?\\).*?)?)>?[ \\t]*((['\"])(.*?)\\6[ \\t]*)?\\))/g,writeAnchorTag);\n\n    //\n    // Last, handle reference-style shortcuts: [link text]\n    // These must come last in case you've also got [link test][1]\n    // or [link test](/foo)\n    //\n\n    /*\n        text = text.replace(/\n        (                           // wrap whole match in $1\n            \\[\n            ([^\\[\\]]+)              // link text = $2; can't contain '[' or ']'\n            \\]\n        )()()()()()                 // pad rest of backreferences\n        /g, writeAnchorTag);\n    */\n    text = text.replace(/(\\[([^\\[\\]]+)\\])()()()()()/g, writeAnchorTag);\n\n    return text;\n}\n\nvar writeAnchorTag = function(wholeMatch,m1,m2,m3,m4,m5,m6,m7) {\n    if (m7 == undefined) m7 = \"\";\n    var whole_match = m1;\n    var link_text   = m2;\n    var link_id  = m3.toLowerCase();\n    var url     = m4;\n    var title   = m7;\n\n    if (url == \"\") {\n        if (link_id == \"\") {\n            // lower-case and turn embedded newlines into spaces\n            link_id = link_text.toLowerCase().replace(/ ?\\n/g,\" \");\n        }\n        url = \"#\"+link_id;\n\n        if (g_urls[link_id] != undefined) {\n            url = g_urls[link_id];\n            if (g_titles[link_id] != undefined) {\n                title = g_titles[link_id];\n            }\n        }\n        else {\n            if (whole_match.search(/\\(\\s*\\)$/m)>-1) {\n                // Special case for explicit empty url\n                url = \"\";\n            } else {\n                return whole_match;\n            }\n        }\n    }\n\n    url = escapeCharacters(url,\"*_\");\n    var result = \"<a href=\\\"\" + url + \"\\\"\";\n\n    if (title != \"\") {\n        title = title.replace(/\"/g,\"&quot;\");\n        title = escapeCharacters(title,\"*_\");\n        result +=  \" title=\\\"\" + title + \"\\\"\";\n    }\n\n    result += \">\" + link_text + \"</a>\";\n\n    return result;\n}\n\n\nvar _DoImages = function(text) {\n//\n// Turn Markdown image shortcuts into <img> tags.\n//\n\n    //\n    // First, handle reference-style labeled images: ![alt text][id]\n    //\n\n    /*\n        text = text.replace(/\n        (                       // wrap whole match in $1\n            !\\[\n            (.*?)               // alt text = $2\n            \\]\n\n            [ ]?                // one optional space\n            (?:\\n[ ]*)?         // one optional newline followed by spaces\n\n            \\[\n            (.*?)               // id = $3\n            \\]\n        )()()()()               // pad rest of backreferences\n        /g,writeImageTag);\n    */\n    text = text.replace(/(!\\[(.*?)\\][ ]?(?:\\n[ ]*)?\\[(.*?)\\])()()()()/g,writeImageTag);\n\n    //\n    // Next, handle inline images:  ![alt text](url \"optional title\")\n    // Don't forget: encode * and _\n\n    /*\n        text = text.replace(/\n        (                       // wrap whole match in $1\n            !\\[\n            (.*?)               // alt text = $2\n            \\]\n            \\s?                 // One optional whitespace character\n            \\(                  // literal paren\n            [ \\t]*\n            ()                  // no id, so leave $3 empty\n            <?(\\S+?)>?          // src url = $4\n            [ \\t]*\n            (                   // $5\n                (['\"])          // quote char = $6\n                (.*?)           // title = $7\n                \\6              // matching quote\n                [ \\t]*\n            )?                  // title is optional\n        \\)\n        )\n        /g,writeImageTag);\n    */\n    text = text.replace(/(!\\[(.*?)\\]\\s?\\([ \\t]*()<?(\\S+?)>?[ \\t]*((['\"])(.*?)\\6[ \\t]*)?\\))/g,writeImageTag);\n\n    return text;\n}\n\nvar writeImageTag = function(wholeMatch,m1,m2,m3,m4,m5,m6,m7) {\n    var whole_match = m1;\n    var alt_text   = m2;\n    var link_id  = m3.toLowerCase();\n    var url     = m4;\n    var title   = m7;\n\n    if (!title) title = \"\";\n\n    if (url == \"\") {\n        if (link_id == \"\") {\n            // lower-case and turn embedded newlines into spaces\n            link_id = alt_text.toLowerCase().replace(/ ?\\n/g,\" \");\n        }\n        url = \"#\"+link_id;\n\n        if (g_urls[link_id] != undefined) {\n            url = g_urls[link_id];\n            if (g_titles[link_id] != undefined) {\n                title = g_titles[link_id];\n            }\n        }\n        else {\n            return whole_match;\n        }\n    }\n\n    alt_text = alt_text.replace(/\"/g,\"&quot;\");\n    url = escapeCharacters(url,\"*_\");\n    var result = \"<img src=\\\"\" + url + \"\\\" alt=\\\"\" + alt_text + \"\\\"\";\n\n    // attacklab: Markdown.pl adds empty title attributes to images.\n    // Replicate this bug.\n\n    //if (title != \"\") {\n        title = title.replace(/\"/g,\"&quot;\");\n        title = escapeCharacters(title,\"*_\");\n        result +=  \" title=\\\"\" + title + \"\\\"\";\n    //}\n\n    result += \" />\";\n\n    return result;\n}\n\n\nvar _DoHeaders = function(text) {\n\n    // Setext-style headers:\n    //  Header 1\n    //  ========\n    //\n    //  Header 2\n    //  --------\n    //\n    text = text.replace(/^(.+)[ \\t]*\\n=+[ \\t]*\\n+/gm,\n        function(wholeMatch,m1){return hashBlock('<h1 id=\"' + headerId(m1) + '\">' + _RunSpanGamut(m1) + \"</h1>\");});\n\n    text = text.replace(/^(.+)[ \\t]*\\n-+[ \\t]*\\n+/gm,\n        function(matchFound,m1){return hashBlock('<h2 id=\"' + headerId(m1) + '\">' + _RunSpanGamut(m1) + \"</h2>\");});\n\n    // atx-style headers:\n    //  # Header 1\n    //  ## Header 2\n    //  ## Header 2 with closing hashes ##\n    //  ...\n    //  ###### Header 6\n    //\n\n    /*\n        text = text.replace(/\n            ^(\\#{1,6})              // $1 = string of #'s\n            [ \\t]*\n            (.+?)                   // $2 = Header text\n            [ \\t]*\n            \\#*                     // optional closing #'s (not counted)\n            \\n+\n        /gm, function() {...});\n    */\n\n    text = text.replace(/^(\\#{1,6})[ \\t]*(.+?)[ \\t]*\\#*\\n+/gm,\n        function(wholeMatch,m1,m2) {\n            var h_level = m1.length;\n            return hashBlock(\"<h\" + h_level + ' id=\"' + headerId(m2) + '\">' + _RunSpanGamut(m2) + \"</h\" + h_level + \">\");\n        });\n\n    function headerId(m) {\n        return m.replace(/[^\\w]/g, '').toLowerCase();\n    }\n    return text;\n}\n\n// This declaration keeps Dojo compressor from outputting garbage:\nvar _ProcessListItems;\n\nvar _DoLists = function(text) {\n//\n// Form HTML ordered (numbered) and unordered (bulleted) lists.\n//\n\n    // attacklab: add sentinel to hack around khtml/safari bug:\n    // http://bugs.webkit.org/show_bug.cgi?id=11231\n    text += \"~0\";\n\n    // Re-usable pattern to match any entirel ul or ol list:\n\n    /*\n        var whole_list = /\n        (                                   // $1 = whole list\n            (                               // $2\n                [ ]{0,3}                    // attacklab: g_tab_width - 1\n                ([*+-]|\\d+[.])              // $3 = first list item marker\n                [ \\t]+\n            )\n            [^\\r]+?\n            (                               // $4\n                ~0                          // sentinel for workaround; should be $\n            |\n                \\n{2,}\n                (?=\\S)\n                (?!                         // Negative lookahead for another list item marker\n                    [ \\t]*\n                    (?:[*+-]|\\d+[.])[ \\t]+\n                )\n            )\n        )/g\n    */\n    var whole_list = /^(([ ]{0,3}([*+-]|\\d+[.])[ \\t]+)[^\\r]+?(~0|\\n{2,}(?=\\S)(?![ \\t]*(?:[*+-]|\\d+[.])[ \\t]+)))/gm;\n\n    if (g_list_level) {\n        text = text.replace(whole_list,function(wholeMatch,m1,m2) {\n            var list = m1;\n            var list_type = (m2.search(/[*+-]/g)>-1) ? \"ul\" : \"ol\";\n\n            // Turn double returns into triple returns, so that we can make a\n            // paragraph for the last item in a list, if necessary:\n            list = list.replace(/\\n{2,}/g,\"\\n\\n\\n\");;\n            var result = _ProcessListItems(list);\n\n            // Trim any trailing whitespace, to put the closing `</$list_type>`\n            // up on the preceding line, to get it past the current stupid\n            // HTML block parser. This is a hack to work around the terrible\n            // hack that is the HTML block parser.\n            result = result.replace(/\\s+$/,\"\");\n            result = \"<\"+list_type+\">\" + result + \"</\"+list_type+\">\\n\";\n            return result;\n        });\n    } else {\n        whole_list = /(\\n\\n|^\\n?)(([ ]{0,3}([*+-]|\\d+[.])[ \\t]+)[^\\r]+?(~0|\\n{2,}(?=\\S)(?![ \\t]*(?:[*+-]|\\d+[.])[ \\t]+)))/g;\n        text = text.replace(whole_list,function(wholeMatch,m1,m2,m3) {\n            var runup = m1;\n            var list = m2;\n\n            var list_type = (m3.search(/[*+-]/g)>-1) ? \"ul\" : \"ol\";\n            // Turn double returns into triple returns, so that we can make a\n            // paragraph for the last item in a list, if necessary:\n            var list = list.replace(/\\n{2,}/g,\"\\n\\n\\n\");;\n            var result = _ProcessListItems(list);\n            result = runup + \"<\"+list_type+\">\\n\" + result + \"</\"+list_type+\">\\n\";\n            return result;\n        });\n    }\n\n    // attacklab: strip sentinel\n    text = text.replace(/~0/,\"\");\n\n    return text;\n}\n\n_ProcessListItems = function(list_str) {\n//\n//  Process the contents of a single ordered or unordered list, splitting it\n//  into individual list items.\n//\n    // The $g_list_level global keeps track of when we're inside a list.\n    // Each time we enter a list, we increment it; when we leave a list,\n    // we decrement. If it's zero, we're not in a list anymore.\n    //\n    // We do this because when we're not inside a list, we want to treat\n    // something like this:\n    //\n    //    I recommend upgrading to version\n    //    8. Oops, now this line is treated\n    //    as a sub-list.\n    //\n    // As a single paragraph, despite the fact that the second line starts\n    // with a digit-period-space sequence.\n    //\n    // Whereas when we're inside a list (or sub-list), that line will be\n    // treated as the start of a sub-list. What a kludge, huh? This is\n    // an aspect of Markdown's syntax that's hard to parse perfectly\n    // without resorting to mind-reading. Perhaps the solution is to\n    // change the syntax rules such that sub-lists must start with a\n    // starting cardinal number; e.g. \"1.\" or \"a.\".\n\n    g_list_level++;\n\n    // trim trailing blank lines:\n    list_str = list_str.replace(/\\n{2,}$/,\"\\n\");\n\n    // attacklab: add sentinel to emulate \\z\n    list_str += \"~0\";\n\n    /*\n        list_str = list_str.replace(/\n            (\\n)?                           // leading line = $1\n            (^[ \\t]*)                       // leading whitespace = $2\n            ([*+-]|\\d+[.]) [ \\t]+           // list marker = $3\n            ([^\\r]+?                        // list item text   = $4\n            (\\n{1,2}))\n            (?= \\n* (~0 | \\2 ([*+-]|\\d+[.]) [ \\t]+))\n        /gm, function(){...});\n    */\n    list_str = list_str.replace(/(\\n)?(^[ \\t]*)([*+-]|\\d+[.])[ \\t]+([^\\r]+?(\\n{1,2}))(?=\\n*(~0|\\2([*+-]|\\d+[.])[ \\t]+))/gm,\n        function(wholeMatch,m1,m2,m3,m4){\n            var item = m4;\n            var leading_line = m1;\n            var leading_space = m2;\n\n            if (leading_line || (item.search(/\\n{2,}/)>-1)) {\n                item = _RunBlockGamut(_Outdent(item));\n            }\n            else {\n                // Recursion for sub-lists:\n                item = _DoLists(_Outdent(item));\n                item = item.replace(/\\n$/,\"\"); // chomp(item)\n                item = _RunSpanGamut(item);\n            }\n\n            return  \"<li>\" + item + \"</li>\\n\";\n        }\n    );\n\n    // attacklab: strip sentinel\n    list_str = list_str.replace(/~0/g,\"\");\n\n    g_list_level--;\n    return list_str;\n}\n\n\nvar _DoCodeBlocks = function(text) {\n//\n//  Process Markdown `<pre><code>` blocks.\n//\n\n    /*\n        text = text.replace(text,\n            /(?:\\n\\n|^)\n            (                               // $1 = the code block -- one or more lines, starting with a space/tab\n                (?:\n                    (?:[ ]{4}|\\t)           // Lines must start with a tab or a tab-width of spaces - attacklab: g_tab_width\n                    .*\\n+\n                )+\n            )\n            (\\n*[ ]{0,3}[^ \\t\\n]|(?=~0))    // attacklab: g_tab_width\n        /g,function(){...});\n    */\n\n    // attacklab: sentinel workarounds for lack of \\A and \\Z, safari\\khtml bug\n    text += \"~0\";\n\n    text = text.replace(/(?:\\n\\n|^)((?:(?:[ ]{4}|\\t).*\\n+)+)(\\n*[ ]{0,3}[^ \\t\\n]|(?=~0))/g,\n        function(wholeMatch,m1,m2) {\n            var codeblock = m1;\n            var nextChar = m2;\n\n            codeblock = _EncodeCode( _Outdent(codeblock));\n            codeblock = _Detab(codeblock);\n            codeblock = codeblock.replace(/^\\n+/g,\"\"); // trim leading newlines\n            codeblock = codeblock.replace(/\\n+$/g,\"\"); // trim trailing whitespace\n\n            codeblock = \"<pre><code>\" + codeblock + \"\\n</code></pre>\";\n\n            return hashBlock(codeblock) + nextChar;\n        }\n    );\n\n    // attacklab: strip sentinel\n    text = text.replace(/~0/,\"\");\n\n    return text;\n};\n\nvar _DoGithubCodeBlocks = function(text) {\n//\n//  Process Github-style code blocks\n//  Example:\n//  ```ruby\n//  def hello_world(x)\n//    puts \"Hello, #{x}\"\n//  end\n//  ```\n//\n\n\n    // attacklab: sentinel workarounds for lack of \\A and \\Z, safari\\khtml bug\n    text += \"~0\";\n\n    text = text.replace(/(?:^|\\n)```(.*)\\n([\\s\\S]*?)\\n```/g,\n        function(wholeMatch,m1,m2) {\n            var language = m1;\n            var codeblock = m2;\n\n            codeblock = _EncodeCode(codeblock);\n            codeblock = _Detab(codeblock);\n            codeblock = codeblock.replace(/^\\n+/g,\"\"); // trim leading newlines\n            codeblock = codeblock.replace(/\\n+$/g,\"\"); // trim trailing whitespace\n\n            codeblock = \"<pre><code\" + (language ? \" class=\\\"\" + language + '\"' : \"\") + \">\" + codeblock + \"\\n</code></pre>\";\n\n            return hashBlock(codeblock);\n        }\n    );\n\n    // attacklab: strip sentinel\n    text = text.replace(/~0/,\"\");\n\n    return text;\n}\n\nvar hashBlock = function(text) {\n    text = text.replace(/(^\\n+|\\n+$)/g,\"\");\n    return \"\\n\\n~K\" + (g_html_blocks.push(text)-1) + \"K\\n\\n\";\n}\n\nvar _DoCodeSpans = function(text) {\n//\n//   *  Backtick quotes are used for <code></code> spans.\n//\n//   *  You can use multiple backticks as the delimiters if you want to\n//   include literal backticks in the code span. So, this input:\n//\n//       Just type ``foo `bar` baz`` at the prompt.\n//\n//     Will translate to:\n//\n//       <p>Just type <code>foo `bar` baz</code> at the prompt.</p>\n//\n//  There's no arbitrary limit to the number of backticks you\n//  can use as delimters. If you need three consecutive backticks\n//  in your code, use four for delimiters, etc.\n//\n//  *  You can use spaces to get literal backticks at the edges:\n//\n//       ... type `` `bar` `` ...\n//\n//     Turns to:\n//\n//       ... type <code>`bar`</code> ...\n//\n\n    /*\n        text = text.replace(/\n            (^|[^\\\\])                   // Character before opening ` can't be a backslash\n            (`+)                        // $2 = Opening run of `\n            (                           // $3 = The code block\n                [^\\r]*?\n                [^`]                    // attacklab: work around lack of lookbehind\n            )\n            \\2                          // Matching closer\n            (?!`)\n        /gm, function(){...});\n    */\n\n    text = text.replace(/(^|[^\\\\])(`+)([^\\r]*?[^`])\\2(?!`)/gm,\n        function(wholeMatch,m1,m2,m3,m4) {\n            var c = m3;\n            c = c.replace(/^([ \\t]*)/g,\"\"); // leading whitespace\n            c = c.replace(/[ \\t]*$/g,\"\");   // trailing whitespace\n            c = _EncodeCode(c);\n            return m1+\"<code>\"+c+\"</code>\";\n        });\n\n    return text;\n}\n\nvar _EncodeCode = function(text) {\n//\n// Encode/escape certain characters inside Markdown code runs.\n// The point is that in code, these characters are literals,\n// and lose their special Markdown meanings.\n//\n    // Encode all ampersands; HTML entities are not\n    // entities within a Markdown code span.\n    text = text.replace(/&/g,\"&amp;\");\n\n    // Do the angle bracket song and dance:\n    text = text.replace(/</g,\"&lt;\");\n    text = text.replace(/>/g,\"&gt;\");\n\n    // Now, escape characters that are magic in Markdown:\n    text = escapeCharacters(text,\"\\*_{}[]\\\\\",false);\n\n// jj the line above breaks this:\n//---\n\n//* Item\n\n//   1. Subitem\n\n//            special char: *\n//---\n\n    return text;\n}\n\n\nvar _DoItalicsAndBold = function(text) {\n\n    // <strong> must go first:\n    text = text.replace(/(\\*\\*|__)(?=\\S)([^\\r]*?\\S[*_]*)\\1/g,\n        \"<strong>$2</strong>\");\n\n    text = text.replace(/(\\*|_)(?=\\S)([^\\r]*?\\S)\\1/g,\n        \"<em>$2</em>\");\n\n    return text;\n}\n\n\nvar _DoBlockQuotes = function(text) {\n\n    /*\n        text = text.replace(/\n        (                               // Wrap whole match in $1\n            (\n                ^[ \\t]*>[ \\t]?          // '>' at the start of a line\n                .+\\n                    // rest of the first line\n                (.+\\n)*                 // subsequent consecutive lines\n                \\n*                     // blanks\n            )+\n        )\n        /gm, function(){...});\n    */\n\n    text = text.replace(/((^[ \\t]*>[ \\t]?.+\\n(.+\\n)*\\n*)+)/gm,\n        function(wholeMatch,m1) {\n            var bq = m1;\n\n            // attacklab: hack around Konqueror 3.5.4 bug:\n            // \"----------bug\".replace(/^-/g,\"\") == \"bug\"\n\n            bq = bq.replace(/^[ \\t]*>[ \\t]?/gm,\"~0\");   // trim one level of quoting\n\n            // attacklab: clean up hack\n            bq = bq.replace(/~0/g,\"\");\n\n            bq = bq.replace(/^[ \\t]+$/gm,\"\");       // trim whitespace-only lines\n            bq = _RunBlockGamut(bq);                // recurse\n\n            bq = bq.replace(/(^|\\n)/g,\"$1  \");\n            // These leading spaces screw with <pre> content, so we need to fix that:\n            bq = bq.replace(\n                    /(\\s*<pre>[^\\r]+?<\\/pre>)/gm,\n                function(wholeMatch,m1) {\n                    var pre = m1;\n                    // attacklab: hack around Konqueror 3.5.4 bug:\n                    pre = pre.replace(/^  /mg,\"~0\");\n                    pre = pre.replace(/~0/g,\"\");\n                    return pre;\n                });\n\n            return hashBlock(\"<blockquote>\\n\" + bq + \"\\n</blockquote>\");\n        });\n    return text;\n}\n\n\nvar _FormParagraphs = function(text) {\n//\n//  Params:\n//    $text - string to process with html <p> tags\n//\n\n    // Strip leading and trailing lines:\n    text = text.replace(/^\\n+/g,\"\");\n    text = text.replace(/\\n+$/g,\"\");\n\n    var grafs = text.split(/\\n{2,}/g);\n    var grafsOut = [];\n\n    //\n    // Wrap <p> tags.\n    //\n    var end = grafs.length;\n    for (var i=0; i<end; i++) {\n        var str = grafs[i];\n\n        // if this is an HTML marker, copy it\n        if (str.search(/~K(\\d+)K/g) >= 0) {\n            grafsOut.push(str);\n        }\n        else if (str.search(/\\S/) >= 0) {\n            str = _RunSpanGamut(str);\n            str = str.replace(/^([ \\t]*)/g,\"<p>\");\n            str += \"</p>\"\n            grafsOut.push(str);\n        }\n\n    }\n\n    //\n    // Unhashify HTML blocks\n    //\n    end = grafsOut.length;\n    for (var i=0; i<end; i++) {\n        // if this is a marker for an html block...\n        while (grafsOut[i].search(/~K(\\d+)K/) >= 0) {\n            var blockText = g_html_blocks[RegExp.$1];\n            blockText = blockText.replace(/\\$/g,\"$$$$\"); // Escape any dollar signs\n            grafsOut[i] = grafsOut[i].replace(/~K\\d+K/,blockText);\n        }\n    }\n\n    return grafsOut.join(\"\\n\\n\");\n}\n\n\nvar _EncodeAmpsAndAngles = function(text) {\n// Smart processing for ampersands and angle brackets that need to be encoded.\n\n    // Ampersand-encoding based entirely on Nat Irons's Amputator MT plugin:\n    //   http://bumppo.net/projects/amputator/\n    text = text.replace(/&(?!#?[xX]?(?:[0-9a-fA-F]+|\\w+);)/g,\"&amp;\");\n\n    // Encode naked <'s\n    text = text.replace(/<(?![a-z\\/?\\$!])/gi,\"&lt;\");\n\n    return text;\n}\n\n\nvar _EncodeBackslashEscapes = function(text) {\n//\n//   Parameter:  String.\n//   Returns:   The string, with after processing the following backslash\n//             escape sequences.\n//\n\n    // attacklab: The polite way to do this is with the new\n    // escapeCharacters() function:\n    //\n    //  text = escapeCharacters(text,\"\\\\\",true);\n    //  text = escapeCharacters(text,\"`*_{}[]()>#+-.!\",true);\n    //\n    // ...but we're sidestepping its use of the (slow) RegExp constructor\n    // as an optimization for Firefox.  This function gets called a LOT.\n\n    text = text.replace(/\\\\(\\\\)/g,escapeCharacters_callback);\n    text = text.replace(/\\\\([`*_{}\\[\\]()>#+-.!])/g,escapeCharacters_callback);\n    return text;\n}\n\n\nvar _DoAutoLinks = function(text) {\n\n    text = text.replace(/<((https?|ftp|dict):[^'\">\\s]+)>/gi,\"<a href=\\\"$1\\\">$1</a>\");\n\n    // Email addresses: <address@domain.foo>\n\n    /*\n        text = text.replace(/\n            <\n            (?:mailto:)?\n            (\n                [-.\\w]+\n                \\@\n                [-a-z0-9]+(\\.[-a-z0-9]+)*\\.[a-z]+\n            )\n            >\n        /gi, _DoAutoLinks_callback());\n    */\n    text = text.replace(/<(?:mailto:)?([-.\\w]+\\@[-a-z0-9]+(\\.[-a-z0-9]+)*\\.[a-z]+)>/gi,\n        function(wholeMatch,m1) {\n            return _EncodeEmailAddress( _UnescapeSpecialChars(m1) );\n        }\n    );\n\n    return text;\n}\n\n\nvar _EncodeEmailAddress = function(addr) {\n//\n//  Input: an email address, e.g. \"foo@example.com\"\n//\n//  Output: the email address as a mailto link, with each character\n//  of the address encoded as either a decimal or hex entity, in\n//  the hopes of foiling most address harvesting spam bots. E.g.:\n//\n//  <a href=\"&#x6D;&#97;&#105;&#108;&#x74;&#111;:&#102;&#111;&#111;&#64;&#101;\n//     x&#x61;&#109;&#x70;&#108;&#x65;&#x2E;&#99;&#111;&#109;\">&#102;&#111;&#111;\n//     &#64;&#101;x&#x61;&#109;&#x70;&#108;&#x65;&#x2E;&#99;&#111;&#109;</a>\n//\n//  Based on a filter by Matthew Wickline, posted to the BBEdit-Talk\n//  mailing list: <http://tinyurl.com/yu7ue>\n//\n\n    var encode = [\n        function(ch){return \"&#\"+ch.charCodeAt(0)+\";\";},\n        function(ch){return \"&#x\"+ch.charCodeAt(0).toString(16)+\";\";},\n        function(ch){return ch;}\n    ];\n\n    addr = \"mailto:\" + addr;\n\n    addr = addr.replace(/./g, function(ch) {\n        if (ch == \"@\") {\n            // this *must* be encoded. I insist.\n            ch = encode[Math.floor(Math.random()*2)](ch);\n        } else if (ch !=\":\") {\n            // leave ':' alone (to spot mailto: later)\n            var r = Math.random();\n            // roughly 10% raw, 45% hex, 45% dec\n            ch =  (\n                    r > .9  ?   encode[2](ch)   :\n                    r > .45 ?   encode[1](ch)   :\n                                encode[0](ch)\n                );\n        }\n        return ch;\n    });\n\n    addr = \"<a href=\\\"\" + addr + \"\\\">\" + addr + \"</a>\";\n    addr = addr.replace(/\">.+:/g,\"\\\">\"); // strip the mailto: from the visible part\n\n    return addr;\n}\n\n\nvar _UnescapeSpecialChars = function(text) {\n//\n// Swap back in all the special characters we've hidden.\n//\n    text = text.replace(/~E(\\d+)E/g,\n        function(wholeMatch,m1) {\n            var charCodeToReplace = parseInt(m1);\n            return String.fromCharCode(charCodeToReplace);\n        }\n    );\n    return text;\n}\n\n\nvar _Outdent = function(text) {\n//\n// Remove one level of line-leading tabs or spaces\n//\n\n    // attacklab: hack around Konqueror 3.5.4 bug:\n    // \"----------bug\".replace(/^-/g,\"\") == \"bug\"\n\n    text = text.replace(/^(\\t|[ ]{1,4})/gm,\"~0\"); // attacklab: g_tab_width\n\n    // attacklab: clean up hack\n    text = text.replace(/~0/g,\"\")\n\n    return text;\n}\n\nvar _Detab = function(text) {\n// attacklab: Detab's completely rewritten for speed.\n// In perl we could fix it by anchoring the regexp with \\G.\n// In javascript we're less fortunate.\n\n    // expand first n-1 tabs\n    text = text.replace(/\\t(?=\\t)/g,\"    \"); // attacklab: g_tab_width\n\n    // replace the nth with two sentinels\n    text = text.replace(/\\t/g,\"~A~B\");\n\n    // use the sentinel to anchor our regex so it doesn't explode\n    text = text.replace(/~B(.+?)~A/g,\n        function(wholeMatch,m1,m2) {\n            var leadingText = m1;\n            var numSpaces = 4 - leadingText.length % 4;  // attacklab: g_tab_width\n\n            // there *must* be a better way to do this:\n            for (var i=0; i<numSpaces; i++) leadingText+=\" \";\n\n            return leadingText;\n        }\n    );\n\n    // clean up sentinels\n    text = text.replace(/~A/g,\"    \");  // attacklab: g_tab_width\n    text = text.replace(/~B/g,\"\");\n\n    return text;\n}\n\n\n//\n//  attacklab: Utility functions\n//\n\n\nvar escapeCharacters = function(text, charsToEscape, afterBackslash) {\n    // First we have to escape the escape characters so that\n    // we can build a character class out of them\n    var regexString = \"([\" + charsToEscape.replace(/([\\[\\]\\\\])/g,\"\\\\$1\") + \"])\";\n\n    if (afterBackslash) {\n        regexString = \"\\\\\\\\\" + regexString;\n    }\n\n    var regex = new RegExp(regexString,\"g\");\n    text = text.replace(regex,escapeCharacters_callback);\n\n    return text;\n}\n\n\nvar escapeCharacters_callback = function(wholeMatch,m1) {\n    var charCodeToEscape = m1.charCodeAt(0);\n    return \"~E\"+charCodeToEscape+\"E\";\n}\n\n} // end of Showdown.converter\n\n\n// export\nif (typeof module !== 'undefined') module.exports = Showdown;\n\n// stolen from AMD branch of underscore\n// AMD define happens at the end for compatibility with AMD loaders\n// that don't enforce next-turn semantics on modules.\nif (typeof define === 'function' && define.amd) {\n    define('showdown', [],function() {\n        return Showdown;\n    });\n};","\ndefine('NuclearHorseStudios',[\n    'angular', \n    'ngResource', \n    'ngRoute',\n    'Controllers',\n    'DbTypeFactory',\n    'MarkDownFilter',\n    'BlogPostDateFilter',\n    'RouteProvider',\n    'underscore',\n    'showdown'], \n    \n    function(   \n        angular, \n        ngResource, \n        ngRoute, \n        Controllers,\n        DbTypeFactory,\n        MarkDownFilter,\n        BlogPostDateFilter,\n        RouteProvider) {\n        \n        var blogDataFactory = DbTypeFactory('blogpost', \n                                            'http://nuclearhorsestudios.com', \n                                            'nuclearhorseblog',\n                                            '_design/blog');\n        \n        return angular.module('NuclearHorseStudios', ['ngResource', 'ngRoute'])\n                      .controller(Controllers)\n                      .filter('markdown', ['$sce', MarkDownFilter])\n                      .filter('blogPostDate', BlogPostDateFilter)\n                      .factory('blogData', blogDataFactory)\n                      .config([ '$routeProvider', RouteProvider ]);\n    }\n);"]}